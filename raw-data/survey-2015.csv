Timestamp,How long have you been programming (in any language)?,Would you say you have a strong academic or theoretical background?,How would you characterize your use of F# today?,"If you were using F# but have now stopped, please tell us why:",F# news and activities,What have you found to be the best way of learning how to use F#?,How useful have F# books been for you?,What is the status of F# in your workplace?,In which domain(s) are you using F#?,"What kind of ""published"" code have you created with F#?",What kind of data sources are you using F# with?,Development environment ,Platforms ,"If you are deploying code written in F#, which platforms do you target?",Which other platform(s) would you be interested in using F# on?,What are your primary programming languages (in addition to F#),"Q: If F# disappeared tomorrow, what language(s) might you use as a “replacement”?",What have been the biggest benefits to you *personally* in using F#? ,How comfortable are you with functional programming in general?,What features in F# do you rarely or never use?,What has been the most frustrating thing for you in *learning* F#?,What stops your workplace from using F# more than it does now?,What kind of training/documentation appeals to you?,What do you think is F#’s most glaring weakness / blind spot / problem?,How long have you been using F#?,Any other comments?,How would you classify your day job?,Frustrations with F# enovironment?,What has been the most frustrating for you in *developing applications* in F#?,Biggest benefits of F# at work,What are your favorite features in F#? ,How can learning F# be made easier?,What could the F# community do to make it more acceptable to your workplace?,What kinds of learning material would you like to see more of?,How could this survey be improved?
12/04/2015 02:26:54,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, HN, Reddit and other programming news sites, F# bloggers","MSDN, F# bloggers, Links posted on social media such as Twitter, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Mainstream business & enterprise applications",Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR,"C#, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Quotations, Static type constraints","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,3-4 years,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market","Algebraic types (inc discriminated unions and tuples), Async workflows, Immutability by default, Interactive development, No dependency cycles, Object expressions, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
12/04/2015 18:01:12,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# bloggers",F# books,,It's officially endorsed for critical/production areas,"Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Financial services, Machine learning, Mainstream business & enterprise applications, Data analysis/statistics, Text analysis/language parsing",Internal enterprise projects,"SQL databases, Analytics",Visual Studio 2012 or newer,"Windows, Linux",Windows,,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Async workflows, Computation expressions, Quotations, Static type constraints, Units of measure",,Nothing. Everyone loves it.,I'm willing to learn advanced concepts but only if they are relevant and practical,Many strong points but not a single killer story / practical use case.,4 or more years,,,,Cross-platform issues,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Interactive development, The ""piping"" idiom, Type providers","Having examples of actual applications/solutions end-to-end, instead of a collection of isolated snippets.",,,
12/04/2015 19:03:31,5-10 years,"No, I don't know much theory",I use it for student work,,"Twitter, F# bloggers",Links and instructions from fsharp.org,,It's used unofficially,"Utilities and tools, Games, Other","Internal enterprise projects, Commercial products","SQL databases, NoSQL database, Read-only data sources such as feeds",Visual Studio 2012 or newer,"Windows, Mac, Linux","Windows, Linux, iOS, Android, Azure",Native,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Agents (MailboxProcessor),,No buy-in: There is lack of acceptance from other teams,I want to learn functional programming but I don't like academic jargon,,1-2 years,,Student,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling",More productive with fewer developers,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Interactive development, printf that is type checked, The ""piping"" idiom, Type providers",,,More material with in-depth tutorials,
12/04/2015 19:07:31,5-10 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# bloggers","F# books, F# bloggers, Reading F# code written by experts",,It's officially endorsed for critical/production areas,Mainstream business & enterprise applications,"Commercial products, Open source projects",NoSQL database,Visual Studio 2012 or newer,Windows,Windows,JVM,"C#, Haskell",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Quotations, Static type constraints, Type providers, Units of measure",,,,,4 or more years,,Enterprise development,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Backtick naming, Immutability by default, No dependency cycles, The ""piping"" idiom, Type inference",,,,
12/04/2015 19:22:20,5-10 years,"No, I don't know much theory",I use it at work or for other commercial uses,,Twitter,"F# books, F# bloggers, Answers to Stack Overflow questions",,,Utilities and tools,Commercial products,Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,Windows,Native,,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Object expressions, Object-oriented compatibility, Quotations, Units of measure",Not enough real-world code to learn from,,I'm willing to learn advanced concepts but only if they are relevant and practical,The lack of official ASP.NET support from MS.,4 or more years,,Data or analytics related,,"Less sophisticated tools for refactoring, etc.",Easy concurrency with async and agents,"Agents (MailboxProcessor), Async workflows, Easy integration with other .NET libraries, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories","How about adding the F# weekly to the ""F# news and activities"" section?"
12/04/2015 19:25:52,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, slack (functional programming)","F# books, F# bloggers, Links posted on social media such as Twitter, Personal mentoring, Videos (e.g. Community for F#), hands on events",,It's officially endorsed for critical/production areas,Games,"Commercial products, Open source projects",Not doing data centric apps,Visual Studio 2012 or newer,"Windows, Linux","Windows, Android, Other",Native,C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Quotations, Units of measure",it would have been harder without power tools,"Training: They are worried about getting non-F# developers up to speed, performance",I like theory -- I'm not afraid of monads and other abstractions,Being associated with Microsoft,1-2 years,,backend,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Performance issues","Correctness: fewer bugs and less rework, More productive with fewer developers","Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, Type inference, Type providers",Wish I knew,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, getting started in F# without .net background would increase the community ",
12/04/2015 19:30:06,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,Twitter,"Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Videos (e.g. Community for F#), fsharpforfunandprofit.com",,It's officially endorsed for critical/production areas,Research/Teaching,Instrument control code for a scientific experiment,Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C, C#, Python",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Great community, Having fun again",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Quotations,Not enough real-world code to learn from,Training: They are worried about getting non-F# developers up to speed,I'm willing to learn advanced concepts but only if they are relevant and practical,There is a lot of excitement about cloud and web-based applications in F# but we just need to build a robust local application which demands concurrency and modularity. Building Windows UI in F# isn't well integrated with the toolchain so we use C# but it does add the cost of maintaining code in two languages.,Less than a year,,"Academic, research, or related",,Had trouble combining Events/Observables with Async workflows,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems, Readability","Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, No dependency cycles, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, The ""piping"" idiom, Type inference, Type providers, Units of measure",It would be interesting to see some tutorials showing how to make some imperative code declarative step-by-step.,,More interactive tutorials (e.g. like the F# Koans),
12/04/2015 19:34:44,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Videos (e.g. Community for F#), Reading F# code written by experts",,It's used unofficially,"None - Just playing around, Utilities and tools, Other",Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,Windows,"Javascript, LLVM, Native","C#, Java, Perl",,"Conciseness of code (I can see more at a glance), Having fun again, Speed of development","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Static type constraints, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,2-3 years,,Enterprise development,,"Less sophisticated tools for refactoring, etc.",Faster time to market,"Algebraic types (inc discriminated unions and tuples), Object expressions, printf that is type checked, The ""piping"" idiom, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
12/04/2015 20:06:22,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"Google groups, F# bloggers","MSDN, F# books, F# bloggers, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,It's used unofficially,"Algorithm-heavy business applications (non-financial), Machine learning, Text analysis/language parsing","Internal enterprise projects, Commercial products","SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,"Windows, Android, WinPhone","None -- I'm happy with the CLR/Mono, JVM","C#, C++",,"Having fun again, Speed of development, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Interactive development, Quotations","Lack of good tutorials/documentation, Don't understand the compiler errors, Unpleasant interactions with the community, Not enough real-world code to learn from","Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Enterprise development,,"Lack of good wrappers for non-F# libraries, Working with C#-centric tooling",Faster time to market,"Active Patterns, Async workflows, No dependency cycles, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
12/04/2015 20:21:24,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, Google groups, F# bloggers","Links and instructions from fsharp.org, F# bloggers, Personal mentoring, Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Algorithm-heavy business applications (non-financial), Machine learning, Data analysis/statistics, Text analysis/language parsing",Internal enterprise projects,"SQL databases, NoSQL database, Analytics",Visual Studio 2012 or newer,Windows,Windows,"LLVM, Native","C#, Go",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Quotations,"Don't understand the compiler errors, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Faster time to market, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Async workflows, Easy integration with other .NET libraries, Immutability by default, Object expressions, printf that is type checked, Quotations, Type inference, Type providers",,,"More material with short ""cookbook"" style information, More short ""live coding"" videos, More podcasts and other audio-only material",
12/04/2015 20:25:18,2-5 years,"No, I don't know much theory",I use it for research or academic work,,"Twitter, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,"Algorithm-heavy business applications (non-financial), Machine learning, Mobile apps, Text analysis/language parsing",Internal enterprise projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, iOS",None -- I'm happy with the CLR/Mono,C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Quotations, Static type constraints, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,"Academic, research, or related",,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Faster time to market, Easy concurrency with async and agents, Better for solving complex problems","Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Immutability by default, Interactive development, The ""piping"" idiom, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos",
12/04/2015 21:07:15,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# bloggers","F# books, F# bloggers, Links posted on social media such as Twitter, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Algorithm-heavy business applications (non-financial), Research/Teaching","Internal enterprise projects, Open source projects","SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,"Windows, Linux","LLVM, Native",C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Object-oriented compatibility, Quotations, Static type constraints",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Data or analytics related,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with Hopac","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Object expressions, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
12/04/2015 21:12:46,10 or more years,"No, I don't know much theory",I use it for research or academic work,,Twitter,"F# books, F# bloggers, Answers to Stack Overflow questions, Personal mentoring, Reading F# code written by experts",,It's officially endorsed for critical/production areas,Research/Teaching,Commercial products,,Visual Studio 2012 or newer,Windows,Windows,Javascript,Python,,"Correctness (no nulls, it works first time)",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Async workflows,Not enough real-world code to learn from,Training: They are worried about getting non-F# developers up to speed,I'm willing to learn advanced concepts but only if they are relevant and practical,"Just needs a bigger user base. More examples of similar uses to my own would be a huge boon. 

Also, more resources on optimisation",1-2 years,,"Academic, research, or related",,Performance issues,Correctness: fewer bugs and less rework,Units of measure,,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
12/04/2015 21:20:57,10 or more years,"Yes, I enjoy computer science and mathematics","in transition between ""side project"" and ""at work""",,"Twitter, Google groups, F# bloggers","MSDN, F# books, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Algorithm-heavy business applications (non-financial), Data analysis/statistics",data stream handling ,Data integration and EAI,Visual Studio 2012 or newer,Windows,Windows,Javascript,"R, Visual Basic",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Computation expressions, Object expressions","Installation process, learning the .NET ecosystem ",not yet in discussion on a strategic level,I like theory -- I'm not afraid of monads and other abstractions,F# is probably on the way from Microsoft to Open Source nowhere land.,2-3 years,,Data or analytics related,,"Not being part of the core .NET distribution, Working with C#-centric tooling","Correctness: fewer bugs and less rework, Faster time to market, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), No dependency cycles, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom",,,More material with in-depth tutorials,
12/04/2015 21:46:58,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# bloggers","F# books, F# bloggers, Answers to Stack Overflow questions",,It's used unofficially,"Utilities and tools, Machine learning, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Open source projects","SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,"JVM, Native",C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Async workflows, Object expressions, Quotations, Units of measure",Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,"Type abstraction - it doesn't have type classes, and interfaces are clunky to use and don't easily support abstracting over types created by others (e.g., core .NET types). ",3-4 years,,Data or analytics related,,Performance issues,"Correctness: fewer bugs and less rework, Faster time to market","Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,Find a killer app - something akin to what Spark is to Scala. ,"More material with in-depth tutorials, More interactive tutorials (e.g. like the F# Koans)",
12/04/2015 22:04:24,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, HN, Reddit and other programming news sites, F# bloggers, Slack Chat","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Reading F# code written by experts, Meetups",,It's officially endorsed for critical/production areas,"Utilities and tools, Custom development/specialist markets, Machine learning, Mainstream business & enterprise applications, Data analysis/statistics","Commercial products, Open source projects","SQL databases, NoSQL database, Event sourcing, Read-only data sources such as feeds, Analytics",Visual Studio 2012 or newer,Windows,"Windows, Azure",None -- I'm happy with the CLR/Mono,"C#, Typescript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Object expressions, Quotations, Units of measure","I can't use my knowledge from C# or other imperative languages, Don't understand the compiler errors, Not enough real-world code to learn from",No buy-in: There is lack of acceptance from other teams,I like theory -- I'm not afraid of monads and other abstractions,As a language? I would love to see better support for structural typing in it.,3-4 years,,Cloud,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Faster time to market, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers","It depends who for. If for the C# developer, things such as error messages and intellisense is often too ""other worldly"" and scares them off (rightly or wrongly, but I see it happen all the time).

Integration of Power Tools into VS would also be a big help I think.","Not so much my workplace - I have control over what languages we use. But in general, the perception that it's ""too hard to learn"" is still something that we as a community need to work on.","More material with in-depth tutorials, More material with real-world examples and war stories, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
12/04/2015 22:05:21,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, HN, Reddit and other programming news sites",F# books,,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Mainstream business & enterprise applications","Commercial products, Open source projects",SQL databases,Visual Studio 2012 or newer,"Windows, Mac",Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Async workflows, Computation expressions, Object expressions, Object-oriented compatibility, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I like theory -- I'm not afraid of monads and other abstractions,,3-4 years,,Enterprise development,,Working with C#-centric tooling,"Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents","Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Immutability by default, No dependency cycles, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,,
12/04/2015 22:25:42,2-5 years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,Twitter,"F# books, Answers to Stack Overflow questions",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Research/Teaching",Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,"LLVM, Native","C#, Ocaml/SML",,"Correctness (no nulls, it works first time), Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Quotations",Not enough real-world code to learn from,Training: They are worried about getting non-F# developers up to speed,I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,"Academic, research, or related",,Lack of good wrappers for non-F# libraries,Correctness: fewer bugs and less rework,"Active Patterns, Object expressions",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
12/04/2015 22:29:01,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,Twitter,"F# books, F# bloggers, Links posted on social media such as Twitter",,It's used unofficially,"Utilities and tools, Machine learning, Mainstream business & enterprise applications, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Open source projects",NoSQL database,Visual Studio 2012 or newer,Windows,Windows,Native,C#,,"Great community, Having fun again, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor), Static type constraints, Units of measure",Not enough real-world code to learn from,"Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,2-3 years,,Enterprise development,,,"Correctness: fewer bugs and less rework, Faster time to market","Algebraic types (inc discriminated unions and tuples), Interactive development, The ""piping"" idiom, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
12/04/2015 22:36:28,2-5 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# bloggers, Slack channel","F# books, F# bloggers, Links posted on social media such as Twitter, Videos (e.g. Community for F#), Reading F# code written by experts, contributing to OSS",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Other","Open source projects, thesis project",SQL databases,Visual Studio 2012 or newer,Windows,,Javascript,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Object expressions, Units of measure",Don't understand the compiler errors,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Faster time to market, Easy concurrency with async and agents","Algebraic types (inc discriminated unions and tuples), Interactive development, The ""piping"" idiom, Type inference, Type providers",,,"More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
12/04/2015 22:39:27,10 or more years,"No, I don't know much theory",Just tinkering,,F# bloggers,"F# books, F# bloggers, Reading F# code written by experts",,It's used unofficially,"None - Just playing around, Mainstream business & enterprise applications",Internal enterprise projects,"SQL databases, Data integration and EAI",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Async workflows, Integration with non-F# libraries",Not enough real-world code to learn from,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Haven't really used it yet,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with real-world examples and war stories, More short ""live coding"" videos",
12/04/2015 22:49:12,2-5 years,"No, I don't know much theory",I use it for hobby or side projects,,F# bloggers,"MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Custom development/specialist markets, Machine learning, Mainstream business & enterprise applications, Research/Teaching","Internal enterprise projects, Not applicable. None of my F# code is used by other people","SQL databases, NoSQL database, Data integration and EAI",MonoDevelop,"Windows, Linux","Windows, Linux, iOS, Android, WinPhone, Other","JVM, LLVM, Native",C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Computation expressions, Interactive development","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Too Windows-centric: They have concerns over cross-platform issues",I like theory -- I'm not afraid of monads and other abstractions,So many c# coders.,1-2 years,,Enterprise development,,"Lack of F# friendly libraries, Working with C#-centric tooling","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, Object expressions, printf that is type checked, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type providers",It's almost easy,More lessons &videos in russian lang. Some people like scals cose it opensource. But they dont like f# cose smell microsoft.,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
12/04/2015 22:55:56,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Google+, F# bloggers",F# books,,It's used unofficially,Utilities and tools,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2010 or older,Windows,Windows,,"C#, C++, PowerShell",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Object expressions, Object-oriented compatibility, Quotations",Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Enterprise development,,Working with C#-centric tooling,Type-safe scripting,"Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference","I'm not sure I can answer this for the general case, as I came to F# after picking up Erlang and doing a substantial project with it; so my biggest hurdles were adapting to static typing (and the type signature notation) and the top-to-bottom order of interpretation. ",It would have to become an expected part of university courses so that eventually there's a large enough cohort of people who have used the language.,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
12/04/2015 23:44:24,5-10 years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly",,It's used unofficially,"Utilities and tools, Text analysis/language parsing",Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,Windows,"Javascript, Native","C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Interactive development, Static type constraints, Units of measure",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,Tooling around debugging and source code viewing.,1-2 years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Immutability by default, Object expressions, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,Teaching materials would be helpful. Right now I just have to turn someone's interest or my evangelism into a 'teaching moment'.  Nut honestly most of the push back comes because people don't want to learn a new thing.,More material with real-world examples and war stories,
12/04/2015 23:49:06,,,Just tinkering,,,,,,,,,,Windows,,,,,,"Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,,,I'm willing to learn advanced concepts but only if they are relevant and practical,"Always talks about C# and Haskell.

Needs more material that goes beyond the F# language, where the F# language is just the means for transmitting ideas that even non F# programmers will find useful.

There are such materials out there, but they're typically packaged and written with the goal of ""this is why you should learn F#"" instead of ""here's a cool idea you should try"".


Examples

I never wanted to dig deeper into C, but I wanted to understand K&R's CSV parser.
So I dug deeper.

I never wanted to learn Scheme, but I always wanted to understand infinite streams in SICP.
So, I learned it.
",Less than two months,,,,,,,"Link seemingly arbitrary decisions in the language/library to values deeply held by F# programmers.

Some of those decisions can be very frustrating to a beginner and understanding why such decisions were made should help the learning process. For example, why does Seq.skip throw where Linq's skip and Haskell's drop do not?

",,,
12/04/2015 23:46:41,2-5 years,"No, I don't know much theory",Just tinkering,,"Twitter, F# Weekly","MSDN, F# books, F# bloggers, Links mentioned in F# Weekly",,It's used unofficially,Utilities and tools,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,"JVM, LLVM","C#, Python, Rust",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,Not enough real-world code to learn from,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,,I was using F# but have stopped,,Enterprise development,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Active Patterns, Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 00:48:44,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"F# Weekly, HN, Reddit and other programming news sites, F# bloggers","MSDN, F# books, F# bloggers, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,It's used unofficially,"None - Just playing around, Algorithm-heavy business applications (non-financial)",Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Visual Basic",,Learning functional programming in general,"Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Async workflows, Integration with non-F# libraries, Quotations","Lack of good tutorials/documentation, Not enough real-world code to learn from",No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,Working with C#-centric tooling,"Correctness: fewer bugs and less rework, Better for solving complex problems","Easy integration with other .NET libraries, Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 01:30:24,,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# bloggers","MSDN, F# books, F# bloggers, Links posted on social media such as Twitter, Answers to Stack Overflow questions, Reading F# code written by experts",,It's officially endorsed for critical/production areas,Other,Commercial products,Not doing data centric apps,Visual Studio 2012 or newer,"Windows, Mac",Windows,"JVM, Javascript, LLVM, Native","C#, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Object-oriented compatibility, Type providers, Units of measure",,,I'm willing to learn advanced concepts but only if they are relevant and practical,"- It's dependence on the .NET runtime.
- The type system, while great, could be more sophisticated, with built in support for features like higher-kinded types or OCaml-style functors.
- I didn't find any practical use for Type Providers yet. Sure it's cool to play with some data in your IDE, etc. I tried to find how can I use this seemingly powerful feature in my application, but alas.
- I think F# would really shine with stronger support for compile time meta-programming. Think Scala macros but not as ugly. Nemerle is really great in this respect.",3-4 years,,Consumer application development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Units of measure",More widespread support outside Visual Studio. Xamarin Sketch is great but crashes all the time. Emacs is a pain to configure. So is Vim. Is there even support for Sublime? Etc.,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 01:32:48,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly","F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial)","Internal enterprise projects, Open source projects",SQL databases,Visual Studio 2012 or newer,Windows,Windows,Native,SQL,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Quotations",n/a,1st class science and statistics libraries,I like theory -- I'm not afraid of monads and other abstractions,"Lack of professional quality support tools like:
FSharp.Formatting needs to be better, not enterprise ready
professional quality charting
Python beats F# on science/engineering library support",3-4 years,,Enterprise development,,"Lack of F# friendly libraries, Working with C#-centric tooling","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Immutability by default, No dependency cycles, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with short ""cookbook"" style information",
13/04/2015 01:40:10,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,Mobile apps,"Internal enterprise projects, App for a non-profit via Xamarin","SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,"Windows, Mac","Windows, iOS, Azure",None -- I'm happy with the CLR/Mono,"C#, Javascript",,"Conciseness of code (I can see more at a glance), Great community, Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I want to learn functional programming but I don't like academic jargon,,Less than a year,,Enterprise development,,Difficulty in troubleshooting problems,Correctness: fewer bugs and less rework,"Active Patterns, Easy integration with other .NET libraries, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 01:41:34,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, Google groups, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Mainstream business & enterprise applications, Mobile apps, Other","Internal enterprise projects, Open source projects","SQL databases, Not doing data centric apps",Visual Studio 2012 or newer,"Windows, Mac","Windows, iOS, Android, WinPhone, Azure","JVM, Javascript","C#, Javascript, TypeScript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Quotations",Not enough real-world code to learn from,Nothing. Everyone loves it.,I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,"Not being part of the core .NET distribution, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Immutability by default, No dependency cycles, Type inference, Type providers, Units of measure",,Encourage and help Microsoft and Xamarin to make F# a real first class language.,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 01:45:22,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,Twitter,"F# books, F# bloggers, Reading F# code written by experts",,It's officially endorsed for critical/production areas,Mainstream business & enterprise applications,"Commercial products, Open source projects","SQL databases, NoSQL database",Visual Studio 2012 or newer,"Windows, Mac, Linux",Linux,None -- I'm happy with the CLR/Mono,"C, C#, C++, Haskell, Java, Javascript, Objective-C, Ocaml/SML, Perl, PHP",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),Type providers,,Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,Enterprise development,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 01:52:33,10 or more years,"No, I don't know much theory",Just tinkering,Haven't understood FP well yet,Twitter,F# books,,,,,,Visual Studio 2012 or newer,"Windows, Mac",,,"C#, Javascript",,,Beginner (For example: you know OO well and functional programming seems strange),,"Lack of good tutorials/documentation, I can't use my knowledge from C# or other imperative languages, Not enough real-world code to learn from",,I want to learn functional programming but I don't like academic jargon,,I was using F# but have stopped,,Enterprise development,,,,,A lot of videos,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 02:00:10,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, Google groups, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Custom development/specialist markets, Mainstream business & enterprise applications, Mobile apps","Internal enterprise projects, Commercial products, Open source projects",SQL databases,I also use vim,Linux,"Linux, iOS, Android","None -- I'm happy with the CLR/Mono, Javascript, Native","C#, Javascript, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Integration with non-F# libraries, Interactive development, Object-oriented compatibility, Quotations, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,"I really think it would have been more popular if it had been born into a different community other than Microsoft. I'd like to see more crypto/privacy initiatives leveraging provable correctness, etc. e.g. miTLS and fstar.",2-3 years,,Financial services or similar,,Its association with Microsoft,"Domain modelling: making illegal states unrepresentable, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Immutability by default, No dependency cycles, Object expressions, printf that is type checked, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,Get c# to stop stealing its best features.,"More material with in-depth tutorials, More material with real-world examples and war stories, More podcasts and other audio-only material",
13/04/2015 02:00:53,10 or more years,,I use it at work or for other commercial uses,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers, StackOverflow chat","Links and instructions from fsharp.org, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Custom development/specialist markets, Mainstream business & enterprise applications, Research/Teaching, Text analysis/language parsing, Other","Internal enterprise projects, Commercial products","SQL databases, NoSQL database, Event sourcing, Data integration and EAI",Visual Studio 2012 or newer,Windows,"Windows, WinPhone, Azure","JVM, Javascript, LLVM, Native","C, C#, C++, Haskell, Java, Visual Basic",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,"Don't understand the compiler errors, Intellisense could be more polished, enriched. I have not really had enough time to get a good flow or process,","No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams, Think OO is only way to go.",I like theory -- I'm not afraid of monads and other abstractions,"I am incredibly impressed with F#. On a personal level, I think F# (ML) and Haskell are legitimate steps toward the languages that we will use in the future. So, I am mostly comparing to Haskell (Microsoft Research  for the win!). F# has some type system weakness that even languages like Scala support -- I would love to F# roll in the latest in static type systems -- higher kinds, effect systems, refinement types, etc.",2-3 years,Thanks for such a great community!,Enterprise development,,"Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems, I enjoy programming again","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Immutability by default, No dependency cycles, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, principled ",,"For what it is worth, I am totally convinced.
For my organization, it would be high profile, successful projects that have been written in F#. Additionally, showing how it can be used to create Web applications (both server and compiling to javascript) would be helpful for where we are going. I am very excited about leveraging its new cross platform capabilities. It is hard for me to guess, but anyone of those three could be the ones that convince my organization.
","More material with in-depth tutorials, More podcasts and other audio-only material","On the question of how comfortable with functional programming are you, none of the categories really fit me. I have been an OO programmer for a long time, then through Erik Meijer and LINQ and Bart de Smet and others got a glimpse of the principles of functional programming - I am thoroughly convinced in its superiority, but I am not really that good or experienced in it, although I have jumped into the theory side as much as my brain allows."
13/04/2015 02:02:21,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, HN, Reddit and other programming news sites, F# bloggers","Links and instructions from fsharp.org, F# bloggers, Links posted on social media such as Twitter, Videos (e.g. Community for F#), Reading F# code written by experts",,It's used unofficially,Data analysis/statistics,Commercial products,SQL databases,Visual Studio 2012 or newer,Windows,Windows,"JVM, Native","C#, Javascript",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Units of measure",Not enough real-world code to learn from,Training: They are worried about getting non-F# developers up to speed,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,digital agency,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market","Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Type providers",,,"More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 03:15:01,2-5 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers, JabbR","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,I don't use F# at work,"Utilities and tools, Mainstream business & enterprise applications, Research/Teaching, Data analysis/statistics, Other","Open source projects, Soon-to-be commercial software","SQL databases, NoSQL database, Event sourcing",Visual Studio 2012 or newer,Windows,"Windows, Azure","None -- I'm happy with the CLR/Mono, Javascript","C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Async workflows, Quotations, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Fad: They have concerns over long term language viability, They see some benefits, but ""we're already good at C#, and the differences aren't enough to convert us""",I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,,,"Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Backtick naming, Easy integration with other .NET libraries, Immutability by default, No dependency cycles, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",A full book series would be awesome.,Show F# use in more BLOBAs. Play-by-plays.,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 03:22:29,10 or more years,,I use it at work or for other commercial uses,,"Twitter, HN, Reddit and other programming news sites, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, Answers to Stack Overflow questions, Reading F# code written by experts",,It's used unofficially,Mainstream business & enterprise applications,Internal enterprise projects,"SQL databases, NoSQL database, Event sourcing",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript, Visual Basic",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Units of measure,Don't understand the compiler errors,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market","Active Patterns, Agents (MailboxProcessor), Easy integration with other .NET libraries, Immutability by default, No dependency cycles, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 04:19:29,5-10 years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, HN, Reddit and other programming news sites","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Answers to Stack Overflow questions",,I don't use F# at work,"Utilities and tools, Mobile apps",Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux, Azure","JVM, Javascript, Native","C#, Haskell, Java, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Quotations","Lack of good tutorials/documentation, Not enough real-world code to learn from","Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,"Not being part of the core .NET distribution, Less sophisticated tools for refactoring, etc.",,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Interactive development, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 04:36:18,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly","F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Personal mentoring, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Financial services, Machine learning, Mobile apps, Data analysis/statistics","Internal enterprise projects, Commercial products, Open source projects","SQL databases, Event sourcing, Read-only data sources such as feeds, Data integration and EAI",Visual Studio 2012 or newer,"Windows, Mac","Windows, Mac, iOS, Azure","None -- I'm happy with the CLR/Mono, Native","Python, T-SQL",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),Agents (MailboxProcessor),Even better quality of F# compiler and IDE. We need Roslyn like quality and extensibility.,Even better quality of F# compiler and IDE. We need Roslyn like quality and extensibility.,I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Data or analytics related,,"Less sophisticated tools for refactoring, etc., Even better quality of F# compiler and IDE. We need Roslyn like quality and extensibility.","Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, Interactive development, Object expressions, printf that is type checked, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 04:37:57,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly","Links mentioned in F# Weekly, Videos (e.g. Community for F#), Reading F# code written by experts, fsharpforfunandprofit",,It's used unofficially,"Utilities and tools, Algorithm-heavy business applications (non-financial), Data analysis/statistics",Commercial products,"SQL databases, NoSQL database, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Javascript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Object-oriented compatibility, Quotations, Static type constraints",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,No type classes or dependant types ,4 or more years,,"Academic, research, or related",,Working with C#-centric tooling,"Correctness: fewer bugs and less rework, More productive with fewer developers","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Type inference, Type providers, structural equality",,,More interactive tutorials (e.g. like the F# Koans),
13/04/2015 04:58:17,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly","F# books, Personal mentoring",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Machine learning, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Commercial products, Open source projects",SQL databases,Visual Studio 2012 or newer,Windows,Windows,"LLVM, Native","C#, C++, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Units of measure",Lack of good tutorials/documentation,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,Data or analytics related,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Computation expressions, Quotations, Type inference, Type providers",,,More interactive tutorials (e.g. like the F# Koans),
13/04/2015 05:10:41,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications","Internal enterprise projects, Open source projects","SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,"Windows, WinPhone, Azure",Native,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Units of measure",Don't understand the compiler errors,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Enterprise development,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Faster time to market, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, Interactive development, No dependency cycles, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 05:23:49,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, HN, Reddit and other programming news sites, F# bloggers","Links and instructions from fsharp.org, F# bloggers, Answers to Stack Overflow questions, tryfsharp.org",,It's officially endorsed for critical/production areas,"Utilities and tools, Machine learning, Data analysis/statistics, Text analysis/language parsing",Internal enterprise projects,"Read-only data sources such as feeds, Analytics",Visual Studio 2012 or newer,Windows,Windows,"Javascript, Native","C#, C++, Python",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Object expressions, Quotations, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from, websharper is a great example of a really powerful architecture that's poorly documented.  Simple day-to-day DOM manipulation tasks in particular are not explained anywhere.","Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,"Like all functional languages it can be a steep ramp-up for conventional programmers, especially those without formal training in programming languages (ie a B.Sc.)",1-2 years,"Special mentions go to Sergey Tihon's blog, the F# subreddit and Don Syme and Thomas Petricek's frequent tweets/posts/talks.

I love this language and how it shapes how I think about programming.",Data or analytics related,,"Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Easy integration with other .NET libraries, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,Continue to be awesome.,More interactive tutorials (e.g. like the F# Koans),You might also want to learn the sizes of the shops using F#.  Are they small startups or big corporate environments?
13/04/2015 05:33:45,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, Google+, F# bloggers","F# bloggers, Links mentioned in F# Weekly",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications, Text analysis/language parsing","Internal enterprise projects, Open source projects","SQL databases, Event sourcing",Visual Studio 2012 or newer,"Windows, Linux",Windows,"Javascript, LLVM","C#, Haskell, Visual Basic",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Great community, Having fun again",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Quotations, Type providers, Units of measure",embrace math and academia,Training: They are worried about getting non-F# developers up to speed,I like theory -- I'm not afraid of monads and other abstractions,no higher-kinded polymorphism - no type-classes nor ML style modules - almost certainly no development in this aspects as tied to the CLR,4 or more years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Easy concurrency with async and agents, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Computation expressions, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 06:15:13,5-10 years,"No, I don't know much theory",Use it for my own commercial projects (www.wcfstorm.com),,"HN, Reddit and other programming news sites","F# books, F# bloggers, Links mentioned in F# Weekly",,It's used unofficially,Utilities and tools,Commercial products,SQL databases,Visual Studio 2012 or newer,Windows,Windows,Native,C#,,"Conciseness of code (I can see more at a glance), Great community, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Computation expressions, Units of measure",Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, C# is more than good enough",I'm willing to learn advanced concepts but only if they are relevant and practical,F# biggest problem is that Microsoft's treats is a language that's secondary to C#.,4 or more years,,Enterprise development,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, Faster time to market","Active Patterns, Agents (MailboxProcessor), Easy integration with other .NET libraries, Immutability by default, Object expressions, The ""piping"" idiom, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information",
13/04/2015 06:39:27,2-5 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,Twitter,"MSDN, Links and instructions from fsharp.org, F# bloggers, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Xamarin,Mac,"Mac, iOS","LLVM, Native","C#, Javascript, Objective-C",,"Better domain modelling with records and unions, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,,Haven't really used it yet,,Enterprise development,,Performance issues,,"Algebraic types (inc discriminated unions and tuples), Async workflows, Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 06:39:59,2-5 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,F# Weekly,"Links and instructions from fsharp.org, F# bloggers, Links mentioned in F# Weekly, Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Azure,None -- I'm happy with the CLR/Mono,"C#, Javascript",,"Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,,Have not explored it,I want to learn functional programming but I don't like academic jargon,,Less than two months,,Enterprise development,,Not having an Idea of what I am doing,,"Active Patterns, No dependency cycles, The ""piping"" idiom, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More podcasts and other audio-only material",
13/04/2015 06:52:20,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly","F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly",,It's used unofficially,Utilities and tools,Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,"Windows, Azure","Javascript, Native","C#, Elixir, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Object-oriented compatibility, Units of measure",More support from microsoft,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Financial services or similar,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries",Correctness: fewer bugs and less rework,"Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material",
13/04/2015 07:12:06,2-5 years,"No, I don't know much theory",Just tinkering,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers",,It's used unofficially,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, Linux",Javascript,"C#, Javascript",,"Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Enterprise development,,,,"Agents (MailboxProcessor), Backtick naming, Computation expressions, The ""piping"" idiom, Type inference",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More podcasts and other audio-only material",
13/04/2015 07:29:59,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# bloggers, StackOverflow chat","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Videos (e.g. Community for F#)",,It's used unofficially,Utilities and tools,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Quotations",,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Enterprise development,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, printf that is type checked, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 07:33:02,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Custom development/specialist markets, Other","Internal enterprise projects, Open source projects",SQL databases,Visual Studio 2012 or newer,Windows,,JVM,"C, C#",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Object expressions, Object-oriented compatibility, Quotations, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Fad: They have concerns over long term language viability",I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,Enterprise development,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Simple ""one liner"" type definitions for records and DUs, Type inference, Type providers",Learning to code is not easy... ;-),More success stories maybe? ,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 08:04:55,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","F# books, F# bloggers, Links posted on social media such as Twitter, Structured training/workshops",,It's officially endorsed for critical/production areas,"Utilities and tools, Financial services, Other","Internal enterprise projects, Commercial products, Open source projects",Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,Javascript,C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Active Patterns, Quotations, Units of measure","Don't understand the compiler errors, Not enough real-world code to learn from",Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,"Still seen as being a fancy elitist thing by many ""average"" devs",4 or more years,Keep being awesome!,Financial services or similar,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, Simple ""one liner"" type definitions for records and DUs, Type inference",,,"More material with real-world examples and war stories, more fun and more profit",
13/04/2015 08:23:49,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly","Links posted on social media such as Twitter, Links mentioned in F# Weekly",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Machine learning, Data analysis/statistics","Internal enterprise projects, Open source projects",SQL databases,Visual Studio 2012 or newer,Windows,"Windows, Mac, Linux",JVM,C/AL,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Great community",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Active Patterns, Agents (MailboxProcessor), Static type constraints",,Can't use it inside Dynamics NAV,I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,Enterprise development,,"Not being part of the core .NET distribution, FSharp.Core compat issues","Faster time to market, Efficiency/Performance, Scripting","Backtick naming, Immutability by default, The ""piping"" idiom, Type inference",,,"More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 08:45:48,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers, StackOverflow chat","Links and instructions from fsharp.org, F# books, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,"Games, Mobile apps","Commercial products, Open source projects",Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, WinPhone","JVM, Javascript, Native","C#, C++",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),,"Lack of good tutorials/documentation, better tools and templates in visual studio. often need ugly workarounds for the c#/f# interaction to work especially for xaml projects.","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,It would be great if f# had something similar to haskells typeclasses. Without that you lose a lot of reuse potential.,1-2 years,,Financial services or similar,,"Lack of good wrappers for non-F# libraries, Working with C#-centric tooling",,"Immutability by default, Interactive development, The ""piping"" idiom, Type inference",,The Fsharp community already does a lot with lots of meetups and events. There's some really good blogs. Having more blogs like Scott Wlaschins would be good. This clearly shows benefits to the business in an easily understandable way,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 08:35:43,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,Twitter,"Links and instructions from fsharp.org, F# books, F# bloggers, Videos (e.g. Community for F#)",,It's officially endorsed for critical/production areas,Financial services,Internal enterprise projects,"SQL databases, Event sourcing, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,Javascript,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Async workflows, Quotations, Units of measure",Fix CLR to enable typeclasses,Nothing. Everyone loves it.,I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,Keep up the good work.,Financial services or similar,,Fringe CLR limitations,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Immutability by default, No dependency cycles, Object expressions, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 08:38:31,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","F# bloggers, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Data analysis/statistics",Internal enterprise projects,"SQL databases, NoSQL database, Event sourcing, Read-only data sources such as feeds",Visual Studio 2012 or newer,"Windows, Mac, Linux",Windows,"Javascript, LLVM, Native","C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Object-oriented compatibility, Quotations",,Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,Enterprise development,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, The ""piping"" idiom, Type inference, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 08:40:27,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","MSDN, F# books, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,"Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications, Data analysis/statistics","Internal enterprise projects, Open source projects","SQL databases, NoSQL database, Event sourcing",Visual Studio 2012 or newer,"Windows, Linux","Windows, Azure, Amazon Web services",LLVM,"C#, Erlang, Haskell, Ocaml/SML, Scala",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,,Hiring: They worry about not being able to find F# developers,I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,Enterprise development,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,More material with in-depth tutorials,
13/04/2015 08:49:00,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, Google groups, F# bloggers, Functional Programming Slack","MSDN, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Reading F# code written by experts",,I don't use F# at work,"Utilities and tools, Machine learning, Other",Open source projects,Event sourcing,Visual Studio 2012 or newer,Windows,,"JVM, Native","Erlang, Haskell, Javascript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Integration with non-F# libraries, Interactive development, Object-oriented compatibility, Quotations, Units of measure",,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Enterprise development,,"Working with C#-centric tooling, Cross-platform issues",,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, No dependency cycles, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 08:50:52,10 or more years,"No, I don't know much theory",Just tinkering,,"Twitter, F# Weekly",F# bloggers,,It's used unofficially,"None - Just playing around, Financial services",Internal enterprise projects,"SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,,Smalltalk,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance)",Beginner (For example: you know OO well and functional programming seems strange),"Active Patterns, Agents (MailboxProcessor), Quotations",Installation process,time to get around to it,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers","The ""piping"" idiom, Type providers",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 08:54:32,5-10 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, HN, Reddit and other programming news sites","Links and instructions from fsharp.org, Answers to Stack Overflow questions, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Machine learning, Mainstream business & enterprise applications, Research/Teaching, Data analysis/statistics","Internal enterprise projects, Commercial products","SQL databases, NoSQL database, Event sourcing, Analytics",Visual Studio 2012 or newer,Windows,Azure,None -- I'm happy with the CLR/Mono,,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance, A smug sense of superiority",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Quotations",,Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Enterprise development,,Difficulty in troubleshooting problems,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure, The open nature of the additional libs",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 08:58:32,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,,,,Visual Studio 2012 or newer,Windows,,,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Object expressions, Units of measure",,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,"I am a little concerned with asp net 5 roadmap. 

Not enough resources put into f# web frameworks.",4 or more years,"Great Lang and community. Love the enthusiasm. 

Keep up the great work!!!",Enterprise development,,Lack of good wrappers for non-F# libraries,Faster time to market,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Type providers",,More testimonials from industries other than financial services. A little less humbleness when highlighting strong suits over other languages.,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 09:09:26,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"F# Weekly, HN, Reddit and other programming news sites","F# books, F# bloggers, Answers to Stack Overflow questions",,It's used unofficially,"Utilities and tools, Research/Teaching",Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,"Windows, Mac, Linux","Windows, Linux","Javascript, LLVM","C, C#, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance)",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Object-oriented compatibility, Quotations, Units of measure",Lack of good tutorials/documentation,"Too Microsoft-centric: They think it is too closely linked to Microsoft, F# is largely unknown to fellow researchers",I'm willing to learn advanced concepts but only if they are relevant and practical,Many libraries and type providers are not well documented.,2-3 years,,"Academic, research, or related",,Lack of F# friendly libraries,"More productive with fewer developers, Easy concurrency with async and agents, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference",,High quality libraries for data visualization and data analysis.,"More material with in-depth tutorials, More material with short ""cookbook"" style information",
13/04/2015 09:15:12,1-2 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,Research/Teaching,"Internal enterprise projects, Open source projects","NoSQL database, Event sourcing",Visual Studio 2012 or newer,"Windows, Linux","Windows, Azure",Javascript,"C#, Javascript",,Learning functional programming in general,"Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Async workflows, Computation expressions",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,,"Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Easy integration with other .NET libraries, Interactive development, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 09:36:42,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly, HN, Reddit and other programming news sites","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,It's used unofficially,"Algorithm-heavy business applications (non-financial), Machine learning, Mainstream business & enterprise applications, Data analysis/statistics",Internal enterprise projects,Read-only data sources such as feeds,Visual Studio 2012 or newer,"Windows, Mac","Windows, Mac, Linux, iOS, Android, WinPhone","LLVM, Native","Java, Objective-C, Ruby, Swift",,"Having fun again, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,bad cross platform tooling,they don't care about the benefits,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling","Correctness: fewer bugs and less rework, More productive with fewer developers","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom",,,"More material with in-depth tutorials, introduction to .Net using F#",
13/04/2015 09:51:41,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,Twitter,"F# bloggers, Links posted on social media such as Twitter",,I don't use F# at work,"None - Just playing around, Algorithm-heavy business applications (non-financial), Financial services, Mainstream business & enterprise applications",,Event sourcing,Visual Studio 2012 or newer,Windows,Windows,,"C#, Javascript",,Better domain modelling with records and unions,"Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,,,I like theory -- I'm not afraid of monads and other abstractions,,Haven't really used it yet,,Enterprise development,,,Domain modelling: making illegal states unrepresentable,Immutability by default,,,,
13/04/2015 09:56:26,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# bloggers","F# bloggers, Reading F# code written by experts",,It's used unofficially,Utilities and tools,"Commercial products, Open source projects","SQL databases, NoSQL database, Analytics",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Java, Javascript, Scala",,"Conciseness of code (I can see more at a glance), Learning functional programming in general, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Quotations, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,Enterprise development,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries",Domain modelling: making illegal states unrepresentable,"Algebraic types (inc discriminated unions and tuples), Immutability by default, Type inference",Teach functional programming instead of F# language syntax.,,,"In ""How comfortable are you with functional programming in general?"", ""expert"" is actually ""intermediate"", there's lots more to FP beyond monads.

The question ""If you were using F# but have now stopped, please tell us why"" doesn't make any sense to me. I may not have written much F# code in months, but that doesn't mean I ""stopped"". It's another tool.

The question ""What is the status of F# in your workplace?"" doesn't make sense in many workplaces, where people mostly don't care about the tools being used and the ""official"", ""non-official"" status simply does not apply.

""How do you learn F#?"" applies only to people recently learning the language. Any feedback I give about that applies to when I was learning it many years ago, mostly useless today."
13/04/2015 10:01:24,5-10 years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# bloggers","F# books, F# bloggers, Links posted on social media such as Twitter",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,NoSQL database,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Static type constraints",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,That people think Functional Programming in general is too complicated.,1-2 years,,Enterprise development,,Difficulty in troubleshooting problems,,"Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Units of measure",,,"More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 10:14:30,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly",,I don't use F# at work,"None - Just playing around, Mainstream business & enterprise applications",Open source projects,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,"Windows, Mac, Linux",Javascript,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Active Patterns,Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams, CMS (EPiServer) we are using is easier build with C#",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,"Less sophisticated tools for refactoring, etc., some OOP features do not work as in C# (virtual methods, properties has different IL)",,"Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 10:44:45,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Structured training/workshops",,It's used unofficially,"Financial services, Games, Machine learning, Mobile apps","Commercial products, Open source projects",Not doing data centric apps,Visual Studio 2012 or newer,"Windows, Mac",Windows,"JVM, LLVM","C#, Go, Rust, Swift",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Quotations, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,"Second class status to VB and C# from MS. Tooling has improved, but compared to C# for example, is very basic. ",4 or more years,,Financial services or similar,,Not being part of the core .NET distribution,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material",
13/04/2015 11:10:42,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Structured training/workshops, Videos (e.g. Community for F#), Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Games",Internal enterprise projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Object expressions, Quotations, Units of measure",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I want to learn functional programming but I don't like academic jargon,"Tooling for building UIs (e.g. WPF and Winforms applications are much easier with C#)
I know people knock ReSharper, but it's an amazingly powerful tool for C# that experienced users miss when switching to F#. F# power tools is a great start, but it's there's many of the features of a tool like ReSharper are missing.",2-3 years,,Enterprise development,,"Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents","Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,"Highlight that there's a low barrier to entry.
Focus on similarities to existing technologies (C#), rather than how much better it is (I think this makes people defensive).","More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 11:14:25,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, Google groups, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,Utilities and tools,"Internal enterprise projects, Open source projects",Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,"Windows, Linux","None -- I'm happy with the CLR/Mono, Native","C#, Java",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Object-oriented compatibility, Static type constraints","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, printf that is type checked, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 11:15:38,2-5 years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly","Links and instructions from fsharp.org, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,It's officially endorsed for critical/production areas,"Financial services, Mainstream business & enterprise applications",Commercial products,SQL databases,Visual Studio 2012 or newer,Windows,"Windows, Azure",None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Static type constraints, Units of measure",I can't use my knowledge from C# or other imperative languages,Nothing. Everyone loves it.,I'm willing to learn advanced concepts but only if they are relevant and practical,"Tooling and lack of overall support from Microsoft for other related products. (Roslyn, ASP.NET vNext)",Less than a year,,Financial services or similar,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 11:17:59,5-10 years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# bloggers","F# bloggers, Links posted on social media such as Twitter, Videos (e.g. Community for F#), Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Mainstream business & enterprise applications",Open source projects,NoSQL database,Visual Studio 2012 or newer,Windows,"Windows, Azure","None -- I'm happy with the CLR/Mono, Native","C#, Javascript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,Tooling. Not having something like ReSharper is such a pain!,1-2 years,,Enterprise development,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",Less toy examples and more real-world whole application architecture examples.,"More examples at the whole-application level that can be pointed to to prove it can be done and done well (eg. here's the best practice way of constructing a web application using F#).
Better tooling. F# Power Tools is a nice start, but Visual Studio & C# destroys F# in terms of code navigation, refactoring and inspection tools (think ReSharper).","More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 11:18:28,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"Twitter, F# bloggers",F# books,,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,NoSQL database,Visual Studio 2012 or newer,Windows,Windows,JVM,C#,,"Better domain modelling with records and unions, Correctness (no nulls, it works first time)",Beginner (For example: you know OO well and functional programming seems strange),,,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,,Haven't really used it yet,,Enterprise development,,,,,,,"More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 11:25:20,5-10 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly","MSDN, F# books, F# bloggers, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,Mainstream business & enterprise applications,"Internal enterprise projects, Commercial products, Open source projects","SQL databases, Event sourcing, Read-only data sources such as feeds",VS 2012+ with VsVim and Vim,"Windows, Linux","Windows, Linux",LLVM,"C#, Python, Visual Basic",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Object expressions",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,Lack of higher kinded and/or dependent types; otherwise a lot more could be reused from the Scala/Haskell communities.,4 or more years,,Enterprise development,,"Not being part of the core .NET distribution, Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Quotations, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More short ""live coding"" videos",
13/04/2015 11:25:58,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, Google groups, HN, Reddit and other programming news sites, F# bloggers","F# bloggers, Links posted on social media such as Twitter",,It's officially endorsed for critical/production areas,"Utilities and tools, Custom development/specialist markets, Research/Teaching, Data analysis/statistics","Commercial products, Open source projects",Read-only data sources such as feeds,Visual Studio 2012 or newer,"Windows, Mac, Linux","Windows, Mac, Linux, iOS, Android, Azure","Javascript, gpu","C, C#, C++, Haskell, Ocaml/SML",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Speed of development, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),,"Lack of good tutorials/documentation, Not enough real-world code to learn from","Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I want to learn functional programming but I don't like academic jargon,"Weak web programming story

Too associated with Microsoft",4 or more years,,"Academic, research, or related",,"Not being part of the core .NET distribution, Working with C#-centric tooling","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,More free training ,"More material with short ""cookbook"" style information, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 11:26:31,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# bloggers","F# books, F# bloggers, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Mainstream business & enterprise applications, Mobile apps",Open source projects,Event sourcing,Visual Studio 2012 or newer,"Windows, Mac",Windows,Javascript,"C#, Javascript, Objective-C",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Interactive development, Object-oriented compatibility, Static type constraints, Units of measure","Installation process, Don't understand the compiler errors","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Faster time to market, Easy concurrency with async and agents","Active Patterns, Algebraic types (inc discriminated unions and tuples), Backtick naming, Immutability by default, No dependency cycles, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type providers",,,"More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 11:26:43,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,Twitter,"F# books, Links posted on social media such as Twitter, Reading F# code written by experts",,It's officially endorsed for critical/production areas,Data analysis/statistics,Internal enterprise projects,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,"Windows, Azure, Amazon Web services",None -- I'm happy with the CLR/Mono,"C#, SQL",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor), Quotations, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Data or analytics related,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Backtick naming, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,"1) Get buy in from some industry 'thought leaders' from the OO camp (Jon Skeet, Kent Beck, Scott Hanselman).
2) Get coverage in the kind of media which C-level and VP-level people read, so that instead of devs saying ""let's do this"", managers in big corporates start saying ""why aren't you doing this already?"".",More material with real-world examples and war stories,
13/04/2015 11:28:10,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly","F# bloggers, Links mentioned in F# Weekly, Reading F# code written by experts",,I don't use F# at work,Mainstream business & enterprise applications,Open source projects,"SQL databases, Event sourcing",Visual Studio 2012 or newer,Windows,Windows,,C#,,,Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Interactive development",,,,,,,Enterprise development,,,,"Agents (MailboxProcessor), Immutability by default, Quotations, The ""piping"" idiom, Type providers, Units of measure, rop",,,,
13/04/2015 11:30:52,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"Twitter, F# Weekly","F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,,"Clojure, Python",,"Functional but can be tweaked to get high performance, type providers",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Integration with non-F# libraries, Object expressions, Object-oriented compatibility",tooling sucks,"Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft",I like theory -- I'm not afraid of monads and other abstractions,C# pollution; the latter is as painful as java.,Less than a year,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Cross-platform issues",,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Type providers, Units of measure",Minimize c# pollution of the language,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 11:33:03,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"Twitter, F# Weekly, Google+","MSDN, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Research/Teaching, Text analysis/language parsing",Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,JVM,C#,,"Correctness (no nulls, it works first time), Speed of development, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Active Patterns, Object expressions",Don't understand the compiler errors,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,"Academic, research, or related",,"Difficulty in troubleshooting problems, Performance issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Quotations, The ""piping"" idiom, Type inference",,,"More material with short ""cookbook"" style information",
13/04/2015 11:33:25,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,Twitter,"MSDN, F# books, F# bloggers, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,"Utilities and tools, Mainstream business & enterprise applications",Open source projects,"SQL databases, Event sourcing",Visual Studio 2012 or newer,Windows,"Windows, Azure",None -- I'm happy with the CLR/Mono,C#,,"Correctness (no nulls, it works first time), Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Static type constraints, Type providers, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,Poor support from Microsoft devdiv and marketing.,2-3 years,,"Author, consultant, advisor",,"Not being part of the core .NET distribution, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Slow compiler","Correctness: fewer bugs and less rework, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, No dependency cycles, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,I don't know what I don't know,
13/04/2015 11:33:49,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's used unofficially,Utilities and tools,Not applicable. None of my F# code is used by other people,"Event sourcing, Analytics",Emacs,Mac,,"None -- I'm happy with the CLR/Mono, LLVM","C, C#, C++, Perl, Python, Scheme/CL",,"Conciseness of code (I can see more at a glance), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Object expressions, Quotations, Type providers, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,"I use it at home with Emacs on a mac, and at work with Visual Studio (2012, because ""enterprise""). I want to build small scripts and utilities, but VS2012 is quite a heavyweight thing for that. I was waiting for better support in LINQPad but then discovered fsharp mode on Emacs/w32 had developed great/stable completion - now a ""scratch.fsx"" file is my better-than-linqpad solution. But, the rest of my team are Visual Studio bound and it's hard to show them a demo of what I do without freaking them out!",Less than a year,,Financial services or similar,,Working with C#-centric tooling,"Correctness: fewer bugs and less rework, More productive with fewer developers, better than Python (our ""official"" scripting/glue language)","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference","I find fsi/fsharpi quite frustrating for experimentation (compared to ghci or slime interaction), e.g. interactive completion and easy-to-access docs (like hoogle or the Common Lisp hyperspec) are super useful for exploring langauges and libraries.",Create more jobs so I can go work at a place that isn't afraid of F#!,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 11:37:04,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# bloggers, StackOverflow chat","F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Financial services, Machine learning, Data analysis/statistics","Internal enterprise projects, Commercial products, Open source projects","SQL databases, NoSQL database, Read-only data sources such as feeds",Visual Studio 2012 or newer,"Windows, Mac, Linux","Windows, Mac, Linux","JVM, LLVM","C, C#, C++, Python, R, Scala",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,"Tooling, Refactoring, Type Classes",F# is still a niche,I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,Financial services or similar,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Interactive development, Quotations, Type inference",,,More material with in-depth tutorials,
13/04/2015 11:40:00,2-5 years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# bloggers","MSDN, F# books, F# bloggers, Links posted on social media such as Twitter, Personal mentoring, Reading F# code written by experts",,It's used unofficially,Utilities and tools,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,"JVM, LLVM","C#, Java, Scheme/CL",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Quotations, Type providers",Not enough real-world code to learn from,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I want to learn functional programming but I don't like academic jargon,,1-2 years,,Enterprise development,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 11:44:13,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"F# Weekly, HN, Reddit and other programming news sites","Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Reading F# code written by experts",,It's used unofficially,"Custom development/specialist markets, Research/Teaching",Internal enterprise projects,SQL databases,MonoDevelop,"Windows, Linux","Windows, Linux",Native,"C++, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Speed of development, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Object-oriented compatibility",Not enough real-world code to learn from,Nothing. Everyone loves it.,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,Thanks for running the survey!,Science or related,,"Lack of good wrappers for non-F# libraries, Cross-platform issues","Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, No dependency cycles, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 11:45:37,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, Google groups, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,It's used unofficially,"Utilities and tools, Games, Mobile apps","Open source projects, Not applicable. None of my F# code is used by other people","SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,"Windows, Android, WinPhone",None -- I'm happy with the CLR/Mono,"C#, Java, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,"Lack of good tutorials/documentation, I can't use my knowledge from C# or other imperative languages, Not enough real-world code to learn from","Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Fad: They have concerns over long term language viability, Too Microsoft-centric: They think it is too closely linked to Microsoft, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,F# is still used as library language but it should moved as complete project language. There still issues with Visual Studio Project files. ,2-3 years,We should keep working hard. ,Enterprise development,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Working with C#-centric tooling","Correctness: fewer bugs and less rework, More productive with fewer developers","Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",More real life project that should be open sourced. More documentation in F# libraries. Sometimes no documentation makes things bit tough to get started. ,I guess it is a journey every language has to made. F# being more on research side people are little hesitate to learn. It is like if things are working and going on with C# why there is need for another language. ,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos",I guess this is good enough. 
13/04/2015 11:48:04,2-5 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers, Slack chat","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,It's used unofficially,Mainstream business & enterprise applications,"Internal enterprise projects, Commercial products, Open source projects","SQL databases, Event sourcing",Visual Studio 2012 or newer,"Windows, Linux",Windows,Javascript,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Quotations,,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Enterprise development,,"Not being part of the core .NET distribution, Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Immutability by default, No dependency cycles, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material",
13/04/2015 11:48:28,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly","Links posted on social media such as Twitter, Links mentioned in F# Weekly, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Machine learning, Data analysis/statistics","Internal enterprise projects, Commercial products",SQL databases,Visual Studio 2012 or newer,"Windows, Mac","Windows, Azure",JVM,"Erlang, Java, Python, Scala",,"Conciseness of code (I can see more at a glance), Great community, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Object expressions, Object-oriented compatibility, Units of measure",Not enough real-world code to learn from,,I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market","Immutability by default, The ""piping"" idiom, Type inference",,,More material with real-world examples and war stories,
13/04/2015 11:49:25,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions",,I don't use F# at work,Utilities and tools,Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,JVM,C#,,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Computation expressions",Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.",,"Immutability by default, No dependency cycles, The ""piping"" idiom",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 11:51:07,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, StackOverflow chat","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly",,It's used unofficially,"Utilities and tools, Data analysis/statistics, Text analysis/language parsing",Open source projects,SQL databases,Visual Studio 2012 or newer,"Windows, Linux","Windows, Mac, Linux",None -- I'm happy with the CLR/Mono,"C, C#, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Async workflows, Computation expressions, Object expressions, Units of measure",Installation process,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Too Windows-centric: They have concerns over cross-platform issues",I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Driver development,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,Much better linux support for using and developing.,More material with in-depth tutorials,
13/04/2015 11:51:42,2-5 years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"Twitter, F# bloggers","F# books, F# bloggers, Links posted on social media such as Twitter, Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,"Research/Teaching, Data analysis/statistics",Not applicable. None of my F# code is used by other people,SQL databases,Emacs,"Windows, Linux","Windows, Linux",None -- I'm happy with the CLR/Mono,"C#, C++",,"Great community, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Quotations",Hard to create your own *.fsproj files without installing VS or Xamari.,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,"Managing projects too depending on IDE, no simple setup of *.fsproj.",2-3 years,,"Academic, research, or related",,Cross-platform issues,"Efficiency/Performance, Better for solving complex problems","Interactive development, Simple ""one liner"" type definitions for records and DUs, Type inference",,Improve the documentation to make more clear the expected run-time of different datastructures. Also emacs binding need more work. Intellisense features in REPL :),More material with in-depth tutorials,
13/04/2015 11:55:04,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,F# bloggers,"Links and instructions from fsharp.org, F# books, F# bloggers, Reading F# code written by experts",,It's officially endorsed for critical/production areas,Financial services,Commercial products,"SQL databases, Event sourcing, Read-only data sources such as feeds, Data integration and EAI",Visual Studio 2012 or newer,"Windows, Mac",Windows,Native,"C#, C++, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Units of measure,,"Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much",I'm willing to learn advanced concepts but only if they are relevant and practical,,3-4 years,,Financial services or similar,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents","Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Object expressions",,,"More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 11:55:09,Less than a year,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, Google+, F# bloggers","MSDN, F# bloggers, Links mentioned in F# Weekly, Structured training/workshops",,It's officially endorsed for critical/production areas,"Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Machine learning, Data analysis/statistics","Commercial products, Open source projects","NoSQL database, Read-only data sources such as feeds",Visual Studio 2012 or newer,"Windows, Mac","Windows, Azure, Amazon Web services","LLVM, Native","C++, Go, Python",,"Better domain modelling with records and unions, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Quotations,Not enough real-world code to learn from,Too Windows-centric: They have concerns over cross-platform issues,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Science or related,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Computation expressions",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 11:55:32,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly","F# books, Links posted on social media such as Twitter, I learnt ML on a course and applied concepts to F#",,It's used unofficially,Mainstream business & enterprise applications,Commercial products,Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,Windows,JVM,"C#, Java, Javascript, Scala",,"Conciseness of code (I can see more at a glance), Using type providers and recursive functions to handle messaging got rid of tons of c# code into a F# library",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Object expressions, Quotations, Units of measure",,"Chicken and egg problem, nothing is written in F# so no need to employ F# capability therefore nothing is written in F# x forever",I like theory -- I'm not afraid of monads and other abstractions,"F#'s biggest problem is that C# is ""okay"".  C#, you can kind of use higher order functions with lambdas, expression trees and Func<>.  It kind of does implicit typing within some significant constraints.  If C# was terrible F# would be picked up like a shot.  IMHO the  ""we can do that in C#  (to a degree)"", is the biggest problem F# has.",1-2 years,One question mentioned the community as a negative.  As an outsider to F# I have found the community to be very positive and welcoming.,Enterprise development,,,Faster time to market,"Interactive development, The ""piping"" idiom, Type providers",,,"The most important thing I like is material that is curated, hence I like a good book.  To much material is on 1 small part of the language or ecosystem and lacks a curation.  F sharp for fun and profit is a counter example and that is well structured.",Free cake for all participants
13/04/2015 12:00:40,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,Colleague,"MSDN, Links and instructions from fsharp.org, F# books, Personal mentoring, Pluralsight",,It's officially endorsed for critical/production areas,Research/Teaching,Not applicable. None of my F# code is used by other people,,Visual Studio 2012 or newer,"Windows, Mac, Linux",Windows,None -- I'm happy with the CLR/Mono,"C, C++, Java, Perl, Python",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,Finding time to write more,"Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams, Nothing. Everyone loves it.",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Science or related,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Faster time to market, Easy concurrency with async and agents, Better for solving complex problems","Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Immutability by default, The ""piping"" idiom",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 12:01:39,5-10 years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly","F# books, F# bloggers, Links posted on social media such as Twitter",,It's used unofficially,"Financial services, Games, Mobile apps","Commercial products, games ",Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,"Windows, Android",None -- I'm happy with the CLR/Mono,C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Units of measure,none of those,"Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Financial services or similar,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 12:02:10,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"F# Weekly, F# bloggers","F# books, F# bloggers",,It's officially endorsed for critical/production areas,"Utilities and tools, Mainstream business & enterprise applications","Commercial products, Open source projects","Read-only data sources such as feeds, Analytics",Xamarin,"Windows, Mac","Mac, iOS, Android","JVM, Javascript, LLVM",C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Interactive development, Static type constraints, Units of measure",Don't understand the compiler errors,"Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,Lack of full support for PCL/Universal apps,4 or more years,,Enterprise development,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Cross-platform issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Immutability by default, Object expressions, The ""piping"" idiom, Type inference, Type providers",Better IDE tools,More x-plat work,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 12:03:38,5-10 years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# bloggers, IRC, StackOverflow chat","MSDN, F# bloggers, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Custom development/specialist markets, Text analysis/language parsing",Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,Windows,Windows,Native,"C, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Having fun again, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Quotations, Static type constraints, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Fad: They have concerns over long term language viability, Too Windows-centric: They have concerns over cross-platform issues, Not a development company",I'm willing to learn advanced concepts but only if they are relevant and practical,,2-3 years,,Data or analytics related,,"Not being part of the core .NET distribution, Less sophisticated tools for refactoring, etc., Performance issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Easy integration with other .NET libraries, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 12:04:25,10 or more years,"No, I don't know much theory",Just tinkering,,Twitter,"MSDN, Links and instructions from fsharp.org, F# bloggers, Links posted on social media such as Twitter",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Visual Basic",,"Having fun again, Learning functional programming in general",Beginner (For example: you know OO well and functional programming seems strange),,,"Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,,,"Immutability by default, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 12:08:00,2-5 years,"Yes, I enjoy computer science and mathematics",I use it for student work,,"Twitter, F# Weekly, F# bloggers","MSDN, Links and instructions from fsharp.org, F# bloggers, Links posted on social media such as Twitter, Reading F# code written by experts",,It's used unofficially,"Machine learning, Data analysis/statistics, Text analysis/language parsing",Not applicable. None of my F# code is used by other people,Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,Windows,"LLVM, Native","C, C#, C++, Java, Python, R",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Functional but can be tweaked to get high performance","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Agents (MailboxProcessor)",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,"Academic, research, or related",,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc.",,"Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 12:09:38,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, IRC","Links and instructions from fsharp.org, Personal mentoring, F# for fun & profits web site",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Financial services","Internal enterprise projects, Commercial products, Open source projects","SQL databases, NoSQL database",Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux","JVM, Javascript","Clojure, Haskell",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Type providers, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,"While it is cross-platform/editor thanks to Mono and fsharpbindings, I think that the concentration of users using Windows/VS is very high, which means that the experience on other platforms is much less polished.",1-2 years,Thank you for organizing this survey.,Financial services or similar,,"Cross-platform issues, Windows/VStudio centricity ","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers","Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 12:09:59,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, StackOverflow chat","MSDN, F# books, F# bloggers, Links mentioned in F# Weekly",,It's officially endorsed for critical/production areas,Financial services,Internal enterprise projects,"SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux",Native,"C#, Perl",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Great community, Speed of development, Type providers",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows",Tooling not quite at .NET standard,Performance - sometimes too abstract/too much overheard ,I'm willing to learn advanced concepts but only if they are relevant and practical,"Tooling is sometimes irritating especially when starting, e.g. a type provider breaks Intellisense from time to time. As a newcomer you loose a lot of time because you think you are the reason for the error instead of Visual Studio.",1-2 years,,Financial services or similar,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, More productive with fewer developers, Faster time to market, Efficiency/Performance","Simple ""one liner"" type definitions for records and DUs, Type providers",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",A bit redundant to have similar questions for general/work.
13/04/2015 12:10:26,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,I don't like a lot of things...,Twitter,"Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,"Utilities and tools, Algorithm-heavy business applications (non-financial), Data analysis/statistics","Internal enterprise projects, Open source projects","SQL databases, NoSQL database, Read-only data sources such as feeds, Analytics",Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux",LLVM,"C, C#, C++, Haskell, Perl, Python, Rust, Scheme/CL",,Speed of development,Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Type providers,,why...,I want to learn functional programming but I don't like academic jargon,,I was using F# but have stopped,,Enterprise development,,,is there?,"Active Patterns, Async workflows, Easy integration with other .NET libraries, Object-oriented features (inc. C# compatibility, conciseness), Type inference, Type providers",,,More material with real-world examples and war stories,
13/04/2015 12:11:40,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,Twitter,"Links and instructions from fsharp.org, Links posted on social media such as Twitter",,It's used unofficially,,,,Visual Studio 2012 or newer,Windows,,,"C#, C++",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I want to learn functional programming but I don't like academic jargon,,Less than a year,,Enterprise development,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Async workflows, Immutability by default, The ""piping"" idiom",,,More material with real-world examples and war stories,
13/04/2015 12:11:58,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"F# Weekly, HN, Reddit and other programming news sites","F# bloggers, Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Mainstream business & enterprise applications, Data analysis/statistics","Internal enterprise projects, Commercial products",SQL databases,Visual Studio 2012 or newer,Windows,Windows,"None -- I'm happy with the CLR/Mono, Native","C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),Units of measure,Not enough real-world code to learn from,Tool support (like Resharper),I'm willing to learn advanced concepts but only if they are relevant and practical,"Tool/IDE support, even with F# PowerTools",1-2 years,,Data or analytics related,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,"Build better tool support. For a huge project that is already using C#, it's more difficult to add F# as there's no cross-boundary tools.","More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 12:14:37,5-10 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly","F# bloggers, Links mentioned in F# Weekly, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Financial services, Data analysis/statistics","Internal enterprise projects, Open source projects",SQL databases,Visual Studio 2012 or newer,"Windows, Mac",Windows,Javascript,C#,,"Conciseness of code (I can see more at a glance), Having fun again, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Quotations, Units of measure",Not enough real-world code to learn from,Training: They are worried about getting non-F# developers up to speed,I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Financial services or similar,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, More productive with fewer developers","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Interactive development, The ""piping"" idiom",,,"More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 12:18:37,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Data analysis/statistics, Text analysis/language parsing",Internal enterprise projects,"SQL databases, Read-only data sources such as feeds, Not doing data centric apps",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C, C#, Perl",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Computation expressions, Interactive development, Type providers, Units of measure",,,I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Mineral resources,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 12:20:17,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","MSDN, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,"Mainstream business & enterprise applications, Data analysis/statistics","Internal enterprise projects, Open source projects","SQL databases, Event sourcing",Visual Studio 2012 or newer,"Windows, Mac, Linux",Windows,"None -- I'm happy with the CLR/Mono, LLVM, Native",C#,,"Conciseness of code (I can see more at a glance), Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Interactive development, Object expressions, Quotations",Lack of good tutorials/documentation,Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,"Get Visual studio and MS to treat it like a first class citizen.  Why can I add a manifest to a C# app but not a F# one from the IDE, why do I have to hand edit the fsproj so often?  Why the lack of templates, why the lack of editor support.  Why do we require FSPowerTools to get decent syntax highlighting?  It seem that MS doesnt really support it, which give people a bad feeling about its going away someday.",2-3 years,,Enterprise development,,"Working with C#-centric tooling, visual studios lack of support for F# projects.  ","Correctness: fewer bugs and less rework, Easy concurrency with async and agents","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Type inference",,"Get Visual studio and MS to treat it like a first class citizen.  Why can I add a manifest to a C# app but not a F# one from the IDE, why do I have to hand edit the fsproj so often?  It seem that MS doesnt really support it, which give people a bad feeling about its going away someday.",More material with in-depth tutorials,
13/04/2015 12:24:11,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,Twitter,"MSDN, F# books, Structured training/workshops",,It's officially endorsed for critical/production areas,"Algorithm-heavy business applications (non-financial), Games","Internal enterprise projects, Commercial products",SQL databases,Xamarin,Mac,"Windows, iOS, Android, WinPhone",None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Computation expressions,Lack of good tutorials/documentation,Hiring: They worry about not being able to find F# developers,I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Efficiency/Performance, Easy concurrency with async and agents","Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 12:27:04,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"F# Weekly, HN, Reddit and other programming news sites","Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Javascript, Ruby",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Async workflows, Integration with non-F# libraries",Lack of good tutorials/documentation,No perceived benefits: They don't understand what benefits F# has over C# or other languages,,,Haven't really used it yet,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling",,"Easy integration with other .NET libraries, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 12:31:53,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly","Links and instructions from fsharp.org, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly",,It's officially endorsed for critical/production areas,Mainstream business & enterprise applications,"Internal enterprise projects, Open source projects","SQL databases, Event sourcing, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Interactive development, Quotations, Static type constraints","I can't use my knowledge from C# or other imperative languages, Don't understand the compiler errors, Not enough real-world code to learn from","Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Immutability by default, No dependency cycles, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 12:30:41,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly","Links and instructions from fsharp.org, F# books",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, C++, Javascript, Python",,"Conciseness of code (I can see more at a glance), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Agents (MailboxProcessor),Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,,,"Immutability by default, The ""piping"" idiom",,,,
13/04/2015 12:32:05,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly","F# books, F# bloggers, Structured training/workshops, Videos (e.g. Community for F#)",,It's used unofficially,Mainstream business & enterprise applications,Commercial products,SQL databases,Visual Studio 2012 or newer,Windows,"Windows, Azure",JVM,C#,,"Conciseness of code (I can see more at a glance), Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,Don't understand the compiler errors,"Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,Lack of tooling,Correctness: fewer bugs and less rework,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Immutability by default, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 12:33:45,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# bloggers","Links and instructions from fsharp.org, F# bloggers",,It's officially endorsed for non-critical/non-production code,"Financial services, Mobile apps","Internal enterprise projects, Commercial products",NoSQL database,Visual Studio 2012 or newer,Windows,Windows,"None -- I'm happy with the CLR/Mono, Native","C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Object expressions, Quotations, Units of measure",,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, As a consultant, it is a hard sell to clients sometimes due to some of the reasons above",I'm willing to learn advanced concepts but only if they are relevant and practical,Not enough material on how to apply F# to LOB apps,Less than a year,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, No dependency cycles, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 12:34:45,5-10 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,Twitter,MSDN,,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, C++, Haskell",,,Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,Installation process,,I like theory -- I'm not afraid of monads and other abstractions,,Less than two months,,Student,,,,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Object-oriented features (inc. C# compatibility, conciseness)",,,"More material with short ""cookbook"" style information",
13/04/2015 12:34:59,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, HN, Reddit and other programming news sites, F# bloggers",F# bloggers,,It's used unofficially,"Utilities and tools, Text analysis/language parsing","Internal enterprise projects, Open source projects",,Visual Studio 2012 or newer,Windows,Windows,"Javascript, LLVM",C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Interactive development, Object-oriented compatibility",not intuitive for people with C-based semantics background,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,2-3 years,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,More material with real-world examples and war stories,
13/04/2015 12:36:18,2-5 years,"No, I don't know much theory",I use it for hobby or side projects,,"F# Weekly, HN, Reddit and other programming news sites, IRC","Links and instructions from fsharp.org, F# books, F# bloggers, Reading F# code written by experts",,I don't use F# at work,"Utilities and tools, Mainstream business & enterprise applications, Text analysis/language parsing",Not applicable. None of my F# code is used by other people,"SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux","Javascript, LLVM","C#, Javascript, PHP, Python",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Quotations, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from",,I like theory -- I'm not afraid of monads and other abstractions,,Less than two months,,Enterprise development,,Lack of good wrappers for non-F# libraries,,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Interactive development, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 12:37:33,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, HN, Reddit and other programming news sites, F# bloggers, IRC","F# books, Answers to Stack Overflow questions",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,"Windows, Mac","Windows, Mac","JVM, Javascript","C#, Java, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor), Quotations, Static type constraints, Type providers, Units of measure",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft",I like theory -- I'm not afraid of monads and other abstractions,Cross-platform development experience and lack of JVM implementation.,3-4 years,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Easy concurrency with async and agents","Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference",,Great developer experience on platforms other than Windows.,"More material with in-depth tutorials, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 12:39:18,2-5 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, HN, Reddit and other programming news sites","F# bloggers, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,I don't use F# at work,Games,Not applicable. None of my F# code is used by other people,"SQL databases, NoSQL database, Event sourcing, Read-only data sources such as feeds",Visual Studio 2012 or newer,"Windows, Mac",Windows,"LLVM, Native",C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor), Interactive development, Object expressions, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,"It is limited by the CLR, but it is also the biggest benefit since you can use F# and C# together",Less than a year,,Student,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling",,"Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 12:40:09,5-10 years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# bloggers","F# books, F# bloggers, Videos (e.g. Community for F#)",,It's used unofficially,None - Just playing around,Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,"Windows, Mac, Linux",None -- I'm happy with the CLR/Mono,"C#, Java",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Fad: They have concerns over long term language viability, Too Windows-centric: They have concerns over cross-platform issues",I want to learn functional programming but I don't like academic jargon,,Less than a year,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance","Active Patterns, Async workflows, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material",
13/04/2015 12:40:44,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly","MSDN, Links and instructions from fsharp.org, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,It's used unofficially,Utilities and tools,Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Computation expressions, Object expressions, Object-oriented compatibility, Units of measure",Don't understand the compiler errors,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,Not being part of the core .NET distribution,"Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents","Active Patterns, Async workflows, Easy integration with other .NET libraries, Immutability by default, No dependency cycles, printf that is type checked, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with real-world examples and war stories, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 12:41:24,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","MSDN, F# books, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Mainstream business & enterprise applications","Internal enterprise projects, Open source projects","SQL databases, NoSQL database, Data integration and EAI",Visual Studio 2012 or newer,Windows,"Windows, Mac, Azure","Javascript, Native","C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Units of measure,Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Enterprise development,,"Not being part of the core .NET distribution, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Async workflows, Backtick naming, Easy integration with other .NET libraries, Immutability by default, Interactive development, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More podcasts and other audio-only material",
13/04/2015 12:44:18,10 or more years,"No, I don't know much theory",Just tinkering,,"Twitter, F# Weekly","F# books, F# bloggers, Videos (e.g. Community for F#), Reading F# code written by experts",,I don't use F# at work,Utilities and tools,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux",JVM,Scala,,"Conciseness of code (I can see more at a glance), Great community, Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Agents (MailboxProcessor),Not enough real-world code to learn from,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I like theory -- I'm not afraid of monads and other abstractions,,Less than two months,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Active Patterns, Computation expressions, Easy integration with other .NET libraries, The ""piping"" idiom",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 12:44:26,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, HN, Reddit and other programming news sites, F# bloggers","MSDN, Links and instructions from fsharp.org, F# bloggers, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for critical/production areas,,,,Visual Studio 2012 or newer,Windows,,,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Agents (MailboxProcessor),,,I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Financial services or similar,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems, Lack of F# support in immediate window when debugging",,"Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,,
13/04/2015 12:47:08,10 or more years,"No, I don't know much theory",Just tinkering,,Twitter,"F# books, F# bloggers, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,,Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Javascript",,"Conciseness of code (I can see more at a glance), Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,"I can't use my knowledge from C# or other imperative languages, Don't understand the compiler errors",,I want to learn functional programming but I don't like academic jargon,,Less than two months,,Enterprise development,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework",,,,"More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 12:48:21,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, Google groups","MSDN, F# books",,It's used unofficially,"Utilities and tools, Text analysis/language parsing",Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, Mac, Linux",Native,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Computation expressions, Quotations, Static type constraints, Units of measure",,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,Cross-platform issues,,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, Type inference",,,"More material with real-world examples and war stories, More podcasts and other audio-only material",
13/04/2015 12:49:40,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Videos (e.g. Community for F#), Reading F# code written by experts",,It's used unofficially,"None - Just playing around, Utilities and tools",Not applicable. None of my F# code is used by other people,,Visual Studio 2010 or older,Windows,,None -- I'm happy with the CLR/Mono,C#,,"Great community, Having fun again",Beginner (For example: you know OO well and functional programming seems strange),,,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Financial services or similar,,Paradigm shift,,"Immutability by default, The ""piping"" idiom",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More podcasts and other audio-only material",The survey is spot on. I like that all q's are optional. Looking forward to having a look at the results. 
13/04/2015 12:49:41,Less than a year,"No, I don't know much theory",Just tinkering,"Minimal learning material for use in more practical consumer/end-user applications, insufficient local support and job prospects in my area, community focus on ""Big Data"" and financial computing conflicts with my moral beliefs.","Twitter, F# Weekly","Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly",,I don't use F# at work,None - Just playing around,Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, WinPhone","Javascript, LLVM, Native","Clojure, Haskell, Javascript, Scheme/CL, Racket",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows, Computation expressions, Integration with non-F# libraries, Object-oriented compatibility, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from","Fad: They have concerns over long term language viability, Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft",I want to learn functional programming but I don't like academic jargon,"Fundamentally I think the biggest problem with F# is that its architects at Microsoft assume that no one will want to write applications in pure F#, and so simply haven't bothered tackling the issue seriously. The focus of the community is largely on backend computation and ""Big Data"" processing, with almost no dedicated support for something as simple as making a Windows application from start to finish without falling back to C# code for most of the work, and largely much of the material assumes you already know enough C# to do that.",I was using F# but have stopped,,Student,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling",,"Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference","F# needs more material (tutorials, libraries, VS templates) for making complete applications entirely in F#, in an idiomatic way that matches the ease of use of the rest of the language's features and the functional programming style. ",,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 12:56:33,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"Twitter, F# Weekly, F# bloggers","F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,I don't use F# at work,Utilities and tools,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Javascript",,"Better domain modelling with records and unions, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Static type constraints, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc.",,"Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 13:00:36,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, Slack chat","F# books, F# bloggers, Links posted on social media such as Twitter, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Research/Teaching, Text analysis/language parsing","Internal enterprise projects, Open source projects","NoSQL database, Event sourcing, Read-only data sources such as feeds",Emacs,"Windows, Mac, Linux","Mac, Linux","LLVM, Native","C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Static type constraints, Units of measure",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,"Academic, research, or related",,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Cross-platform issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Interactive development, Simple ""one liner"" type definitions for records and DUs, Type inference, Type providers",,,"More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 13:00:38,5-10 years,"No, I don't know much theory",I use it at work or for other commercial uses,,"F# Weekly, Google groups, HN, Reddit and other programming news sites, F# bloggers, slack","F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's used unofficially,"Mainstream business & enterprise applications, Data analysis/statistics","Internal enterprise projects, Commercial products","SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Javascript",,"Correctness (no nulls, it works first time), Having fun again",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows, Interactive development, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from","Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,Lack of really amazing tooling.,Less than a year,,Data or analytics related,,Not being part of the core .NET distribution,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Immutability by default, Type inference, Type providers",Have Scott W. finish the railroad oriented programming tutorial series on fsharpforfunandprofit.com,"Keep pushing it as ""not just for academic stuff.""","More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 13:01:03,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly","Answers to Stack Overflow questions, trying and failing",,It's officially endorsed for critical/production areas,"Mainstream business & enterprise applications, Data analysis/statistics","Internal enterprise projects, Commercial products","SQL databases, Analytics",,Windows,"Windows, Azure",None -- I'm happy with the CLR/Mono,"C#, Javascript, R",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Computation expressions, Units of measure","Lack of good tutorials/documentation, Installation process","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I'm willing to learn advanced concepts but only if they are relevant and practical,"Need more templates in VS, esp on the web stack",2-3 years,,Enterprise development,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Easy integration with other .NET libraries, Immutability by default, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers","Need more templates in VS, esp on the web stack",,"More material with short ""cookbook"" style information, More short ""live coding"" videos",
13/04/2015 13:02:23,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"Twitter, F# Weekly","MSDN, Links and instructions from fsharp.org, F# books, Reading F# code written by experts",,It's used unofficially,None - Just playing around,Not applicable. None of my F# code is used by other people,Event sourcing,Visual Studio 2012 or newer,"Windows, Linux",,,"C#, Javascript, Python, Visual Basic",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Beginner (For example: you know OO well and functional programming seems strange),Object-oriented compatibility,Lack of good tutorials/documentation,,I'm willing to learn advanced concepts but only if they are relevant and practical,"The learning curve is pretty steep. There are a bunch of concepts you need to know before you begin. It is not keyboard friendly, too many special characters and keyboard chords. ",Less than two months,,Enterprise development,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",Domain modelling: making illegal states unrepresentable,"Algebraic types (inc discriminated unions and tuples), Interactive development, Simple ""one liner"" type definitions for records and DUs, Units of measure",,,"More material with short ""cookbook"" style information, What does idiomatic f# look like?",
13/04/2015 13:02:34,Less than a year,"No, I don't know much theory",I'm a complete newbie to programming,,"Twitter, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, Links posted on social media such as Twitter, Videos (e.g. Community for F#), I'm a complete newbie to programming",,I don't use F# at work,"None - Just playing around, Financial services, Machine learning, Data analysis/statistics, Text analysis/language parsing, Other",I'm a complete newbie to programming,"Read-only data sources such as feeds, Analytics",I'm a complete newbie to programming,Windows,"Windows, Azure, Other",None -- I'm happy with the CLR/Mono,"Erlang, Haskell",,"Learning functional programming in general, I'm a complete newbie to programming",Beginner (For example: you know OO well and functional programming seems strange),Object-oriented compatibility,"Lack of good tutorials/documentation, Installation process, Don't understand the compiler errors, Not enough real-world code to learn from, I'm a complete newbie to programming","Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams, I'm a complete newbie to programming",I like theory -- I'm not afraid of monads and other abstractions,"No clear learning path and educational certification,   therefore there is a lack of structure",Haven't really used it yet,"Yes, please sit down with the F# software foundation and create a structured educational certification program so that we can have ""Certified Functional Programmer"" aka CFP.

Have a look at Erlangs educational certification program for guidance
",Student,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",I'm a complete newbie to programming,I'm a complete newbie to programming,More videos and tutorials targeted specifically at newbies like myself,More videos and tutorials,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans), I'm a complete newbie to programming",
13/04/2015 13:04:07,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","F# books, F# bloggers, Reading F# code written by experts",,It's officially endorsed for critical/production areas,Financial services,Commercial products,SQL databases,Visual Studio 2012 or newer,Windows,Windows,"None -- I'm happy with the CLR/Mono, JVM, Native","C, C#, C++",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Object-oriented compatibility","I can't use my knowledge from C# or other imperative languages, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I like theory -- I'm not afraid of monads and other abstractions,"No type classes
Lack of support/promotion from Microsoft",4 or more years,,Financial services or similar,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 13:06:01,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly","F# books, F# bloggers, Reading F# code written by experts, just use it",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Machine learning, Data analysis/statistics, Text analysis/language parsing",Internal enterprise projects,,Visual Studio 2012 or newer,Windows,"Windows, Azure",Native,F#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Object-oriented compatibility, Quotations",,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Nothing. Everyone loves it.",I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Data or analytics related,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Interactive development, Type inference, Type providers",use F# at school (no OO-damaged brains will learn it easily ;-),,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 13:11:58,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, Google groups, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Personal mentoring, Videos (e.g. Community for F#), Reading F# code written by experts",,I don't use F# at work,None - Just playing around,"Open source projects, Not applicable. None of my F# code is used by other people","NoSQL database, Event sourcing",Visual Studio 2012 or newer,"Windows, Mac","Windows, Mac, Azure","Javascript, LLVM","C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows, Interactive development",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Fad: They have concerns over long term language viability, Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems, Cross-platform issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Object expressions, Quotations, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,More material with real-world examples and war stories,
13/04/2015 13:15:02,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# bloggers","F# books, F# bloggers, Links posted on social media such as Twitter, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Games, Mainstream business & enterprise applications, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Commercial products","NoSQL database, Analytics",Visual Studio 2012 or newer,"Windows, Mac, Linux","Windows, Linux, iOS, Android, WinPhone","JVM, Javascript, LLVM, Native","C#, Java, Javascript, Scala",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),Agents (MailboxProcessor),Not enough real-world code to learn from,"Hiring: They worry about not being able to find F# developers, Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,lack of type class,1-2 years,,Game,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Better for solving complex problems","Computation expressions, No dependency cycles, Quotations, Simple ""one liner"" type definitions for records and DUs, inline",,,More material with in-depth tutorials,
13/04/2015 13:16:42,10 or more years,"No, I don't know much theory",Just tinkering,"Poor tooling.
","Twitter, F# bloggers",Learn it as a second functional language.,,I don't use F# at work,None - Just playing around,Open source projects,SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,Learning functional programming in general,Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,"Lack of good tutorials/documentation, Installation process, Don't understand the compiler errors, Unpleasant interactions with the community","Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I want to learn functional programming but I don't like academic jargon,The debugging/development experience.,I was using F# but have stopped,,Enterprise development,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",,"Active Patterns, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Units of measure","Community suffers from the near universal problem that all languages seem to suffer from, but made more extreme by it's youth.

Namely the ""To draw an owl start with two circles then draw the rest of the owl"" joke is far too prevalent with tutorials being either single file snippets or massive go read the OSS project. With little to no clues about how to go from one to the other.",By groking that ,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More short ""live coding"" videos",
13/04/2015 13:20:39,10 or more years,"No, I don't know much theory",Just tinkering,,"Twitter, F# bloggers, functionalprogramming slack","F# books, F# bloggers, Links posted on social media such as Twitter, Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,"NoSQL database, Read-only data sources such as feeds",Textmate,Mac,"Windows, Mac, Azure","Javascript, LLVM","C#, Haskell, Objective-C, Ruby, Swift",,Learning functional programming in general,"Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Interactive development, Object expressions, Quotations, Type providers, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,Haven't really used it yet,,Enterprise development,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Cross-platform issues",,"Agents (MailboxProcessor), Async workflows, Easy integration with other .NET libraries, Immutability by default",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 13:34:45,5-10 years,"No, I don't know much theory",Just tinkering,,"Twitter, F# Weekly","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly",,I don't use F# at work,"None - Just playing around, Utilities and tools",Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Agents (MailboxProcessor), Async workflows, Computation expressions, Quotations",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Easy integration with other .NET libraries, Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 13:40:29,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,Twitter,"F# books, F# bloggers, Links posted on social media such as Twitter, Answers to Stack Overflow questions",,,"Research/Teaching, Data analysis/statistics",Not applicable. None of my F# code is used by other people,Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,,None -- I'm happy with the CLR/Mono,R,,"Great community, Functional but can be tweaked to get high performance","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Async workflows, Integration with non-F# libraries, Object expressions, Object-oriented compatibility, Units of measure","Don't understand the compiler errors, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Fad: They have concerns over long term language viability",I'm willing to learn advanced concepts but only if they are relevant and practical,"It is not as easy to transition from dynamic languages as some people think. In other words, the language is simple, but the tooling is complex from the perspective of somebody coming from R, python, ruby world that is a researcher rather than computer scientist.

Like, the Visual Studio projects concept is confusing if I just want to use fsx. I want my student to use it with libraries, but they get confused. Tomas' fslab basic template .zip was very helpful with this once discovered.

Also, e.g., I try to startup using fsharp.data to parse a .csv but loading a 2gb data set fails (I think large file support has since been fixed, but for awhile is ""issues"" on github this was not seen as a problem) or R will load the file into a data.frame faster than Deedle will. Basically, the toy examples on fsharp.data and deedle look great, but when I try to use it with real large datasets, things start to break and there's not tutorial on how to actually use these tools, or best practices for performance, when you have large datasets.

I know above is sometimes not really comments about F#, but libraries. But Fsharp.data and deedle are two libraries heavily pushed by the community for getting non-comp sci empirical researchers to embrace F#.",1-2 years,,"Academic, research, or related",,,Efficiency/Performance,"Interactive development, The ""piping"" idiom, Type providers",,,"More material with short ""cookbook"" style information",
13/04/2015 13:45:37,10 or more years,"No, I don't know much theory",Just tinkering,,"Twitter, F# Weekly","F# books, F# bloggers, Videos (e.g. Community for F#)",,It's used unofficially,"None - Just playing around, Text analysis/language parsing",Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,Windows,Windows,"Javascript, LLVM","Javascript, Delphi",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",Units of measure,Not enough real-world code to learn from,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I want to learn functional programming but I don't like academic jargon,,Less than a year,,Enterprise development,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Faster time to market, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More podcasts and other audio-only material",
13/04/2015 13:56:26,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# bloggers","F# books, F# bloggers",,It's used unofficially,,,,Sublime Text,Windows,,"JVM, Javascript","C#, Go, Java, Javascript, Perl",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,Don't understand the compiler errors,,I'm willing to learn advanced concepts but only if they are relevant and practical,"The question above about compiler errors really hit home, they are ",Less than two months,,Enterprise development,,"Not being part of the core .NET distribution, Lack of F# friendly libraries",Faster time to market,"The ""piping"" idiom, Type providers",,"Sadly, it's a chicken/egg problem Ruby didn't really take off until Rails, which was a platform for getting things done quickly. It's hard to make the case that the language itself does that.",Solving concrete business problems. More of the DDD with F# would be great.,
13/04/2015 13:56:58,Less than a year,"No, I don't know much theory",I use it for hobby or side projects,,"F# Weekly, HN, Reddit and other programming news sites","F# books, F# bloggers, Links mentioned in F# Weekly",,It's used unofficially,"None - Just playing around, Data analysis/statistics, Text analysis/language parsing",Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Python",,Learning functional programming in general,Beginner (For example: you know OO well and functional programming seems strange),,Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I want to learn functional programming but I don't like academic jargon,,Less than two months,,Data or analytics related,,"Not being part of the core .NET distribution, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.",,"Easy integration with other .NET libraries, Object-oriented features (inc. C# compatibility, conciseness), Type inference, Units of measure",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 13:57:03,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,"No coworkers or peers using it. Dealing with 3rd party libraries/packaging confusing on mac/linux. Began using Haskell and type classes, esp. For numbers, felt more convenient. ","Twitter, F# Weekly","F# books, F# bloggers, Links mentioned in F# Weekly",,I don't use F# at work,"Machine learning, Data analysis/statistics",Not applicable. None of my F# code is used by other people,SQL databases,Emacs,Mac,Mac,"LLVM, Native","Clojure, Elixir, Python, R",,"Better domain modelling with records and unions, Having fun again",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Units of measure,Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft, Benefits of F# over haskell or ocaml.",I'm willing to learn advanced concepts but only if they are relevant and practical,Mac/linux support & community. Lack of type classes/polymorphism feels awkward with heavy numeric work (float/int conversions everywhere),1-2 years,,Data or analytics related,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Cross-platform issues",Domain modelling: making illegal states unrepresentable,"Algebraic types (inc discriminated unions and tuples), Immutability by default, The ""piping"" idiom, Type inference, Type providers",,Better Mac/linux support.  Good ML/data/numeric libraries with decent performance and documentation. (Competitive with python or JVM langs). ,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 14:09:30,5-10 years,"No, I don't know much theory",I use it at work or for other commercial uses,,F# bloggers,"F# bloggers, Personal mentoring, Videos (e.g. Community for F#)",,I don't use F# at work,,,,Unsure yet,,,"Javascript, Native","Javascript, PHP, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,,"Hiring: They worry about not being able to find F# developers, Fad: They have concerns over long term language viability, Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft",I like theory -- I'm not afraid of monads and other abstractions,The need for .NET,Haven't really used it yet,,Enterprise development,,,,"Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Immutability by default, Interactive development, Object expressions, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material",
13/04/2015 14:12:25,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"F# Weekly, F# bloggers","F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Algorithm-heavy business applications (non-financial), Research/Teaching, Text analysis/language parsing",Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux","LLVM, Native","C#, C++, Python",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Object expressions",,Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,Science or related,,"Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Performance issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Interactive development, Type inference, Type providers, Units of measure",,,,
13/04/2015 14:16:06,5-10 years,"No, I don't know much theory",I use it for hobby or side projects,,F# Weekly,fsharpforfunandprofit.com,,I don't use F# at work,"None - Just playing around, Utilities and tools, Other",Not applicable. None of my F# code is used by other people,"SQL databases, Read-only data sources such as feeds",Emacs,Linux,Linux,"JVM, Javascript","Javascript, Python",,"Correctness (no nulls, it works first time), Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor), Computation expressions, Quotations, Type providers","Don't understand the compiler errors, Not enough real-world code to learn from",No buy-in: There is lack of acceptance from other teams,I'm willing to learn advanced concepts but only if they are relevant and practical,"Everyone assumes you develop like a Windows developer, with Windows developer tools and workflows. Coming from a Linux/OSS background, needing an IDE to generate MSBuild scripts and .sln files, and having to manually point to .dlls and add references, and generate projects from templates etc., is insanely clunky. It seriously gets in my way for creating short one-off scripts in F# where I don't want the hassle of grabbing the F# Project Scaffold and wiring everything up.",Less than a year,,Enterprise development,,"Lack of good wrappers for non-F# libraries, Difficulty in troubleshooting problems",,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference","More resources that don't assume you're clicking buttons and loading templates in Visual Studio (or any IDE, really, but at least not VS). Document the new-project boilerplate code!",,More material with real-world examples and war stories,
13/04/2015 14:21:24,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Structured training/workshops",,It's used unofficially,"None - Just playing around, Utilities and tools",Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,"Windows, Mac, Linux",Windows,"JVM, Javascript, LLVM, Native","C#, Java",,Better domain modelling with records and unions,Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Object expressions, Quotations, Static type constraints, Units of measure",No ReSharper,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I like theory -- I'm not afraid of monads and other abstractions,No support from JetBrains,Less than a year,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, More productive with fewer developers, Faster time to market","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Immutability by default, Interactive development, The ""piping"" idiom, Type providers",,,"More material with in-depth tutorials, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 14:22:40,2-5 years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","F# books, F# bloggers, Links posted on social media such as Twitter, Videos (e.g. Community for F#), Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Custom development/specialist markets, Text analysis/language parsing",Internal enterprise projects,"SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,Native,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Async workflows, Computation expressions, Object expressions, Quotations, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Fad: They have concerns over long term language viability",I'm willing to learn advanced concepts but only if they are relevant and practical,"Lack of type classes and higher kinds. Not adding new language features fast enough given that C# will be adding many F# features such as pattern matching, record types and some form of algebraic data type. If F# doesn't add more advanced features soon, it the language may lose momentum and slowly fade into obscurity.",4 or more years,"F# must continue to innovate. When C# gets pattern matching, union types, record types and a better tuple syntax, it will be hard to convince developers to switch, unless F# can be seen to offer much higher level language features. ",Enterprise development,,"Not being part of the core .NET distribution, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, printf that is type checked, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More podcasts and other audio-only material",
13/04/2015 14:25:23,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"F# Weekly, F# bloggers","F# bloggers, Answers to Stack Overflow questions, F# for Fun and Profit website",,It's officially endorsed for critical/production areas,"Utilities and tools, Financial services","Internal enterprise projects, Commercial products",SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Type providers, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,http://ericsink.com/entries/fsharp_chasm.html,1-2 years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Knowing that my colleagues don't care much about it","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, No dependency cycles, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference","Open and honest admittance of the obstacles to adoption, rather than more evangelism.  Knowing that it can be hard (for many and various reasons, both technical and political) makes it easier.
","I doubt that the F# community can do much.  It all comes down to Microsoft's attitude; if they were more positive about it (e.g. explicitly supporting F# and the functional paradigm in ASP.NET vNext), that would go a *long* way in persuading more devs in my shop to do more with F#.

Most enterprise devs take their cue from Microsoft, and the ""F# community"" counts for little.

The day Scott Hanselman blogs with regularity about F# and FP... then you know that F# has arrived.  Scott Hanselman represents what I call ""mainstream Microsoft"" and those guys can't break away from C# / OOP it seems.


",,
13/04/2015 14:25:47,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Research/Teaching, Data analysis/statistics",Not applicable. None of my F# code is used by other people,"NoSQL database, Event sourcing, Analytics",Vim,"Mac, Linux","Windows, Linux, Azure",JVM,"C#, C++, Erlang, Javascript",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Quotations, Type providers, Units of measure",Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, Too Windows-centric: They have concerns over cross-platform issues, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,"Lack of F# friendly libraries, Cross-platform issues","Domain modelling: making illegal states unrepresentable, Easy concurrency with async and agents","Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Immutability by default, The ""piping"" idiom",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 14:26:01,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,Twitter,"Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Javascript",,"Conciseness of code (I can see more at a glance), Learning functional programming in general",Beginner (For example: you know OO well and functional programming seems strange),Units of measure,Don't understand the compiler errors,"Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I want to learn functional programming but I don't like academic jargon,,Less than two months,,Enterprise development,,"Less sophisticated tools for refactoring, etc.",,Immutability by default,,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 14:26:10,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,StackOverflow chat,"F# books, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,It's used unofficially,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,None -- I'm happy with the CLR/Mono,"C#, Java, Javascript",,"Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Agents (MailboxProcessor), Async workflows, Object expressions, Object-oriented compatibility, Units of measure",Don't understand the compiler errors,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",,"Easy integration with other .NET libraries, Immutability by default, printf that is type checked, The ""piping"" idiom",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 14:32:17,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, IRC",Reading F# code written by experts,,It's officially endorsed for critical/production areas,"Mainstream business & enterprise applications, Other","Internal enterprise projects, Open source projects","NoSQL database, Event sourcing",Vim,"Windows, Mac, Linux","Windows, Linux","LLVM, Native","C#, Erlang",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Quotations, Type providers",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I like theory -- I'm not afraid of monads and other abstractions,,3-4 years,,Enterprise development,,Cross-platform issues,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Immutability by default, The ""piping"" idiom, Type inference",,,More material with in-depth tutorials,
13/04/2015 14:34:06,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"Twitter, F# bloggers","MSDN, Reading F# code written by experts, Just hacking and gaining experience.",,It's used unofficially,Data analysis/statistics,Not applicable. None of my F# code is used by other people,Read-only data sources such as feeds,Emacs,Mac,"Windows, Mac, Linux","JVM, Native","C++, Java, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Object expressions","Don't understand the compiler errors, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Nothing. Everyone loves it.",I like theory -- I'm not afraid of monads and other abstractions,,Less than two months,,"Academic, research, or related",,Lack of F# friendly libraries,"Domain modelling: making illegal states unrepresentable, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, No dependency cycles, printf that is type checked, The ""piping"" idiom, Type inference",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 14:36:44,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,F# Weekly,"Links and instructions from fsharp.org, F# bloggers, Links mentioned in F# Weekly, Personal mentoring",,It's used unofficially,"Utilities and tools, Other",Internal enterprise projects,"SQL databases, Event sourcing",Visual Studio 2012 or newer,Windows,Windows,,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",,,,"Hiring: They worry about not being able to find F# developers, Fad: They have concerns over long term language viability, Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Backtick naming, Easy integration with other .NET libraries, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type providers, Units of measure",,displace the myth of Java,,
13/04/2015 14:40:14,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"Twitter, F# Weekly, F# bloggers, Slack - Functional Programming","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Reading F# code written by experts, F# for fun and profit",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,"Windows, Mac","Windows, Mac","Javascript, Native","C#, Javascript",,"Better domain modelling with records and unions, Learning functional programming in general",Beginner (For example: you know OO well and functional programming seems strange),"Agents (MailboxProcessor), Async workflows","Don't understand the compiler errors, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I like theory -- I'm not afraid of monads and other abstractions,The compiler errors definitely didn't help me find the issues that I had used a comma instead of a semicolon.  That is definitely a noob error.  I got an immediate answer from the community (Slack - Functional Programming).,Less than two months,Loving F# so far and can't wait to actually start building something.,Enterprise development,,"Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference","I've been walking through F# For Fun and Profit, and like the layout for starting to learn f#.  I've also been bookmarking f# blog posts to come back to.  I like that learning style, but have also bought two books.  F# Deep Dive was definitely not a starter book, but I'll get back to it.  Real World Functional Programming is what I am starting now.

While both of these are good, more F# for C# people might be helpful.","I work at a large company and it has pretty strict SOPs about language use.  Right now, it's not viable.  I think, in general, getting the word out to people who have not drank the coolaid is key.  MSDN articles.  Mentions by key Microsoft people.  It's showing up more in the conferences, but still a small share.","More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 14:46:59,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly","F# books, Videos (e.g. Community for F#), fsharpforfunandprofit",,It's used unofficially,"None - Just playing around, Utilities and tools",Internal enterprise projects,"SQL databases, NoSQL database, Event sourcing",Visual Studio 2012 or newer,Windows,Windows,"None -- I'm happy with the CLR/Mono, asp.net vnext apps (not a platform, but that's what I want)","C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Computation expressions, Object-oriented compatibility, Quotations, Static type constraints, Units of measure",,other devs that are sceptical to FP,I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,,"Correctness: fewer bugs and less rework, Faster time to market, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Immutability by default, No dependency cycles, Object expressions, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers","More examples at conferences showing how it's been used in ""real"" applications.",,"More material with short ""cookbook"" style information, More short ""live coding"" videos",
13/04/2015 14:55:11,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"HN, Reddit and other programming news sites, F# bloggers","MSDN, F# bloggers, Answers to Stack Overflow questions",,It's used unofficially,"Utilities and tools, Machine learning",Internal enterprise projects,"SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,Not enough real-world code to learn from,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",Including a good linting tool that integrates well with visual studio.,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 14:55:49,10 or more years,"Yes, I enjoy computer science and mathematics","I'd like to use it at work, but can't. So hobby for now.",,F# bloggers,"Links and instructions from fsharp.org, F# books, F# bloggers, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,Don't understand the compiler errors,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,Haven't really used it yet,,Enterprise development,,,,"Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 14:57:33,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, Meetup","F# bloggers, Answers to Stack Overflow questions, Personal mentoring, Structured training/workshops, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Mainstream business & enterprise applications, Text analysis/language parsing",Commercial products,"SQL databases, Event sourcing",Visual Studio 2012 or newer,Windows,Windows,JVM,"C#, Java, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Type providers, Units of measure",not frustrated at all,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,,3-4 years,,Enterprise development,,interop with C#,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Backtick naming, Immutability by default, No dependency cycles, The ""piping"" idiom, Type inference",,,More material with real-world examples and war stories,
13/04/2015 15:05:26,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Machine learning, Mainstream business & enterprise applications, Mobile apps, Research/Teaching, Data analysis/statistics, Other","Internal enterprise projects, Commercial products, Open source projects","SQL databases, Data integration and EAI",Visual Studio 2012 or newer,Windows,"Windows, Linux, Android",,"C#, C++, Java, R",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),Agents (MailboxProcessor),"Insufficient examples on MSDN and Stack Overflow, so you always have to translate from C# (which is always straightforward, but still takes time)","Those of use who are already using it love it, but not everyone has started to use it yet.",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Science or related,,"Not being part of the core .NET distribution, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, printf that is type checked, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,More material with real-world examples and war stories,
13/04/2015 15:11:09,5-10 years,"No, I don't know much theory",Just tinkering,,Twitter,"MSDN, F# bloggers, Answers to Stack Overflow questions",,I don't use F# at work,"None - Just playing around, Utilities and tools",Not applicable. None of my F# code is used by other people,"NoSQL database, Event sourcing",Visual Studio 2012 or newer,Windows,Windows,Native,"C#, C++",,"Better domain modelling with records and unions, Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,Not enough real-world code to learn from,"Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I want to learn functional programming but I don't like academic jargon,,Haven't really used it yet,,Enterprise development,,Working with C#-centric tooling,,"Immutability by default, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom",,,"More material with in-depth tutorials, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 15:13:30,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,Twitter,"Links and instructions from fsharp.org, F# bloggers, Answers to Stack Overflow questions",,It's used unofficially,"Utilities and tools, Algorithm-heavy business applications (non-financial)",Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Python",,"Conciseness of code (I can see more at a glance), Having fun again",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Units of measure","Lack of good tutorials/documentation, I can't use my knowledge from C# or other imperative languages, Not enough real-world code to learn from",No buy-in: There is lack of acceptance from other teams,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Science or related,,"Not being part of the core .NET distribution, Performance issues","Correctness: fewer bugs and less rework, More productive with fewer developers, Easy concurrency with async and agents","Async workflows, Backtick naming, Easy integration with other .NET libraries, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 15:20:09,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Personal mentoring, Reading F# code written by experts",,I don't use F# at work,"Utilities and tools, Algorithm-heavy business applications (non-financial), Custom development/specialist markets",Open source projects,"SQL databases, NoSQL database, Event sourcing",Visual Studio 2012 or newer,"Windows, Mac, Linux","Windows, Mac, Linux","Javascript, Native","C#, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Great community, Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Integration with non-F# libraries, Quotations, Units of measure","Installation process, Not enough real-world code to learn from","Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,"- missing interface implicit implementation
- debug F# script directly from IDE
",4 or more years,,Enterprise development,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Cross-platform issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Agents (MailboxProcessor), Async workflows, Backtick naming, Easy integration with other .NET libraries, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,More material with in-depth tutorials,
13/04/2015 15:23:09,5-10 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,Twitter,"MSDN, Answers to Stack Overflow questions",,I don't use F# at work,Utilities and tools,Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor)",,Training: They are worried about getting non-F# developers up to speed,I'm willing to learn advanced concepts but only if they are relevant and practical,,Haven't really used it yet,,Web,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.",,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default",,,"More material with short ""cookbook"" style information, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 15:25:41,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","MSDN, Links and instructions from fsharp.org, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,I don't use F# at work,"None - Just playing around, Machine learning, Data analysis/statistics",Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,"Windows, Mac","Windows, Mac, Linux",Native,"C, C#, C++, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Quotations, Type providers, Units of measure","Don't understand the compiler errors, Not enough real-world code to learn from",,I'm willing to learn advanced concepts but only if they are relevant and practical,"Compiler and debug issues. When code refuses to compile, it can be sticky to figure out exactly what's causing the issue as a new F# programmer. And the debuggers don't have clear support for many functional features yet; piping data through a iter or filter function lacks critical information about the iteration process. Other compiler issues like this exist, and simply need more development.",Less than two months,"Very good survey, well thought out. Might be good to use the survey to solicit ideas for spreading knowledge of F#, not simply making learning it more easily. Learning tools are only so useful if people know F# exists.",Student,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, printf that is type checked, The ""piping"" idiom, Type inference","I have ""seen the light"" of functional style, so to speak. F# can be made easier for everyone else when there is a focus on teaching functional thinking from the ground up. F# For Fun and Profit does this, but is a bit brief; however, its focus on using features like pattern matching and union types to avoid imperative style where possible is essential, and should be expanded upon in the friendliest format possible.","Clearly demonstrate how easily it can integrate into existing workflows, and demonstrate, concisely and clearly, the benefits of learning functional style in such a manner that programmers will WANT to switch to F#.","More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 15:27:02,5-10 years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly","Links posted on social media such as Twitter, fsharpforfunandprofit.com",,It's used unofficially,Utilities and tools,"Commercial products, Open source projects",Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, Azure",None -- I'm happy with the CLR/Mono,"C#, Haskell, Javascript",,Having fun again,Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows, Interactive development",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Open Source,,,More productive with fewer developers,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Immutability by default, No dependency cycles, Object expressions, Quotations, Type inference",,,Getting up and running with F# in editors like Emacs,
13/04/2015 15:29:58,5-10 years,"No, I don't know much theory",I use it at work or for other commercial uses,,F# Weekly,"F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Custom development/specialist markets, Mainstream business & enterprise applications",Internal enterprise projects,"SQL databases, NoSQL database, Analytics",Visual Studio 2012 or newer,Windows,Windows,"JVM, Javascript, LLVM",C#,,Having fun again,"Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Computation expressions","Lack of good tutorials/documentation, Not enough real-world code to learn from","Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I want to learn functional programming but I don't like academic jargon,,1-2 years,,IT management,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Easy concurrency with async and agents","Backtick naming, Immutability by default, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 15:30:15,10 or more years,"No, I don't know much theory",Just tinkering,"Found it difficult to make progress using Xamarin, which was our primary use case.  The documentation wasn't good enough to get up to speed.  F# has some interesting ideas, but it was taking too long to get working demos.",F# Weekly,"Links and instructions from fsharp.org, F# books, F# bloggers",,I don't use F# at work,Mobile apps,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Xamarin,Mac,"Mac, iOS",None -- I'm happy with the CLR/Mono,"Javascript, Python, Rust",,Getting back into functional programming,Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Object-oriented compatibility","Lack of good tutorials/documentation, Not enough real-world code to learn from",No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,Thorough documentation and tutorials with real-world examples.,Less than two months,,Enterprise development,,Working with C#-centric tooling,,"Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Units of measure",,,More material with in-depth tutorials,
13/04/2015 15:31:55,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","MSDN, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Mainstream business & enterprise applications, Text analysis/language parsing",Internal enterprise projects,"SQL databases, Data integration and EAI",Visual Studio 2012 or newer,Windows,Windows,"JVM, Javascript, Native","C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development, Incremental development/testing using FSI",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Quotations, Type providers, Units of measure",,No buy-in: There is lack of acceptance from other teams,I'm willing to learn advanced concepts but only if they are relevant and practical,Microsoft's lack of advocacy.,4 or more years,,Enterprise development,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Type inference",,,,
13/04/2015 15:33:02,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, HN, Reddit and other programming news sites","F# books, F# bloggers, Links mentioned in F# Weekly",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,JVM,"C++, Java, Scala, Q",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Quotations, Type providers, Units of measure",Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Too Windows-centric: They have concerns over cross-platform issues",I'm willing to learn advanced concepts but only if they are relevant and practical,Richness of standard library. Just look over to scala for the kind of functionality available from the get go. .NET interop needs to be more clearly documented.(For example I really struggled at using generic.Dictionary within my Fsharp code),Less than a year,,Financial services or similar,,,,"Computation expressions, Immutability by default, The ""piping"" idiom, Type inference",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 15:40:59,5-10 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"HN, Reddit and other programming news sites, F# bloggers, StackOverflow chat","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications, Text analysis/language parsing, Other","Internal enterprise projects, Commercial products",Read-only data sources such as feeds,Visual Studio 2012 or newer,"Windows, Mac","Windows, Amazon Web services",Native,"C#, Java, Ruby, Scala",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Object expressions, Quotations, Type providers, Units of measure","Lack of good tutorials/documentation, Don't understand the compiler errors","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,2-3 years,,Enterprise development,,"Not being part of the core .NET distribution, Less sophisticated tools for refactoring, etc., resharper","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,Resharper support,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 15:44:00,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,"It's not a choice, but my efforts to introduce F# into my organization stopped at FAKE. It's tough to go beyond that.","Twitter, F# Weekly","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Reading F# code written by experts",,It's used unofficially,Custom development/specialist markets,Internal enterprise projects,"SQL databases, NoSQL database",Visual Studio 2012 or newer,"Windows, Mac",,"JVM, LLVM",C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Quotations","Don't understand the compiler errors, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,,,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Type providers, Units of measure",,Be patient.,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 15:44:59,5-10 years,"Yes, I enjoy computer science and mathematics",Just tinkering,"Since I'm slow with F#, but fast in other languages (C#), I get frustrated and want to switch to get things done more quickly.  ","Twitter, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,Javascript,"C#, Java, Javascript, Visual Basic, Apex",,"Better domain modelling with records and unions, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Interactive development","I can't use my knowledge from C# or other imperative languages, Don't understand the compiler errors",No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,Lack of F# friendly libraries,,"Algebraic types (inc discriminated unions and tuples), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,More material with real-world examples and war stories,
13/04/2015 15:47:17,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"F# Weekly, F# bloggers","F# books, F# bloggers, Videos (e.g. Community for F#)",,It's used unofficially,"Utilities and tools, Data analysis/statistics",Internal enterprise projects,"NoSQL database, Event sourcing, Data integration and EAI",Visual Studio 2012 or newer,Windows,Windows,"Javascript, Native","C, C#, Java",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Interactive development, Object expressions, Object-oriented compatibility","Lack of good tutorials/documentation, Not enough real-world code to learn from","Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, Too Microsoft-centric: They think it is too closely linked to Microsoft",I want to learn functional programming but I don't like academic jargon,"Non-scientific, data-centric apps. Not because it can't do it well as a language, but because that part isn't promoted too much. Anything related to GUI is usually viewed as a second class use-case, something that should be left to OOP languages. As if ""we are real hackers, that stuff is not important"".

Apart from that, it is great as a language and a pleasure to work with once you get it. I think aversion to FP in general, and having a too academic approach to its teaching is what hinders its wider adoption.

It seems like only Scott Wlaschin has gotten the teaching part right. That's why we need his book being released so much ;)",3-4 years,Thank you for all your work regarding F# and contribution to the community.,Business development,,"Lack of good wrappers for non-F# libraries, Cross-platform issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, No dependency cycles, The ""piping"" idiom, Type inference","Having complete coded applications that serve as real world working examples. The ""Calculator Walkthrough"" series by Scott Wlaschin is a great example of this.

You have real world working code and a great guide to understand that code to build it from scratch till it's a full working application.","Increase easy learning resources with real world apps/examples, not half-baked examples.","More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 15:50:13,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers",,I don't use F# at work,"Utilities and tools, Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications, Research/Teaching",Not applicable. None of my F# code is used by other people,"SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Immutability by default, The ""piping"" idiom, Type providers",,,,
13/04/2015 16:02:01,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"F# Weekly, F# bloggers","F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Algorithm-heavy business applications (non-financial), Games, Mainstream business & enterprise applications, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Open source projects","NoSQL database, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,"Windows, Other",Javascript,"C#, Clojure, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Quotations",Not enough real-world code to learn from,"Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams, c# has much better tooling and integration",I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference","more real-world examples, integration with web and native platforms and frameworks, databases, ui
",,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 16:02:27,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"F# Weekly, Google groups, https://functionalprogramming.slack.com/messages/fsharp/","MSDN, Links and instructions from fsharp.org, F# books, Links mentioned in F# Weekly, Personal mentoring, Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Custom development/specialist markets, Mainstream business & enterprise applications, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Open source projects","SQL databases, Data integration and EAI, Not doing data centric apps",Visual Studio 2012 or newer,"Windows, Mac, Linux","Windows, Mac, Linux","None -- I'm happy with the CLR/Mono, Javascript","Visual Basic, SQL",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows, Computation expressions, Integration with non-F# libraries, Object expressions, Quotations, Units of measure","Lack of good tutorials/documentation, Unpleasant interactions with the community, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Fad: They have concerns over long term language viability",I want to learn functional programming but I don't like academic jargon,,Less than a year,"Scott, thank you very much.",Enterprise development,,"Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Cross-platform issues","Correctness: fewer bugs and less rework, More productive with fewer developers","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 16:06:19,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Personal mentoring, Reading F# code written by experts",,It's used unofficially,"Algorithm-heavy business applications (non-financial), Machine learning, Mainstream business & enterprise applications, Research/Teaching, Data analysis/statistics","Internal enterprise projects, Commercial products",Not doing data centric apps,Visual Studio 2012 or newer,"Windows, Mac","Windows, Azure, Amazon Web services",None -- I'm happy with the CLR/Mono,"C#, Javascript, R, Scala",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Quotations",I can't use my knowledge from C# or other imperative languages,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,2-3 years,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Immutability by default, Interactive development, Object expressions, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 16:10:34,5-10 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"F# Weekly, Google+","MSDN, Links and instructions from fsharp.org, F# bloggers, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,I don't use F# at work,"None - Just playing around, Custom development/specialist markets, Machine learning, Data analysis/statistics","Internal enterprise projects, Commercial products","SQL databases, Event sourcing, Read-only data sources such as feeds, Analytics, Data integration and EAI",Visual Studio 2012 or newer,Windows,"Windows, Azure","LLVM, Native","C++, Go, Javascript, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Quotations, Type providers","Lack of good tutorials/documentation, Not enough real-world code to learn from","Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,HKT,Haven't really used it yet,,Data or analytics related,,Lack of F# friendly libraries,,"Simple ""one liner"" type definitions for records and DUs, Type inference, Units of measure",Sample projects. Starting from a blank page is tough compared to learning by example,Beginner friendly to increase adoption rate,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories","Popular F# libraries?
Predictions on the future of F#?"
13/04/2015 16:10:42,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"F# Weekly, HN, Reddit and other programming news sites","MSDN, Links and instructions from fsharp.org, F# books, Links mentioned in F# Weekly, Reading F# code written by experts",,It's used unofficially,"Algorithm-heavy business applications (non-financial), Games",Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,"Windows, Linux","Windows, Mac, iOS",None -- I'm happy with the CLR/Mono,"C#, Scheme/CL",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Type providers,Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Fad: They have concerns over long term language viability",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,Keep up the awesome work!,Data or analytics related,,Working with C#-centric tooling,"Correctness: fewer bugs and less rework, Easy concurrency with async and agents","Active Patterns, Agents (MailboxProcessor), Async workflows, Easy integration with other .NET libraries, Immutability by default, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Units of measure",One of the best ways for me as a C# programmer by trade is to see problems that are often solved with C# being solved instead with F#. Seeing how different paradigms solve problems I'm used to solving helps immensely.,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 16:17:43,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"HN, Reddit and other programming news sites, F# bloggers","MSDN, Links and instructions from fsharp.org, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,"Utilities and tools, Financial services, Machine learning, Data analysis/statistics","Internal enterprise projects, Open source projects","SQL databases, NoSQL database, Read-only data sources such as feeds",Visual Studio 2012 or newer,"Windows, Mac","Windows, Mac, Linux, Azure, Amazon Web services",JVM,"C#, C++, Go, Haskell, Java, Python, R, Scala",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Quotations, Units of measure",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,Lack of tooling on the same level as ReSharper for C#.,4 or more years,,Enterprise development,,"Less sophisticated tools for refactoring, etc.",,"Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference, Type providers",,"More evangelism to the wider .NET community, at conferences, etc.","More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 16:21:03,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, HN, Reddit and other programming news sites, F# bloggers",Taking Don Syme out for a beer.,,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Financial services, Machine learning, Mainstream business & enterprise applications, Research/Teaching, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Commercial products, Open source projects","SQL databases, Event sourcing, Analytics",Visual Studio 2012 or newer,"Windows, Linux",Windows,"Javascript, LLVM","C, C++, Ocaml/SML, Mathematica",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Speed of development, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Quotations, Units of measure",Little information about F# for web development.,Nothing. Everyone loves it.,I'm willing to learn advanced concepts but only if they are relevant and practical,Being limited to .NET on Windows. F# on the Raspberry Pi compiles too slowly to be useful. I haven't figured out how to do web development using F#.,4 or more years,Thanks for running such an interesting survey!,Data or analytics related,,Not being part of the core .NET distribution,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems, Higher morale because coding is fun again.","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Interactive development, printf that is type checked, Type inference",A version of TryFSharp that works on most tablets.,,Broader coverage of applications like web programming. Industrial case studies.,"The questions imply that functional programming is a core part of F# and a panacea. The non-functional part of F# is substantial (e.g. mutable array literals) and just as important. For many practical problems, functional programming is not the best solution. Given the choice, I would choose union types and pattern matching over functional programming.
"
13/04/2015 16:28:33,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,"Switched company. Not really stopped, but reduced to internal tools (previously financial stuff)","F# Weekly, F# bloggers","MSDN, F# bloggers, Links mentioned in F# Weekly, Writing code + google.",,It's used unofficially,"Utilities and tools, Data analysis/statistics","Internal enterprise projects, Open source projects","SQL databases, Data integration and EAI",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),,"Back then, Linux experience was suboptimal.",Just started promoting it at my new workplace. Give it time.,I'm willing to learn advanced concepts but only if they are relevant and practical,"Many small paper-cuts, no glaring weakness, but a big hindrance for switching to F# now: Non-explicit interface implementation. I cannot break public API just for the heck of it!",2-3 years,Good idea. Already curious about what trends we'll see a few years down.,Enterprise development,,"Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Real payoff only starts at 100% F#.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, All of the above, if widening the scope of ""favorite"".","F# needs a book similar to Practical Common Lisp and Effective C++. Actually, those might already exist, but I haven't looked for years.","* Better static analysis tools; F#'s type system is not perfect.
* Fix Code Contract integration (again, maybe it's been done already, last time I checked it wasn't).",More material with in-depth tutorials,"Opinion-polls are fun, but don't help in any decision; move the from top to bottom (like ""most favorite feature"", listing stuff that already exists and bah.)

Distinguish between industry and domain; i.e. data analysis in automotive vs. financial. Different industries usually pool their developers from different backgrounds.

Would be interesting to see the relation between the top UserVoice F# language items and industry/experience/etc."
13/04/2015 16:29:10,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,I don't use F# at work,,Open source projects,"SQL databases, NoSQL database",Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux, iOS, Android, WinPhone, Azure",,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Object-oriented compatibility,Don't understand the compiler errors,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Enterprise development,,Working with C#-centric tooling,,"Agents (MailboxProcessor), Async workflows, Computation expressions, Immutability by default, No dependency cycles, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 16:35:04,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Other","Internal enterprise projects, Commercial products",Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,Native,"C#, C++, Java",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Computation expressions, Quotations, Type providers",Don't understand the compiler errors,No in-box VS/Blend tooling for WPF,I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,"sensors, manufacturing",,"Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Performance issues, Error messages from type inference issues can be confounding.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Units of measure",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material",
13/04/2015 16:38:31,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers, StackOverflow chat","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Structured training/workshops, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Financial services, Data analysis/statistics",Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, MATLAB",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Computation expressions, Object expressions, Quotations, Static type constraints, Units of measure","Not enough real-world code to learn from, Asp.net not officially supported","Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Financial services or similar,,Working with C#-centric tooling,"Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Async workflows, Easy integration with other .NET libraries, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 16:38:58,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"F# bloggers, Reddit","MSDN, F# books, F# bloggers, Reddit",,It's used unofficially,Utilities and tools,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, Azure",None -- I'm happy with the CLR/Mono,C#,,"Conciseness of code (I can see more at a glance), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Quotations, Units of measure",,"Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","More productive with fewer developers, Easier tinkering and sandboxing","Active Patterns, Easy integration with other .NET libraries, Immutability by default, Interactive development, Object expressions, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,Get the experts to host more internal training.,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 16:55:08,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,F# bloggers,"MSDN, Answers to Stack Overflow questions, Personal mentoring, Reading F# code written by experts",,I don't use F# at work,"None - Just playing around, Games, Mainstream business & enterprise applications",Internal enterprise projects,,Visual Studio 2012 or newer,Windows,Windows,Native,"C#, Haskell, Python, Racket",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Async workflows, Integration with non-F# libraries, Quotations",,,I like theory -- I'm not afraid of monads and other abstractions,,3-4 years,,Student,,Not being part of the core .NET distribution,,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, No dependency cycles, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, Type inference, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 17:06:19,1-2 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"HN, Reddit and other programming news sites","MSDN, Links and instructions from fsharp.org, F# books",,It's used unofficially,Utilities and tools,Internal enterprise projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,"JVM, Native","Java, Javascript, Scala",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor)","Lack of good tutorials/documentation, Not enough real-world code to learn from",Training: They are worried about getting non-F# developers up to speed,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,"Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Type inference, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 17:13:38,5-10 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"HN, Reddit and other programming news sites, F# bloggers, IRC","MSDN, Links and instructions from fsharp.org, F# bloggers, Answers to Stack Overflow questions, Personal mentoring, Reading F# code written by experts",,I don't use F# at work,"Utilities and tools, Algorithm-heavy business applications (non-financial), Games, Machine learning",Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,,"C#, Haskell, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Computation expressions, Integration with non-F# libraries, Quotations, Type providers, Units of measure",Not enough real-world code to learn from,,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.",,"Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 17:29:06,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"F# Weekly, F# bloggers, reddit","F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,Utilities and tools,Not applicable. None of my F# code is used by other people,"SQL databases, Event sourcing, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,"Windows, Linux",LLVM,"C, C#, C++, Java, Perl, Python",,"Conciseness of code (I can see more at a glance), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Interactive development, Quotations, Static type constraints, Type providers","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,Perception that it's a language for smart people only,1-2 years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",,"Easy integration with other .NET libraries, Immutability by default, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 17:32:34,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly",Reading F# code written by experts,,I don't use F# at work,Text analysis/language parsing,Open source projects,"SQL databases, Not doing data centric apps",Visual Studio 2012 or newer,Windows,"Windows, Mac, Linux","JVM, LLVM, Native","C#, C++, Erlang, Java",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Async workflows, Interactive development, Object-oriented compatibility, Quotations, Type providers",lack of partial,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, Too Windows-centric: They have concerns over cross-platform issues, No buy-in: There is lack of acceptance from other teams, embedded environment: gc is a nono. memory concerns.",I'm willing to learn advanced concepts but only if they are relevant and practical,lack of type classes. typechecker enforcing immutability,2-3 years,,Enterprise development,,"Performance issues, Cross-platform issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, The ""piping"" idiom, Type inference, Units of measure",,embedded edition. no gc or idiomatic f# doesnt allocate objects. aot jitting is good too.,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 17:41:06,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"F# Weekly, F# bloggers","F# bloggers, http://fsharpforfunandprofit.com",,It's used unofficially,"None - Just playing around, Utilities and tools",Not applicable. None of my F# code is used by other people,SQL databases,Xamarin,Mac,Mac,"JVM, Javascript, LLVM","C#, Javascript, Ruby",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,Not enough real-world code to learn from,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I want to learn functional programming but I don't like academic jargon,The size of the community,Less than two months,,Enterprise development,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Algebraic types (inc discriminated unions and tuples), Async workflows, Immutability by default, Interactive development, Type inference",Example large scale code,,"More material with in-depth tutorials, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 17:46:44,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, Google+, F# bloggers","F# books, F# bloggers",,It's officially endorsed for critical/production areas,Utilities and tools,"Internal enterprise projects, Commercial products, Open source projects",SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Agents (MailboxProcessor),"Lack of good tutorials/documentation, Installation process","Hiring: They worry about not being able to find F# developers, Fad: They have concerns over long term language viability",I like theory -- I'm not afraid of monads and other abstractions,,3-4 years,,Enterprise development,,Not being part of the core .NET distribution,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 17:51:36,10 or more years,"No, I don't know much theory",Just tinkering,,"HN, Reddit and other programming news sites, F# bloggers","F# books, F# bloggers, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,SQL databases,Sublime Text,"Windows, Mac","Windows, Mac",None -- I'm happy with the CLR/Mono,"C#, Javascript, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I like theory -- I'm not afraid of monads and other abstractions,"I don't know enough yet to answer this, but the 'fun' keyword is absolutely horrendous.",Haven't really used it yet,,Enterprise development,,"Not being part of the core .NET distribution, Less sophisticated tools for refactoring, etc.",,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Simple ""one liner"" type definitions for records and DUs, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
13/04/2015 17:56:50,10 or more years,"No, I don't know much theory",Just tinkering,,"HN, Reddit and other programming news sites, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,"None - Just playing around, Utilities and tools, Other",Not applicable. None of my F# code is used by other people,Event sourcing,Sublime Text,"Windows, Linux",Windows,"LLVM, Native","C#, Haskell, Javascript, Ocaml/SML, Python, Ruby, Rust",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,Installation process,"Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,Lack of open development tools in windows.,Less than a year,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling, Cross-platform issues",,"Algebraic types (inc discriminated unions and tuples), Immutability by default, No dependency cycles, printf that is type checked, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 18:18:58,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"F# Weekly, HN, Reddit and other programming news sites, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,I don't use F# at work,"None - Just playing around, Utilities and tools, Algorithm-heavy business applications (non-financial), Data analysis/statistics, Text analysis/language parsing",Not applicable. None of my F# code is used by other people,Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Clojure, Javascript, Ocaml/SML, Python, Typescript",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Great community, Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor), Object expressions, Quotations, Static type constraints, Type providers, Units of measure","Installation process, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,"not being ""officially"" endorsed by MS
it is very hard to ""sell"" F# to PMs, etc",2-3 years,,Enterprise development,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Backtick naming, Easy integration with other .NET libraries, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 18:19:29,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"F# Weekly, FPish.net","Links and instructions from fsharp.org, F# bloggers, Reading F# code written by experts",,It's used unofficially,,,,Visual Studio 2012 or newer,Windows,,None -- I'm happy with the CLR/Mono,"C#, Java",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Integration with non-F# libraries","Lack of good tutorials/documentation, Not enough real-world code to learn from",Poor support for Windows Phone/Windows 8 dev,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,"Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents","Easy integration with other .NET libraries, Immutability by default, Interactive development, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More podcasts and other audio-only material",
13/04/2015 18:21:05,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"F# Weekly, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly",,It's used unofficially,"Utilities and tools, Algorithm-heavy business applications (non-financial)",Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,"Windows, Mac",Windows,"JVM, LLVM","C#, C++, Ocaml/SML",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Object expressions, Object-oriented compatibility, Quotations, Static type constraints, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from",No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,"The lack of proper tooling on Mac.
Dealing with dynamic data, e.g. generating JSON is a hassle.",Less than two months,,Enterprise development,,"Lack of F# friendly libraries, Working with C#-centric tooling","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market","Algebraic types (inc discriminated unions and tuples), Immutability by default, Type inference",,Better/more libraries.,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 18:33:46,5-10 years,"No, I don't know much theory",Architecting/Developing a future enterprise application with F#,,Reddit,"MSDN, Links and instructions from fsharp.org, Answers to Stack Overflow questions, Reading F# code written by experts, fsharpforfunandprofit.com",,I don't use F# at work,"None - Just playing around, Utilities and tools, Mainstream business & enterprise applications","Internal enterprise projects, Commercial products",SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Java, Javascript, Visual Basic",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,"Lack of good tutorials/documentation, Not enough real-world code to learn from, learning curve. I have not worked with functional languages before","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I'm willing to learn advanced concepts but only if they are relevant and practical,"market market market

Traditionally higher education teaches functional programming. And traditionally corporations use object-oriented applications.

F# provides a way to merge these concepts together in a meaningful way, lowering the barrier of entry to the ""real world"" for graduates, and providing a tool for business that makes workflow a bit more robust.",Less than two months,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Cross-platform issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Backtick naming, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference, Type providers, Units of measure",,"Until it gains more real-world acceptance, there won't really be a place for it.","More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 18:35:14,2-5 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,Twitter,"MSDN, Links and instructions from fsharp.org, F# bloggers",,It's used unofficially,Utilities and tools,Not applicable. None of my F# code is used by other people,,Visual Studio 2012 or newer,Windows,,"JVM, Javascript, Native",C++,,"Conciseness of code (I can see more at a glance), Having fun again","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Agents (MailboxProcessor), Async workflows, Type providers, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,Difficulty in troubleshooting problems,More productive with fewer developers,"Easy integration with other .NET libraries, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 18:43:21,5-10 years,"No, I don't know much theory",Just tinkering,,"Twitter, F# Weekly, HN, Reddit and other programming news sites","MSDN, F# books, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,I don't use F# at work,,Not applicable. None of my F# code is used by other people,,Visual Studio 2012 or newer,"Windows, Linux",,JVM,"C#, C++, Java",,"Correctness (no nulls, it works first time), Great community, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,,,I like theory -- I'm not afraid of monads and other abstractions,,3-4 years,,Enterprise development,,,,,,,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 18:51:08,2-5 years,"No, I don't know much theory",Just tinkering,,F# bloggers,"MSDN, Links and instructions from fsharp.org, F# books, F# bloggers",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,JVM,"C#, Javascript",,"Great community, Learning functional programming in general",Beginner (For example: you know OO well and functional programming seems strange),"Async workflows, Type providers, Units of measure","Lack of good tutorials/documentation, I can't use my knowledge from C# or other imperative languages","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft",I want to learn functional programming but I don't like academic jargon,,Less than two months,,Student,,Cross-platform issues,Domain modelling: making illegal states unrepresentable,"Immutability by default, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference",,,More interactive tutorials (e.g. like the F# Koans),
13/04/2015 18:51:40,5-10 years,"No, I don't know much theory",I use it for hobby or side projects,,"HN, Reddit and other programming news sites","Links and instructions from fsharp.org, Answers to Stack Overflow questions",,I don't use F# at work,"Utilities and tools, Other",Open source projects,Not doing data centric apps,MonoDevelop,Linux,"Windows, Mac, Linux",LLVM,"C#, D",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Interactive development, Object-oriented compatibility","Lack of good tutorials/documentation, Don't understand the compiler errors",,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Student,,"Lack of F# friendly libraries, Difficulty in troubleshooting problems",,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, No dependency cycles, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,More material with real-world examples and war stories,
13/04/2015 18:54:07,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,,,,Visual Studio 2012 or newer,Windows,,None -- I'm happy with the CLR/Mono,"C#, C/AL (Dynamics NAV)",,Learning functional programming in general,Beginner (For example: you know OO well and functional programming seems strange),"Agents (MailboxProcessor), Async workflows, Object-oriented compatibility, Quotations",Don't understand the compiler errors,Training: They are worried about getting non-F# developers up to speed,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Active Patterns, Algebraic types (inc discriminated unions and tuples), Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 18:55:24,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,Twitter,Personal experimentation,,It's officially endorsed for critical/production areas,"Utilities and tools, Financial services",Internal enterprise projects,Not doing data centric apps,Visual Studio 2010 or older,Windows,Windows,"None -- I'm happy with the CLR/Mono, JVM","C#, C++, Haskell",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Speed of development, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),Quotations,,"Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,Lack of higher-kinded types,4 or more years,,Financial services or similar,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Async workflows, Object-oriented features (inc. C# compatibility, conciseness)",,,,
13/04/2015 19:00:25,2-5 years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Custom development/specialist markets, Mainstream business & enterprise applications, Data analysis/statistics","Internal enterprise projects, Commercial products",SQL databases,Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Async workflows, Computation expressions, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from",Training: They are worried about getting non-F# developers up to speed,I want to learn functional programming but I don't like academic jargon,,1-2 years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 19:09:10,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,"Windows, Azure",None -- I'm happy with the CLR/Mono,"C#, Javascript, Typescript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Quotations, Units of measure",Don't understand the compiler errors,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,Working with C#-centric tooling,,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Backtick naming, Computation expressions, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference, Type providers",,,More material with in-depth tutorials,
13/04/2015 19:23:39,2-5 years,"No, I don't know much theory",I use it at work or for other commercial uses,,,"Links and instructions from fsharp.org, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly",,It's used unofficially,"Utilities and tools, Algorithm-heavy business applications (non-financial)",Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,Windows,Windows,,"Javascript, Visual Basic",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Object-oriented compatibility,Don't understand the compiler errors,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market","Active Patterns, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 19:36:19,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"F# Weekly, HN, Reddit and other programming news sites","MSDN, Links and instructions from fsharp.org, Personal mentoring, Videos (e.g. Community for F#)",,I don't use F# at work,Other,"Internal enterprise projects, Commercial products, Open source projects","SQL databases, Data integration and EAI, Not doing data centric apps",Visual Studio 2012 or newer,"Windows, Mac, Linux","Windows, Mac, Linux","Javascript, Better Linux/OSX/mobile support","C, C#, C++, Haskell, Java, Javascript, Ocaml/SML, Python, Rust",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Good documentation = good learning experience",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Object-oriented compatibility, Quotations, Static type constraints, Type providers","Not enough real-world code to learn from, FOSS code is often subpar/directly translated from C#","Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,"The cross-platform story is problematic. Xamarin is complicated and expensive to license, and given the fragmentation of build systems between VS and Mono etc., you need an expert build to share code between .NET and Mono.",4 or more years,,Student,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Cross-platform issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Easy concurrency with async and agents, Better for solving complex problems, Easy to refactor/rewrite","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, Object expressions, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",Having a repository of class material for university courses.,"I work at Microsoft on OSG. No one knows F#, so writing code in F# means that if the maintainer leaves it's dead.","More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)","Some of the questions assume a dichotomy between ""currently working in F#"" and ""never worked in F#"". I've worked in F# before but don't anymore, even though I'd love to."
13/04/2015 20:06:15,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, HN, Reddit and other programming news sites","F# books, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Machine learning, Data analysis/statistics",Not applicable. None of my F# code is used by other people,Analytics,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Scheme/CL",,"Conciseness of code (I can see more at a glance), Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Async workflows, Computation expressions, Quotations, Units of measure",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Fad: They have concerns over long term language viability",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Data or analytics related,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.",More productive with fewer developers,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 20:33:00,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,,"MSDN, F# books, F# bloggers, Answers to Stack Overflow questions",,I don't use F# at work,"None - Just playing around, Text analysis/language parsing",Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,,"C#, C++",,"Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Computation expressions, Object expressions, Type providers","Don't understand the compiler errors, I think a tutorial should cover compiler errors. I'm starting to learn how some errors mean I'm missing an argument to a function, where others (in VS's squiggles) are just it being too fast and warning me about something that I'm in the middle of doing anyway.",No buy-in: There is lack of acceptance from other teams,I'm willing to learn advanced concepts but only if they are relevant and practical,"I chose it because I have VS installed. I don't know why I would use it over Haskell or Clojure if going to do some real project. So, I suppose other than CLR integration, I don't know any reason to choose F#. My limited understanding so far has it the same as any other functional language.",Less than two months,,Enterprise development,,,,"Easy integration with other .NET libraries, Immutability by default, Interactive development, The ""piping"" idiom, Type inference","Have a problem with multiple solutions, where they advance in terms of tools or idoms being employed. Link to descriptions of the techniques added in the solution. Maybe the same problem could be worked a couple times as more concepts are added to it? I'm trying problems from Rosalind.info. It would be interesting to compare what might be considered an answer using best practices.",,,
13/04/2015 20:36:51,5-10 years,"No, I don't know much theory",I use it for hobby or side projects,,"HN, Reddit and other programming news sites","Links and instructions from fsharp.org, Links posted on social media such as Twitter, Answers to Stack Overflow questions, Reading F# code written by experts",,It's used unofficially,Utilities and tools,Not applicable. None of my F# code is used by other people,Not doing data centric apps,MonoDevelop,"Windows, Linux","Windows, Linux",None -- I'm happy with the CLR/Mono,"Java, Javascript",,"Conciseness of code (I can see more at a glance), Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,"Lack of good tutorials/documentation, Not enough real-world code to learn from",No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Enterprise development,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries",Better for solving complex problems,"Easy integration with other .NET libraries, No dependency cycles, The ""piping"" idiom, Type inference",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos",
13/04/2015 20:49:19,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,I've been too busy with projects in other languages. My last real opportunity was when writing tooling at a previous job.,,"F# books, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Vim,Mac,,"JVM, LLVM","C#, Clojure, Haskell, Scala",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Interactive development, Type providers",,Going out of business. Stack is in Scala.,I like theory -- I'm not afraid of monads and other abstractions,,I was using F# but have stopped,,Technical Founder,,,,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 20:52:36,2-5 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"HN, Reddit and other programming news sites","MSDN, Links and instructions from fsharp.org, F# bloggers",,I don't use F# at work,"Financial services, Machine learning, Mainstream business & enterprise applications","Internal enterprise projects, Commercial products, Open source projects","Analytics, Data integration and EAI",Visual Studio 2012 or newer,"Windows, Mac","Windows, Mac",JVM,"C#, C++, Java, Swift, Typescript",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,Not enough real-world code to learn from,"Hiring: They worry about not being able to find F# developers, Too Microsoft-centric: They think it is too closely linked to Microsoft",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Enterprise development,,Cross-platform issues,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents",,,,"More material with short ""cookbook"" style information, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 20:56:11,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","MSDN, F# books, Already knew Caml and OCaml",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,"Native, Dalvik/ART","C#, C++, Java, Javascript",,Learning functional programming in general,Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Units of measure,Tooling,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,"Microsoft doesn't provide a clear message about the language.

In some presentations the value of the language is endorsed, but when it comes to tooling, or mentioning which languages are supported across the whole Windows eco-system, F# is always left out.

A recent is the frontage about Windows 10 for developers, not a single word about F#.",,,Enterprise development,,"Not being part of the core .NET distribution, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., No clear message from Microsoft about the language",,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Object-oriented features (inc. C# compatibility, conciseness), ML language family",,"I don't think much is possible without Microsoft changing their overall message.

The type of corporations I work for, care about commodity developers and have big scale offshoring projects.

Personally I doubt they would see any value in languages like F#, unless they are forced to use them.",More material with real-world examples and war stories,
13/04/2015 21:08:28,2-5 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,,"MSDN, F# bloggers",,I don't use F# at work,None - Just playing around,,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,"Windows, Linux",None -- I'm happy with the CLR/Mono,Java,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Quotations, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from",,I like theory -- I'm not afraid of monads and other abstractions,"Template engine in f# doesn't exist. 
Razor and aspx are not compatible with it.",Less than two months,"I learned OCaml when I was student at University and I loved it.
I live in France and there is no jobs in F#. 
There is a good Scala community in France, but nothing in F# and it's very frustrating because F# syntax is more concise than Scala.
 ",Enterprise development,,Lack of good wrappers for non-F# libraries,,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Type inference",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 21:31:45,5-10 years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# bloggers","MSDN, F# books, Links posted on social media such as Twitter, Personal mentoring, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Text analysis/language parsing","Internal enterprise projects, Not applicable. None of my F# code is used by other people",,Visual Studio 2012 or newer,Windows,Windows,,C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Async workflows, Integration with non-F# libraries, Object expressions, Type providers","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Money: They worry that good F# developers will cost too much, No buy-in: There is lack of acceptance from other teams, Nothing. Everyone loves it.",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Enterprise development,,,"Correctness: fewer bugs and less rework, Faster time to market, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 21:39:17,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,F# bloggers,"Links and instructions from fsharp.org, F# books, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,Native,C#,,Learning functional programming in general,Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Computation expressions, Quotations, Type providers, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,It is treated by Microsoft as a second-class language (despite them calling it a first-class language).,Haven't really used it yet,,Enterprise development,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Working with C#-centric tooling",,"Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Immutability by default, Type inference, Type providers, Units of measure",,"Better F# integration with other .NET languages, particularly XAML.  I would also love to use F# from the same project, potentially the same source file, as C# code.","More short ""live coding"" videos",
13/04/2015 21:39:49,5-10 years,"No, I don't know much theory",Just tinkering,,"HN, Reddit and other programming news sites","F# books, F# bloggers, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,"Windows, Mac","Windows, Mac",,Java,,Learning functional programming in general,Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,,,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Architect (buildings not software),,,,"Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, Interactive development, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 21:56:08,5-10 years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly, HN, Reddit and other programming news sites","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly",,It's used unofficially,"Utilities and tools, Mobile apps, Text analysis/language parsing",Not applicable. None of my F# code is used by other people,,Xamarin,"Windows, Mac","Windows, Mac, iOS, Android",Javascript,"C, C#, Elixir, Javascript, Ruby",,"Better domain modelling with records and unions, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Computation expressions, Object expressions, Object-oriented compatibility, Quotations, Type providers, Units of measure","Lack of good tutorials/documentation, Don't understand the compiler errors, Not enough real-world code to learn from",It's not always agreed upon what is idiomatic F# so we're afraid we'd dump a lot of time/money into writing bad code,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Enterprise development,,Difficulty in troubleshooting problems,"Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), The ""piping"" idiom","There are still some features that I haven't found much information on, possibly because it seems like they're not ""daily use"" kind of features.

For example, I see people mention ""functional reactive"" stuff in passing here and there but I don't have a good sense of what it is or how to use it in F# yet. Type providers are another thing that seem to be more advanced, so it seems like only a few people really use them much, and there's not a lot of useful information about them that I can find (like, what can I do with them, what are some situations where I might make use of them, how do I create them?)",,"More material with in-depth tutorials, More material with short ""cookbook"" style information",
13/04/2015 22:09:12,2-5 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,,,,I don't use F# at work,"None - Just playing around, Text analysis/language parsing",Not applicable. None of my F# code is used by other people,,Visual Studio 2012 or newer,Windows,Windows,,"C#, Java, PHP",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,Not enough real-world code to learn from,,I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Student,,Difficulty in troubleshooting problems,"Correctness: fewer bugs and less rework, Efficiency/Performance, Easy concurrency with async and agents","Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Type providers",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 22:20:30,10 or more years,"No, I don't know much theory",Learning,,"Twitter, F# Weekly","F# books, Links mentioned in F# Weekly, Reading F# code written by experts, Conversion of akka-bootcamp lessons to F#",,It's used unofficially,"None - Just playing around, Utilities and tools","Not applicable. None of my F# code is used by other people, Utility apps",SQL databases,Visual Studio 2012 or newer,Windows,,,"C#, Javascript",,"Conciseness of code (I can see more at a glance), Having fun again, Learning functional programming in general, Changed my javascript coding which is now more functional","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,Lack of time on my part,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I want to learn functional programming but I don't like academic jargon,,Less than a year,,Enterprise development,,,,"Algebraic types (inc discriminated unions and tuples), Immutability by default, The ""piping"" idiom, Units of measure",,,"More material with real-world examples and war stories, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 22:31:41,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# bloggers, Answers to Stack Overflow questions, fsharpforfunandprofit.com",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications",Internal enterprise projects,"SQL databases, NoSQL database, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Java, Javascript, Objective-C, G, M",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows, Interactive development, Object-oriented compatibility, Quotations",Installation process,"Hiring: They worry about not being able to find F# developers, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams, Not enough support in tooling (the templates suck!)",I like theory -- I'm not afraid of monads and other abstractions,"It's obviously better that C#, but still treated as a poor cousin by Microsoft.

If it's better shouldn't it be the default?",2-3 years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, readability, therefore maintainability","Active Patterns, Easy integration with other .NET libraries, Immutability by default, Object expressions, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Units of measure","Less videos talking ""at"" me, and more interactive (or narrative) tutorials working ""with"" me.","Nuget packages that don't corrupt the one-pass ordering of the project's files.
Razor and controller right-click creation templates that actually work.
Proper refactoring support (even in Resharper?)","More material with in-depth tutorials, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 22:39:16,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"F# Weekly, Google+, Google groups, HN, Reddit and other programming news sites, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Custom development/specialist markets, Mainstream business & enterprise applications",Commercial products,,Visual Studio 2012 or newer,Windows,Windows,"JVM, Javascript, LLVM, Native",C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Async workflows, Interactive development, Object expressions, Units of measure",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, No dependency cycles, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 22:41:26,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, HN, Reddit and other programming news sites","F# books, F# bloggers, Links mentioned in F# Weekly, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Data analysis/statistics",,"SQL databases, NoSQL database, Read-only data sources such as feeds",Xamarin,"Windows, Mac",,"Javascript, Native","C#, Javascript, Typescript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,Not enough real-world code to learn from,,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,"Less sophisticated tools for refactoring, etc.",,"Easy integration with other .NET libraries, Interactive development, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
13/04/2015 23:08:29,1-2 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,,F# books,,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,None -- I'm happy with the CLR/Mono,"C, C#, C++, Haskell, Java",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Async workflows, Computation expressions, Quotations, Type providers","Lack of good tutorials/documentation, Not enough real-world code to learn from, not enough intellisense as in c#","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,"lack of perfect intellisense. not enough libraries. add some more immutable data structures.
not enough publicity.",Less than a year,f# is great!,Student,,"Not being part of the core .NET distribution, not enough intellisense as in c#",,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Immutability by default, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, The ""piping"" idiom, Type inference, Units of measure","Publish a whole book which will cover the uncovered areas better. ive read some f# books, and if i didnt know haskell before, i wouldnt understand any fp concept their. in haskell, it took me some time to grasp ideas like folds, lazy evaluation, monads, and f# books arent thourogh enouph. im sure its quite common that most people who start reading those books stop in the middle.",,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",its too long
13/04/2015 23:18:12,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","F# bloggers, Links mentioned in F# Weekly, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Algorithm-heavy business applications (non-financial), Machine learning, Data analysis/statistics",Internal enterprise projects,"SQL databases, NoSQL database, Event sourcing, Analytics",Visual Studio 2012 or newer,Windows,"Windows, Linux","JVM, LLVM",C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Units of measure,"Lack of good tutorials/documentation, Don't understand the compiler errors","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,Data or analytics related,,"Lack of F# friendly libraries, Working with C#-centric tooling","More productive with fewer developers, Faster time to market, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Computation expressions, Quotations, Type inference",,"Highlight large successful projects using F#.  
Show there is demand for F# dev in other companies ","More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
13/04/2015 23:32:30,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly","F# books, F# bloggers, Links mentioned in F# Weekly, Experiments",,It's officially endorsed for critical/production areas,"Utilities and tools, Financial services, Mainstream business & enterprise applications","Internal enterprise projects, Open source projects","SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Interactive development, Static type constraints",Don't understand the compiler errors,Nothing. Most people love it.,I like theory -- I'm not afraid of monads and other abstractions,,3-4 years,,Financial services or similar,,Performance issues,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents, Better for solving complex problems, Engaging developers","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Type inference",,,,
13/04/2015 23:37:21,5-10 years,"No, I don't know much theory",Just tinkering,,F# bloggers,"MSDN, Links and instructions from fsharp.org, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,None -- I'm happy with the CLR/Mono,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Beginner (For example: you know OO well and functional programming seems strange),"Active Patterns, Agents (MailboxProcessor), Async workflows, Computation expressions, Quotations, Type providers, Units of measure",Don't understand the compiler errors,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I want to learn functional programming but I don't like academic jargon,Project templates and lack of built-in Nuget F# Interactive support make it difficult for me to transition from C#.,Less than two months,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, The ""piping"" idiom, Type inference",,More templates for common projects. Our department is MVC web site oriented and lack of easily created site was big turn off. I watched a video from Mark Seeman on Pluralsight and it seemed like a hassle for each team to do. ,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 00:06:42,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# bloggers","MSDN, F# books, F# bloggers, Links posted on social media such as Twitter",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Custom development/specialist markets, Mainstream business & enterprise applications, Data analysis/statistics","Internal enterprise projects, Commercial products, Open source projects","SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C, C#, Java, Javascript, Objective-C, PHP, Visual Basic",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Async workflows, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from","Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I want to learn functional programming but I don't like academic jargon,,2-3 years,F# for fun and profit is my favorite site. Hoorah!,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Active Patterns, Agents (MailboxProcessor), Easy integration with other .NET libraries, Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 00:07:31,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,F# Weekly,"MSDN, F# books, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,Custom development/specialist markets,Commercial products,Read-only data sources such as feeds,Visual Studio 2012 or newer,"Windows, Mac, Linux",Windows,"Javascript, LLVM, Native","C++, Javascript, Perl",,"Correctness (no nulls, it works first time)",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Object expressions, Quotations, Type providers, Units of measure",Not enough real-world code to learn from,CentOS 5 compatibility,I'm willing to learn advanced concepts but only if they are relevant and practical,"I think the need for Mono on non-Windows platforms pushes a lot of people to Haskell and OCaml, purely because they compile to native code.

I realize that getting F# to the same point would require some amount of .NET independence, but even if early versions of a native-code F# compiler could only use C-based libraries via some kind of FFI, that would still be useful.",1-2 years,,vertical market software,,"Working with C#-centric tooling, Cross-platform issues, SharpDevelop and Xamarin treat F# as a third-class citizen; I use Visual Studio since F# is only a *second*-class citizen there","Correctness: fewer bugs and less rework, .NET compatibility without having to use C# or VB.net :)","Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference",,"Build current Mono and F# RPMs for older OSes, too.

The instructions [here](http://goo.gl/tf6xjy) don't say which version of CentOS it works with, but my attempts tell me that it doesn't work with anything but the CentOS 7, the latest version of the OS. This means that until our production CentOS 5 & 6 boxes all fall over, many years from now, we can't ship anything mission-critical built with F# unless we're willing to package and install Mono and F# for it ourselves.

Occasionally you can find third-party RPM sources, but they're often untrustworthy or unstable.

So far, it's actually been easiest to just build from source, but that's only suitable on internal development machines.  It isn't something we can do on hundreds of remote production systems.",More material with real-world examples and war stories,"All of the answers to the second question seem focused on internal-use applications. None of the answers are really good for software developed by organization A for use by organization B.  (Commercial software, consulting, open source, etc.)"
14/04/2015 00:13:05,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"HN, Reddit and other programming news sites, F# bloggers","MSDN, F# books, Answers to Stack Overflow questions, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Algorithm-heavy business applications (non-financial), Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Open source projects","SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, C++, Javascript, Python",,"Conciseness of code (I can see more at a glance), Having fun again",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Object expressions, Object-oriented compatibility, Quotations, Type providers, Units of measure",I can't use my knowledge from C# or other imperative languages,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,"Intergration with visual studio, C# is vastly better.",4 or more years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","More productive with fewer developers, Efficiency/Performance, Better for solving complex problems","Easy integration with other .NET libraries, Immutability by default, No dependency cycles, The ""piping"" idiom, Type inference",,,More podcasts and other audio-only material,
14/04/2015 00:13:13,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, Facebook, F# bloggers","F# books, F# bloggers, Links posted on social media such as Twitter, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Custom development/specialist markets, Mainstream business & enterprise applications, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Commercial products",SQL databases,Visual Studio 2012 or newer,Windows,Windows,Javascript,C#,,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Learning functional programming in general, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Object expressions",,Hiring: They worry about not being able to find F# developers,I like theory -- I'm not afraid of monads and other abstractions,The fact that many syntactic elements or their context are hidden. Especially with regard to Active Patterns & 'Function' Lambdas.,4 or more years,,Enterprise development,,Difficulty in troubleshooting problems,"Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Interactive development, The ""piping"" idiom, Type inference, Type providers, Units of measure","Articles like Tomas Petricek's ""F# walkthrough: looking under the covers.",Convince Microsoft to use F# in their products and boast about that fact.,"More material with in-depth tutorials, More material with real-world examples and war stories",
14/04/2015 00:13:58,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# bloggers, StackOverflow chat","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Personal mentoring, Reading F# code written by experts",,It's used unofficially,Financial services,Internal enterprise projects,"SQL databases, NoSQL database, Event sourcing, Analytics",Sublime Text,"Windows, Mac","Windows, Mac, Azure, Amazon Web services",LLVM,"C#, C++, Haskell, R, Scala, Typescript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Quotations, Static type constraints",Steep learning curve,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,"Actually I think the greatest weakness is also the greatest advantage: F# requires you to think harder about what and how you write code.
So for someone trying to learn the language is more intimidating than an imperative language.",2-3 years,No,Enterprise development,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More interactive tutorials (e.g. like the F# Koans)",Looks good to me
14/04/2015 00:17:17,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,Twitter,"Links and instructions from fsharp.org, F# books",,I don't use F# at work,Data analysis/statistics,Open source projects,Read-only data sources such as feeds,Xamarin,"Windows, Mac","Windows, Mac","Javascript, Native","C#, Clojure, Javascript, Python, Visual Basic",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Computation expressions, Object expressions, Quotations, Type providers, Units of measure",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,2-3 years,,Enterprise development,,"Working with C#-centric tooling, Cross-platform issues",,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom",,,"More material with real-world examples and war stories, More short ""live coding"" videos",
14/04/2015 00:20:11,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","MSDN, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Reading F# code written by experts, fsharpforfunandprofit",,It's used unofficially,"Utilities and tools, Custom development/specialist markets","Internal enterprise projects, Tests","SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,"Windows, Azure",,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Units of measure,Lack of good tutorials/documentation,Others not aware of F# strengths,I like theory -- I'm not afraid of monads and other abstractions,Just needs to further grow in follower size.,Less than a year,,Enterprise development,,"No ""go to definition"" interop with C#","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance","Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, No dependency cycles, The ""piping"" idiom, Type inference",,"Keep up the good work, people will come around when the critical massing occurs and they finally look closely at it.","More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 00:28:06,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,Twitter,"MSDN, F# books, F# bloggers, fsharpforfunandprofit.com",,It's used unofficially,Data analysis/statistics,Not applicable. None of my F# code is used by other people,"SQL databases, NoSQL database, Event sourcing",Visual Studio 2012 or newer,Windows,,Native,"C#, C++, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Interactive development, Object expressions, Object-oriented compatibility, Quotations, Static type constraints",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Easy concurrency with async and agents, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type providers, Units of measure",,,More material with real-world examples and war stories,
14/04/2015 00:45:20,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly","F# books, Links posted on social media such as Twitter, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,It's officially endorsed for non-critical/non-production code,"Algorithm-heavy business applications (non-financial), Financial services",Internal enterprise projects,SQL databases,Visual Studio 2010 or older,Windows,Windows,JVM,"C#, Javascript",,Conciseness of code (I can see more at a glance),"Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",Agents (MailboxProcessor),Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,More mainstream marketing,4 or more years,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Backtick naming, Easy integration with other .NET libraries, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference, Units of measure",,More business case studies,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 00:59:00,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,Now using.,"Twitter, F# Weekly, GitHub search","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers",,It's officially endorsed for critical/production areas,"Utilities and tools, Machine learning, Data analysis/statistics","Internal enterprise projects, Commercial products, Open source projects","SQL databases, Read-only data sources such as feeds, Analytics",Visual Studio 2012 or newer,Windows,"Windows, Amazon Web services",JVM,"C#, Java, Javascript, R",,Conciseness of code (I can see more at a glance),Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Quotations, Units of measure",Installation process,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,3-4 years,,Enterprise development,,Slow compilation,"Correctness: fewer bugs and less rework, More productive with fewer developers, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Easy integration with other .NET libraries, printf that is type checked, The ""piping"" idiom, Type inference, Type providers",,Let people including non-developers find out about the F# language.,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 01:28:46,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"F# Weekly, HN, Reddit and other programming news sites, F# bloggers","Links mentioned in F# Weekly, Reading F# code written by experts",,I don't use F# at work,"Algorithm-heavy business applications (non-financial), Data analysis/statistics, Text analysis/language parsing",Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux",Native,"C#, C++, Java, Javascript, Python",,"Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Quotations, Type providers","Lack of good tutorials/documentation, Not enough real-world code to learn from",No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Data or analytics related,,,,"Algebraic types (inc discriminated unions and tuples), Backtick naming, Easy integration with other .NET libraries, Immutability by default, Interactive development, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
14/04/2015 01:53:23,2-5 years,"No, I don't know much theory",I use it for hobby or side projects,,"F# Weekly, HN, Reddit and other programming news sites, F# bloggers","F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Reading F# code written by experts",,It's used unofficially,Machine learning,Not applicable. None of my F# code is used by other people,"SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,,None -- I'm happy with the CLR/Mono,C#,,"Correctness (no nulls, it works first time), Learning functional programming in general, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Object expressions, Quotations, Units of measure",Not enough real-world code to learn from,"Training: They are worried about getting non-F# developers up to speed, Too esoteric",I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,"Not being part of the core .NET distribution, Less sophisticated tools for refactoring, etc.",Scripting common tasks,"Algebraic types (inc discriminated unions and tuples), The ""piping"" idiom",,"Continue developing the tools that make it easy to use (FSharp power tools is great, etc)","More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 01:57:41,10 or more years,"No, I don't know much theory",Just tinkering,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,"Windows, Mac",,None -- I'm happy with the CLR/Mono,"C#, Java, R",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows, Computation expressions, Object-oriented compatibility, Quotations, Static type constraints",,,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,"Working with C#-centric tooling, Cross-platform issues",,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More podcasts and other audio-only material",
14/04/2015 01:58:40,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,Financial services,Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Java, Javascript, Scala",,"Conciseness of code (I can see more at a glance), Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Agents (MailboxProcessor), Computation expressions, Interactive development","I can't use my knowledge from C# or other imperative languages, Not enough real-world code to learn from",No buy-in: There is lack of acceptance from other teams,I like theory -- I'm not afraid of monads and other abstractions,"1. No widespread word for real-world usage scenarios.

2 . F# Power Tools are not on par with modern IDE's features like R# for VS and intelliJ for Java/Scala.

3. Not enough presence on dev conferences? I missed Compose this year (where F# was well introduced), but going to LambdaConf, and here just a couple of talks are F#-related.",Less than two months,,Financial services or similar,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",Better for solving complex problems,"Algebraic types (inc discriminated unions and tuples), Async workflows, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More podcasts and other audio-only material",
14/04/2015 02:57:03,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Machine learning, Research/Teaching, Data analysis/statistics","Internal enterprise projects, Open source projects","SQL databases, NoSQL database",Visual Studio 2012 or newer,"Windows, Mac, Linux","Windows, Mac, Linux, Azure","LLVM, Native","C, C++, Haskell, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Active Patterns, Agents (MailboxProcessor), Object-oriented compatibility, Quotations, Type providers",Lack of good tutorials/documentation,Nothing. Everyone loves it.,I'm willing to learn advanced concepts but only if they are relevant and practical,,3-4 years,,Data or analytics related,,Cross-platform issues,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, printf that is type checked, The ""piping"" idiom, Type inference, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information",
14/04/2015 03:49:36,2-5 years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","F# books, F# bloggers, Videos (e.g. Community for F#), Reading F# code written by experts, Pluralsight, fsharpforfunandprofit",,It's used unofficially,"Financial services, Mainstream business & enterprise applications, Data analysis/statistics","Internal enterprise projects, ETL stuff, business rules","SQL databases, Data integration and EAI",Visual Studio 2012 or newer,Windows,Windows,"None -- I'm happy with the CLR/Mono, Javascript",C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Learning functional programming in general, Easy to reason about the big picture once the core concepts are grasped ","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",Units of measure,I can't use my knowledge from C# or other imperative languages,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, Interns/college grades do not see the benefits ",I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,"Love the work you guys are doing. 
Keep it up.",Small Business Software Dev,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems, Getting used to the Compiler being so strict","Domain modelling: making illegal states unrepresentable, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Backtick naming, Computation expressions, Immutability by default, The ""piping"" idiom, Type providers, Compiler forces you to be correct mostly","I think there should be two paths mainly for F#.

1. How to use F# (functional concepts), but not really understand them ""Chessie"" is a good example of this.

2. a more concrete example of high level concepts like monads,partial application to help understand the theory and start to actually build/write these types of datasets.

for #2 it would be really nice to see how to build an entire system in F#. Many have done a good job with this, but i think there is more to be desired. for example it would be nice to see an entire web stack done in F#/functional style to better illustrate using partial application and other concepts. Add5  gets old real quick.","i think we should try target the younger generation of programmers and get them excited about functional programming in general.

Better Tooling. I think things like FAKE are what will bring F# to the masses. ","More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans), More High level theory with code",
14/04/2015 03:57:36,5-10 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,Twitter,"F# books, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Text analysis/language parsing","Internal enterprise projects, Commercial products","SQL databases, Event sourcing, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,"JVM, LLVM, Native","C#, Javascript, Rust",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Speed of development, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Object-oriented compatibility, Quotations, Units of measure",Installation process,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Too Windows-centric: They have concerns over cross-platform issues",I like theory -- I'm not afraid of monads and other abstractions,"Linux support is very spotty. Only certain versions of mono seem to work well and newer versions of monodevelop only work on some of those versions. I've only managed to get mono, monodevelop, f#, and the editor plugin all working together once out of many attempts. ",3-4 years,,Enterprise development,,Cross-platform issues,"Correctness: fewer bugs and less rework, More productive with fewer developers, Efficiency/Performance, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, No dependency cycles, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,More material with in-depth tutorials,
14/04/2015 04:26:55,10 or more years,"No, I don't know much theory",I use it for research or academic work,,F# Weekly,"Links and instructions from fsharp.org, F# for fun and profit",,I don't use F# at work,"Machine learning, Data analysis/statistics",Not applicable. None of my F# code is used by other people,Analytics,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, C++",,"Great community, Having fun again, Learning functional programming in general, Speed of development","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Units of measure",Don't understand the compiler errors,,I'm willing to learn advanced concepts but only if they are relevant and practical,I think the interactive scripting features can be improved. I would love to see something similar to IPython notebook in F# world.,Less than two months,,Enterprise development,,"Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",,"Async workflows, Backtick naming, Computation expressions, Easy integration with other .NET libraries, Interactive development, Quotations, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 04:35:11,5-10 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,F# Weekly,"F# books, F# bloggers, Reading F# code written by experts",,It's officially endorsed for critical/production areas,Mainstream business & enterprise applications,Commercial products,SQL databases,Visual Studio 2012 or newer,Windows,"Windows, Mac, Azure","LLVM, Native",,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Interactive development, Static type constraints, Units of measure",,Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,Enterprise development,,Not being part of the core .NET distribution,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, The ""piping"" idiom",,,More material with in-depth tutorials,
14/04/2015 05:25:22,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","F# books, F# bloggers, Links mentioned in F# Weekly, Videos (e.g. Community for F#), Reading F# code written by experts",,I don't use F# at work,"Financial services, Mobile apps, Data analysis/statistics",Not applicable. None of my F# code is used by other people,"NoSQL database, Read-only data sources such as feeds",Visual Studio 2012 or newer,"Windows, Mac, Linux","Mac, iOS, Amazon Web services","JVM, Javascript","C#, Ruby",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Beginner (For example: you know OO well and functional programming seems strange),Object-oriented compatibility,Not enough real-world code to learn from,Training: They are worried about getting non-F# developers up to speed,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Financial services or similar,,Cross-platform issues,,"Agents (MailboxProcessor), The ""piping"" idiom, Type providers",,make it easier to write RESTful web services.,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 05:25:33,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","MSDN, F# books, F# bloggers",,I don't use F# at work,Utilities and tools,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Xamarin,Mac,Mac,"None -- I'm happy with the CLR/Mono, LLVM, Native","C, C#, C++, Java, Python, Ruby",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Object expressions, Object-oriented compatibility, Quotations",,No buy-in: There is lack of acceptance from other teams,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,back office,,"Not being part of the core .NET distribution, Less sophisticated tools for refactoring, etc.",,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 06:05:21,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,F# bloggers,"MSDN, Links and instructions from fsharp.org, F# books, Videos (e.g. Community for F#)",,It's officially endorsed for critical/production areas,Custom development/specialist markets,Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,"Windows, Linux","JVM, Native","C#, C++",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time)","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",Integration with non-F# libraries,Not enough real-world code to learn from,Training: They are worried about getting non-F# developers up to speed,I like theory -- I'm not afraid of monads and other abstractions,,Less than two months,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, More productive with fewer developers, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems",Immutability by default,"provide it with subtitle in videos, please","more books, videos and samples","More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos",
14/04/2015 06:06:39,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers",,It's officially endorsed for non-critical/non-production code,Mainstream business & enterprise applications,"Internal enterprise projects, Commercial products","SQL databases, Event sourcing",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Interactive development, Quotations",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,2-3 years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Lack of native Visual Studio support for Web applications","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Faster time to market, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Object expressions, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information",
14/04/2015 06:09:32,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"HN, Reddit and other programming news sites, F# bloggers","F# books, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Machine learning, Mainstream business & enterprise applications, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Commercial products","SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,"Windows, Azure","LLVM, Native",C++,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Interactive development, Object-oriented compatibility, Type providers, Units of measure",Not enough real-world code to learn from,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,3-4 years,,Enterprise development,,"Working with C#-centric tooling, Performance issues, Excessive allocations (e.g Option)","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Immutability by default, Object expressions, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with short ""cookbook"" style information",
14/04/2015 06:24:14,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,Google groups,Fsharpforfunandprofit,,I don't use F# at work,"Utilities and tools, Algorithm-heavy business applications (non-financial), Financial services, Machine learning, Data analysis/statistics",Not applicable. None of my F# code is used by other people,Read-only data sources such as feeds,Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux",Javascript,"C#, C++, Javascript, Python",,"Conciseness of code (I can see more at a glance), Speed of development",Beginner (For example: you know OO well and functional programming seems strange),,"Lack of good tutorials/documentation, I can't use my knowledge from C# or other imperative languages, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft, No buy-in: There is lack of acceptance from other teams",I want to learn functional programming but I don't like academic jargon,"No perceived practical benefit, no one knows about it. Sell it. ",Haven't really used it yet,,Enterprise development,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",,,Tutorials on Practical And simple but realistic problems,"Show practical value, sell it. ","More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 06:35:41,10 or more years,"No, I don't know much theory",Just tinkering,,"F# Weekly, HN, Reddit and other programming news sites","F# bloggers, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,Windows,Windows,"Javascript, Native","C#, Typescript, x++",,"Better domain modelling with records and unions, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Interactive development, Units of measure",Not enough real-world code to learn from,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,,,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference, Type providers",,,More material with real-world examples and war stories,
14/04/2015 06:49:10,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"F# Weekly, IRC","Links and instructions from fsharp.org, F# books, IRC",,,,,,Visual Studio 2012 or newer,Windows,Windows,"LLVM, Native, ARM microcontrollers","C, Visual Basic, ARM assembly language",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Interactive development, Object expressions, Object-oriented compatibility, Quotations, Type providers","Lack of good tutorials/documentation, Not enough real-world code to learn from",,I want to learn functional programming but I don't like academic jargon,,2-3 years,,,,"Not being part of the core .NET distribution, Working with C#-centric tooling, Lack of application examples with proper user interfaces",,"Algebraic types (inc discriminated unions and tuples), The ""piping"" idiom, Type inference",,,"short, fun and complete examples with user interfaces with graphics and sound. No more pointless fibonacci style programs ported from some other language.",
14/04/2015 07:25:57,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,,"MSDN, F# books, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,Financial services,Internal enterprise projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, C++, Javascript, Objective-C, Python",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Computation expressions, Quotations, Static type constraints, Type providers, Units of measure",Not enough real-world code to learn from,,,,4 or more years,,Financial services or similar,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom",,,,
14/04/2015 08:04:48,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Vimeo, YouTube, Channel9","F# books, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,It's used unofficially,Utilities and tools,"Internal enterprise projects, Open source projects",Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,"JVM, Javascript, LLVM, Native","C#, Python",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Units of measure,"Lack of good tutorials/documentation, Scot Wlaschin is great, but we need 10 of them","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,"Working with C#-centric tooling, LAck of design support (WPF, WinForms)","Correctness: fewer bugs and less rework, Faster time to market, Better for solving complex problems","Easy integration with other .NET libraries, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans), and more!",
14/04/2015 08:07:23,10 or more years,"No, I don't know much theory",Just tinkering,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,NoSQL database,Visual Studio 2012 or newer,"Windows, Mac",,None -- I'm happy with the CLR/Mono,"C#, Javascript",,"Having fun again, Learning functional programming in general",Beginner (For example: you know OO well and functional programming seems strange),,"I can't use my knowledge from C# or other imperative languages, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Active Patterns, Immutability by default, Interactive development, Type providers",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 08:40:04,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# bloggers","F# books, F# bloggers, Personal mentoring, Videos (e.g. Community for F#), Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,Native,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,"Lack of good tutorials/documentation, Don't understand the compiler errors, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I like theory -- I'm not afraid of monads and other abstractions,"Poor integration with UI development.
Basically there is no an established framework for UI implementation leveraging Functional Reactive UI.",1-2 years,,Enterprise development,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems, Performance issues",,"Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, No dependency cycles, The ""piping"" idiom, Type inference","Following a full end to end tutorial for a medium complex application.
Showing the workflow for a functional developer including Code Design, UI, Properties Driven Tests, Performance Tweaking and Refactoring.","Provide more material for learning.
There's a gap between beginner and expert which is not covered.
Too many basic tutorials, too many advanced (theoretical) articles, too few intermediate examples. 
Too few examples on functional patterns, anti patterns, best practices etc...","More material with in-depth tutorials, More material with real-world examples and war stories",
14/04/2015 08:51:17,5-10 years,"No, I don't know much theory",I use it for hobby or side projects,Most of my work uses R packages at the moment and this is for me still easier to do directly in R,"Twitter, F# Weekly, HN, Reddit and other programming news sites","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions",,It's used unofficially,"Machine learning, Data analysis/statistics",Not applicable. None of my F# code is used by other people,"SQL databases, Data integration and EAI",Visual Studio 2012 or newer,Windows,Windows,Native,"C#, Python, R",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows, Computation expressions, Quotations",Lack of good tutorials/documentation,,I'm willing to learn advanced concepts but only if they are relevant and practical,,I was using F# but have stopped,,"Academic, research, or related",,"Working with C#-centric tooling, Difficulty in troubleshooting problems",,"Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 09:31:06,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,Twitter,"Links and instructions from fsharp.org, F# bloggers, Videos (e.g. Community for F#)",,I don't use F# at work,Games,Open source projects,Not doing data centric apps,MonoDevelop,"Mac, Linux","Windows, Mac, Linux",Native,"C#, Clojure, Java, Javascript",,"Conciseness of code (I can see more at a glance), Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor)","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Customers are used to OO",I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Science or related,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Cross-platform issues",,"Algebraic types (inc discriminated unions and tuples), Backtick naming, Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference, Units of measure",,,"More material with real-world examples and war stories, More short ""live coding"" videos",
14/04/2015 09:31:55,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"HN, Reddit and other programming news sites, IRC","MSDN, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,None - Just playing around,,,Vanubi,Linux,,Javascript,"C, Go, Java, Javascript, PHP, Python, Vala",,,Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),,,,I'm willing to learn advanced concepts but only if they are relevant and practical,"Not being spammed enough in the open source. You can hear sometimes of Rust, or D. But that's a general problem of .NET, you also rarely hear of C#.",Haven't really used it yet,,Enterprise development,,,,"Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Immutability by default, Interactive development, printf that is type checked, Quotations, The ""piping"" idiom, Type inference, Type providers, Units of measure","Many things are explained as a matter of course instead of being explained more in-depth. Take type providers for example from msdn: https://msdn.microsoft.com/en-us/library/hh156509.aspx . I don't think that's a great explanation of how type providers work, especially by the fact that's not a feature of many other common languages. I learn that by reading blogs. The issue is that it assumes too much knowledge from the reader, the examples are just examples without explaining what's going on.","There's no killer software to be used in an open source enterprise. Say you need a web server, there's certainly nothing written in F# to be used as web server in place of apache httpd or nginx.

If an enterprise is forced to use an F# software because it has killer features compared to others, chances are that the enterprise itself will contribute back and thus increase the relevance of F# in the enterprise.",More material with in-depth tutorials,
14/04/2015 10:16:27,10 or more years,"Yes, I enjoy computer science and mathematics",Fake build scripts,,Twitter,"F# bloggers, Reading F# code written by experts",,It's used unofficially,Utilities and tools,Build scripts,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript",,Learning functional programming in general,Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,I can't use my knowledge from C# or other imperative languages,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,"The learning curve to understand functional programming, not F#'s fault.",1-2 years,,Enterprise development,,Difficulty in troubleshooting problems,Correctness: fewer bugs and less rework,"Active Patterns, Easy integration with other .NET libraries, The ""piping"" idiom",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 10:21:37,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly","MSDN, Answers to Stack Overflow questions, http://fsharpforfunandprofit.com/",,It's officially endorsed for critical/production areas,"Utilities and tools, Custom development/specialist markets, Mainstream business & enterprise applications","Internal enterprise projects, Commercial products, Open source projects","SQL databases, NoSQL database",Visual Studio 2012 or newer,"Windows, Mac",Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript",,Learning functional programming in general,Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Object expressions, Static type constraints, Units of measure",the learning curve is steep but I don't think that should be changed because we don't want c# written in f# syntax we want functional code.,We seem to moving more towards es6.,I'm willing to learn advanced concepts but only if they are relevant and practical,It comes over to academic.,1-2 years,,healthcare,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.",none of the above because we were learning :),"Async workflows, Computation expressions, printf that is type checked, The ""piping"" idiom, Type inference",,"F# is currently very geared towards a financial niche, we use it as a general purpose language. 

We're running into a lot of interop stuff esp. calling f# from c# can be a drag. 

We're really missing application framework like things.

Database access is still very weird, reading is ok but writing soon turns into something weird. Using NH or EF from f# forces the use of loads of <- which feels wrong.",More material with real-world examples and war stories,
14/04/2015 11:06:40,Less than a year,"Yes, I enjoy computer science and mathematics",Just tinkering,I switched to Clojure.,Twitter,,,,,,,Emacs,Mac,,,Clojure,,,Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,,,,,Haven't really used it yet,,Enterprise development,,,,,,,,
14/04/2015 11:11:19,5-10 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,F# bloggers,"MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,,C#,,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Great community, Having fun again","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Agents (MailboxProcessor), Integration with non-F# libraries, Quotations",I can't use my knowledge from C# or other imperative languages,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,"Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc.",,"Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos",
14/04/2015 11:14:16,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, HN, Reddit and other programming news sites, F# bloggers, Slack ""functional programming""","F# bloggers, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Research/Teaching, Text analysis/language parsing","Internal enterprise projects, Open source projects",Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, Linux, Azure",None -- I'm happy with the CLR/Mono,"C#, C++, Haskell, MSBUILD",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Type providers, Units of measure",Hard to find the thing I'm looking for on MSDN as I don't know what it is technically called,"Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,"Missing higher kinds.

Type inference is not 'total' (for want of a better word), need to overuse |> to work around it.",Less than a year,Thanks!,cloud services,,"Less sophisticated tools for refactoring, etc., Performance issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Object expressions, Type inference",,Stop C# stealing features,Full-scale development with F#,
14/04/2015 11:18:29,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,Twitter,"F# books, F# bloggers",,I don't use F# at work,"Utilities and tools, Games",Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,None -- I'm happy with the CLR/Mono,C++,,"Conciseness of code (I can see more at a glance), Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Units of measure,Not enough real-world code to learn from,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I want to learn functional programming but I don't like academic jargon,"Not being a full .NET language, particularly not being able to create protected members seems like an insane decision as it makes OO design difficult and creating libraries to be consumed by C# devs impossible.",Less than two months,,video games development,,Working with C#-centric tooling,,"Algebraic types (inc discriminated unions and tuples), Immutability by default, Object-oriented features (inc. C# compatibility, conciseness), Type inference","Stop using the M-word. No one cares about monads, if they did you wouldn't have to keep explaining them in every goddam functional programming post. ",,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 11:28:45,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,It's officially endorsed for non-critical/non-production code,None - Just playing around,Not applicable. None of my F# code is used by other people,"SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,"Windows, iOS, WinPhone",None -- I'm happy with the CLR/Mono,"C#, Java, Javascript",,"Conciseness of code (I can see more at a glance), Great community, Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",Agents (MailboxProcessor),"I can't use my knowledge from C# or other imperative languages, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams, Customers are against using ""unproven technologies""",I want to learn functional programming but I don't like academic jargon,,2-3 years,,Enterprise development,,"Lack of F# friendly libraries, Working with C#-centric tooling",,"Active Patterns, Backtick naming, Interactive development, The ""piping"" idiom, Type providers, Units of measure",,,"More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 11:30:47,5-10 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, HN, Reddit and other programming news sites",Links and instructions from fsharp.org,,It's officially endorsed for critical/production areas,"Utilities and tools, Custom development/specialist markets",Commercial products,Not doing data centric apps,Emacs,Linux,Windows,"Javascript, LLVM, Native","C#, C++, Haskell, Javascript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Computation expressions, Quotations","Lack of good tutorials/documentation, Not enough real-world code to learn from",Training: They are worried about getting non-F# developers up to speed,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,,"Correctness: fewer bugs and less rework, Easy concurrency with async and agents","Async workflows, Units of measure",,,,
14/04/2015 11:35:46,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,Waiting for more R&D time to become available in my schedule,F# bloggers,"F# books, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Mainstream business & enterprise applications, Text analysis/language parsing",Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,Windows,"Windows, Azure",None -- I'm happy with the CLR/Mono,"C#, Javascript, Typescript",,"Conciseness of code (I can see more at a glance), Having fun again, Learning functional programming in general, Speed of development","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Type providers, Units of measure","Lack of good tutorials/documentation, Don't understand the compiler errors, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Enterprise development,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",More productive with fewer developers,"Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 11:37:23,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers",,I don't use F# at work,Algorithm-heavy business applications (non-financial),Open source projects,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,"Windows, Azure","JVM, Javascript","C#, Javascript, R",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor), Object-oriented compatibility, Quotations, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,"Lack of ecosystem support. MS don't support it (much) and the community is improving but not as strong as scala,clojure,ruby,python,javascript. 

Also, I miss type classes.",1-2 years,,consultant,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.",,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, Type inference, Type providers",Reduce the surface area by focusing on an ideal subset (for me this is the functional parts). ,If MS pushed it we would use it.,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 11:37:39,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,Twitter,"F# bloggers, Links posted on social media such as Twitter, Answers to Stack Overflow questions, Reading F# code written by experts, F# Snippets",,It's officially endorsed for critical/production areas,Utilities and tools,Open source projects,,Visual Studio 2012 or newer,Windows,Windows,"Javascript, LLVM","Scala, CofeeScript",,"Conciseness of code (I can see more at a glance), Great community, Having fun again, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),Object expressions,,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,"It's great, if member methods can be used as function like the below
type Foo (bar) =
  member __.Baz x = printfn ""%s and %s"" bar x

Foo ""bar"" |> Foo.Baz ""qux""
or
Foo ""bar"" |> Baz ""qux""
",2-3 years,,NEET,,Cross-platform issues,"Domain modelling: making illegal states unrepresentable, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents, Better for solving complex problems","Async workflows, Computation expressions, The ""piping"" idiom, Type inference, Type providers",I guess that F# code examples with correspond Haskell code would be pedagogical for other programmers who are interested in functional programming.,,More material with real-world examples and war stories,
14/04/2015 11:38:02,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, HN, Reddit and other programming news sites","MSDN, F# books, Links posted on social media such as Twitter, Links mentioned in F# Weekly",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Research/Teaching, Data analysis/statistics","Internal enterprise projects, Open source projects","NoSQL database, Event sourcing",Visual Studio 2012 or newer,Windows,"Windows, Azure",LLVM,"C, Objective-C, Typescript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),,,Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,"Academic, research, or related",,"Not being part of the core .NET distribution, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, Type inference","Keep doing the adverts for ""up for grabs"" issues on F# compiler. ",Get MSFT to really support it. And/Or: Get a lot of OS love for it. ,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 11:42:31,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers, github","F# books, F# bloggers",,It's officially endorsed for critical/production areas,"Utilities and tools, Mainstream business & enterprise applications, Text analysis/language parsing, Other","Internal enterprise projects, Open source projects","SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,"Windows, Azure, Amazon Web services",None -- I'm happy with the CLR/Mono,"C#, C++, Haskell, Java, Ocaml/SML, Scala, O*C*aml",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Object expressions, Units of measure",Lack of Japanese documentation,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,Development environment support. VFPT is great tool but not enough.,4 or more years,,Enterprise development,,"Lack of F# friendly libraries, unusual build system (ex. FAKE, Packet)","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, Quotations, The ""piping"" idiom, Type inference, Type providers",more books,,More material with in-depth tutorials,
14/04/2015 11:44:53,1-2 years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly, StackOverflow chat","F# books, F# bloggers, Links posted on social media such as Twitter, Reading F# code written by experts",,I don't use F# at work,"Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications",Commercial products,"SQL databases, NoSQL database, Event sourcing",Visual Studio 2012 or newer,Windows,Azure,"JVM, Javascript","C#, Javascript, Typescript",,"Correctness (no nulls, it works first time), Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Type providers,,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,"IDE support and ease of doing things with the solution explorer. Managing folders/files still feels very clunky and difficult. Drag and drop to reorder files would be a huge time saver, also drag and drop into a folder would be awesome (compared to F# Power Tools Move to folder command). Also if checking in to source control and empty folder, that folder will disappear when launching VS the next time (i.e. there has to be a file in the folder for it to stick). In addition, I tried some of the open source templates such as Dan Mohl's ASP.NET MVC template. However, I ended up just switching to a C# MVC project with and F# library holding all the MVC logic. This is because even with the open source MVC template, there is still no ""Show Hidden Files"" button like in C# MVC projects. I use this button all the time when adding images and other content to a web project. Overall, the IDE experience is my major pain point with using F#.",1-2 years,,Enterprise development,,"By far the IDE experience. F# Power Tools helps, but still difficult compared to the C# experience. (i.e. A project cant have more than one folder of the same name, even if having different parent directories. Power Tools registers move to folder as addiiton of a new file, instead of rename like moving files in a C# project). Move file up and move down it would be nice to have the ability to drag and drop to reorder files.",,"Algebraic types (inc discriminated unions and tuples), Immutability by default, The ""piping"" idiom",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
14/04/2015 11:53:53,5-10 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"HN, Reddit and other programming news sites","MSDN, Links and instructions from fsharp.org, F# bloggers, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,It's used unofficially,"Utilities and tools, Algorithm-heavy business applications (non-financial)",Not applicable. None of my F# code is used by other people,,Visual Studio 2012 or newer,Windows,,,"C#, C++, Visual Basic",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,,Perf not as good as C++. Heavy investment in C#. Most benefit using F# style in C#.,I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Science or related,,"Less sophisticated tools for refactoring, etc.",,"Algebraic types (inc discriminated unions and tuples), Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More short ""live coding"" videos, More podcasts and other audio-only material",
14/04/2015 12:02:04,1-2 years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# bloggers","Structured training/workshops, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Custom development/specialist markets",Open source projects,,Emacs,"Windows, Mac, Linux",Linux,,C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Async workflows, Object-oriented compatibility",I can't use my knowledge from C# or other imperative languages,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I want to learn functional programming but I don't like academic jargon,,Less than two months,,Enterprise development,,Cross-platform issues,"Correctness: fewer bugs and less rework, More productive with fewer developers, Efficiency/Performance, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Backtick naming, Immutability by default, Interactive development, printf that is type checked, The ""piping"" idiom, Type inference, Type providers",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos",
14/04/2015 12:05:28,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly","F# bloggers, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's used unofficially,"Custom development/specialist markets, Mainstream business & enterprise applications, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Commercial products",Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, Azure",None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Computation expressions, Interactive development, Object expressions, Quotations, Type providers, Units of measure",Don't understand the compiler errors,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,Difficulty in troubleshooting problems,"Easy concurrency with async and agents, Better for solving complex problems","Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Immutability by default, The ""piping"" idiom",,,More material with in-depth tutorials,
14/04/2015 12:13:53,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,"Not much time to play with tooling on mobile development and much more junior devs around me, not often willing learn.","Twitter, F# Weekly","Links and instructions from fsharp.org, F# bloggers, Links mentioned in F# Weekly, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Financial services, Mobile apps","Internal enterprise projects, Commercial products","SQL databases, NoSQL database",Xamarin,"Windows, Mac","Windows, iOS, Android, Azure","JVM, Javascript, LLVM","C#, PHP",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Type providers, Units of measure",tooling,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, Too Windows-centric: They have concerns over cross-platform issues, No buy-in: There is lack of acceptance from other teams",I want to learn functional programming but I don't like academic jargon,Not much knowledge of functional by mainstream developers,2-3 years,,Enterprise development,,"Difficulty in troubleshooting problems, Cross-platform issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Agents (MailboxProcessor), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference","More real word usages. For example my best learning source was articles from Scott Wlaschin, where he showed f# usage from A to Z and wrote how to use particular f# features in much bigger overview.",Unfortunately it is mine observation in my business area in small mobile apps development. Where we are quite fighting with budgets.,"More material with in-depth tutorials, More material with real-world examples and war stories",
14/04/2015 12:17:56,10 or more years,"No, I don't know much theory",Just tinkering,,"Twitter, F# Weekly, F# bloggers","F# books, F# bloggers, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,,SQL databases,Visual Studio 2012 or newer,Windows,Windows,"JVM, Javascript",C#,,"Conciseness of code (I can see more at a glance), Having fun again, Learning functional programming in general",Beginner (For example: you know OO well and functional programming seems strange),Agents (MailboxProcessor),,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Fad: They have concerns over long term language viability",I'm willing to learn advanced concepts but only if they are relevant and practical,,Haven't really used it yet,,Enterprise development,,,,"Algebraic types (inc discriminated unions and tuples), Computation expressions, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 12:27:59,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,Twitter,"Links and instructions from fsharp.org, F# bloggers, Answers to Stack Overflow questions",,It's used unofficially,Utilities and tools,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,"JVM, Javascript","C#, Javascript",,"Conciseness of code (I can see more at a glance), Great community, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Object-oriented compatibility",Don't understand the compiler errors,No buy-in: There is lack of acceptance from other teams,I like theory -- I'm not afraid of monads and other abstractions,"Need to ""declare before use"", ie need to specify file compilation order and need to put private funcs before public ones in each file. It's just like 1980's C programming all over again and I find it the biggest challenge to getting people to take the language seriously.",Less than a year,,Enterprise development,,"Not being part of the core .NET distribution, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",Correctness: fewer bugs and less rework,"Active Patterns, Async workflows, Easy integration with other .NET libraries, Immutability by default, Interactive development, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More podcasts and other audio-only material",
14/04/2015 12:28:17,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,Twitter,"F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Financial services, Games, Machine learning, Mainstream business & enterprise applications, Mobile apps, Research/Teaching, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Commercial products, Open source projects","SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,"Windows, Mac, Linux","Windows, Mac, Linux",Native,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Computation expressions, Static type constraints, Units of measure",Lack of good tutorials/documentation,Nothing. Everyone loves it.,I want to learn functional programming but I don't like academic jargon,"Technical:
1) Binding redirects for FSharp.Core 
2) Speed of compilation
3) More familiar break & continue for imperative loops
Social:
Great F# showing conferences, user groups, etc. but still not reaching the ""dark matter developers""",4 or more years,"Great survey, thanks!",Financial services or similar,,Minimal visible support from Microsoft,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 12:48:50,10 or more years,"No, I don't know much theory",Just tinkering,,"HN, Reddit and other programming news sites","MSDN, Answers to Stack Overflow questions, HN Links",,I don't use F# at work,None - Just playing around,,SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C, C#, C++, Javascript, Typescript",,,Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,"Lack of good tutorials/documentation, Don't understand the compiler errors, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, Too Windows-centric: They have concerns over cross-platform issues, No buy-in: There is lack of acceptance from other teams",I want to learn functional programming but I don't like academic jargon,,Haven't really used it yet,,Enterprise development,,Not being part of the core .NET distribution,,,Less Jargon,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos","Not use Google rubbish where it randomly picks a language because ""it knows best"""
14/04/2015 12:51:48,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, HN, Reddit and other programming news sites","Links posted on social media such as Twitter, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,It's officially endorsed for critical/production areas,"Utilities and tools, Mobile apps",Commercial products,"SQL databases, NoSQL database, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,"Windows, iOS, Android, Azure","JVM, Javascript, Native","C#, Javascript, Typescript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Type providers, Units of measure",Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Fad: They have concerns over long term language viability, Too Windows-centric: They have concerns over cross-platform issues",I like theory -- I'm not afraid of monads and other abstractions,"Erratic, non-predictable performance",4 or more years,,Mobile app development,,"Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Async workflows, The ""piping"" idiom",Better tooling,,"More material with in-depth tutorials, More short ""live coding"" videos",
14/04/2015 13:04:04,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Mainstream business & enterprise applications, Data analysis/statistics","Internal enterprise projects, Commercial products, Open source projects","SQL databases, NoSQL database, Read-only data sources such as feeds",Visual Studio 2012 or newer,"Windows, Mac",Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Computation expressions, Quotations","Lack of good tutorials/documentation, Not enough real-world code to learn from","Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,"Out-of-the-box tooling – without Visual F# Power Tools, one might as well use Vim to develop F#. The same is true for C#, though – without ReSharper, VS is barely usable as a C# IDE. Not really F#/C# problems, but VS provides the core experience for F# developers and is an important part of the ecosystem.

As for problems in F# as a language, I can't think of one.",4 or more years,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Annoying VS bugs (indentation, word movement inside backticks)","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, Interactive development, Object expressions, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers","By starting with the fundamentals: all functions take exactly one argument, what parentheses actually mean in the syntax, etc. At the core, F# is a very simple language and I believe it is that simplicity which makes a person love the language. A person who has fallen in love with the fundamentals is more likely to invest in learning the harder stuff. Leave the academic jargon (algebraic types, monads, even immutability) out in low-level tutorials and let beginners see the language as a beautiful general-purpose programming language.","Take over the reins in the industry from all the expert beginners who know nothing but C# and wrongly believe that they know what they need to know. Tall order, I know :).","More material with in-depth tutorials, More material with real-world examples and war stories",
14/04/2015 13:04:05,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"HN, Reddit and other programming news sites","MSDN, Links and instructions from fsharp.org",,I don't use F# at work,"Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications","Internal enterprise projects, Commercial products","Read-only data sources such as feeds, Analytics",,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance)",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Units of measure","Installation process, Don't understand the compiler errors",Hiring: They worry about not being able to find F# developers,I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Enterprise development,,"Not being part of the core .NET distribution, Lack of F# friendly libraries","More productive with fewer developers, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Interactive development, Type providers",,,More interactive tutorials (e.g. like the F# Koans),
14/04/2015 13:04:14,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"HN, Reddit and other programming news sites","Links and instructions from fsharp.org, Answers to Stack Overflow questions, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Mainstream business & enterprise applications",Internal enterprise projects,"SQL databases, NoSQL database, Event sourcing",Visual Studio 2012 or newer,"Windows, Linux","Windows, Amazon Web services","None -- I'm happy with the CLR/Mono, LLVM, Native",C#,,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Quotations,"knowing how to do something, but not knowing the right words to put into google to find out how to do it in F#, because of functional jargon","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Financial services or similar,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
14/04/2015 13:09:55,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,"Rather than fully extending OOP with all of the goodies of FP like Scala does. Also F# feel much more limited in its abilities.

For example I wrote similar code which uses a base AST and 2 variants for different purposes. In Scala I could just define 3 different case classes, the latter 2 extending the base. It is not possible to extends DU's in F# easily and you have to use some interface hacks.

Another thing that feels very backwards in F# is the strict order in which you have to define functions and files, which for my project meant that pretty much everything had to be in the same file.

As I have to heavily integrate my F# code with C# code, I feel like C# with heavy use of LINQ just is much easier to work with than integrating C# and F#.

I did not feel these same problems while working with Java and Scala because Scala feel like an extention of an OOP language.","HN, Reddit and other programming news sites","MSDN, F# bloggers, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,"Mainstream business & enterprise applications, Research/Teaching, Text analysis/language parsing",Academic prototypes,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,JVM,"C#, Java, PHP, Scala",,Learning functional programming in general,Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows, Interactive development, Quotations, Units of measure","Lack of good tutorials/documentation, I can't use my knowledge from C# or other imperative languages",No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,F#'s OCAML ancestry and inherited restrictions. It feels very unfamiliar even to those already familiar with FP languages like Scala or Haskell and it's restrictions seem severe.,Less than a year,,"Academic, research, or related",,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",Correctness: fewer bugs and less rework,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Immutability by default, Type inference",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 13:11:14,10 or more years,"No, I don't know much theory",Just tinkering,,F# bloggers,"F# books, F# bloggers, Answers to Stack Overflow questions, Personal mentoring",,It's used unofficially,,,,Visual Studio 2012 or newer,Windows,Windows,,"C#, SQL",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Computation expressions, Integration with non-F# libraries, Interactive development, Object expressions, Object-oriented compatibility, Quotations, Static type constraints, Type providers, Units of measure","I can't use my knowledge from C# or other imperative languages, Don't understand the compiler errors",,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,,,"Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,,
14/04/2015 13:11:52,10 or more years,"Yes, I enjoy computer science and mathematics",exploring real app,,"Twitter, F# Weekly","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Mainstream business & enterprise applications, Mobile apps","Internal enterprise projects, Commercial products",SQL databases,Visual Studio 2012 or newer,Windows,"Windows, Android, Azure, Amazon Web services","LLVM, Native","C#, C++, Java, Scala",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Object-oriented compatibility,Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, Too Microsoft-centric: They think it is too closely linked to Microsoft",I like theory -- I'm not afraid of monads and other abstractions,Nobody knows the benefits of Metaprogramming (Quotations),Less than a year,F# is really great! Thanks for it!,Enterprise development,,Difficulty in troubleshooting problems,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Interactive development, Quotations, Type inference, Type providers, Units of measure",real-world examples,"More Type Providers (e.g. for Swagger), PEG Parser & DSL Support","More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 13:17:38,10 or more years,"No, I don't know much theory",I haven't used it yet.,,Technology news,"Links posted on social media such as Twitter, Videos (e.g. Community for F#)",,,,,,Visual Studio 2010 or older,,,None -- I'm happy with the CLR/Mono,"C#, Visual Basic",,I haven't used F#.,Beginner (For example: you know OO well and functional programming seems strange),,I haven't used F#.,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I want to learn functional programming but I don't like academic jargon,,Haven't really used it yet,,Enterprise development,,I haven't used F#.,,I haven't used F#.,"Practice, practice, practice, etc.",I don't know.,A lengthy video tutorial.,
14/04/2015 13:22:39,2-5 years,"No, I don't know much theory",Just tinkering,,F# Weekly,"Links and instructions from fsharp.org, F# books, Links mentioned in F# Weekly",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Java, Javascript",,"Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Agents (MailboxProcessor), Async workflows, Computation expressions, Integration with non-F# libraries, Interactive development, Object expressions, Object-oriented compatibility, Quotations, Static type constraints, Type providers, Units of measure",Not enough real-world code to learn from,"Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,,Less than two months,,Enterprise development,,Difficulty in troubleshooting problems,,"Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 13:25:14,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"F# Weekly, HN, Reddit and other programming news sites","F# books, F# bloggers, Structured training/workshops",,It's officially endorsed for non-critical/non-production code,Algorithm-heavy business applications (non-financial),Commercial products,Data integration and EAI,Visual Studio 2012 or newer,Windows,Windows,"Javascript, LLVM","C#, C++, Rust",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Units of measure,Not enough real-world code to learn from,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,"Lack of type classes! :) Just kidding, I think the biggest problem is that it's treated as a second-class citizen on the .NET platform by Microsoft, which makes it much harder to convince big enterprises to adopt F#.",1-2 years,,Enterprise development,,"Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Immutability by default, No dependency cycles, Type inference",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 13:25:50,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,F# bloggers,"MSDN, F# bloggers, Answers to Stack Overflow questions",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,"Javascript, Native","C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Async workflows, Interactive development, Quotations, Static type constraints, Type providers",Not enough real-world code to learn from,I'm not sure they know about it,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Enterprise development,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Performance issues",,"Algebraic types (inc discriminated unions and tuples), Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 13:35:34,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,F# Weekly,F# books,,It's used unofficially,"Utilities and tools, Data analysis/statistics",Internal enterprise projects,"SQL databases, Analytics",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Perl",,"Conciseness of code (I can see more at a glance), Having fun again, Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Computation expressions, Object-oriented compatibility",Lack of good tutorials/documentation,Hiring: They worry about not being able to find F# developers,I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,Lack of F# friendly libraries,"Correctness: fewer bugs and less rework, More productive with fewer developers","Active Patterns, Interactive development, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information",
14/04/2015 13:38:05,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,F# bloggers,"F# books, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications, Data analysis/statistics",Internal enterprise projects,"SQL databases, Event sourcing",Visual Studio 2012 or newer,Windows,"Windows, Azure",Native,"C#, Ruby",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows, Quotations, Static type constraints, Units of measure",Not enough real-world code to learn from,No buy-in: There is lack of acceptance from other teams,I like theory -- I'm not afraid of monads and other abstractions,People think it is just C# with some extra bits.,Less than a year,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Active Patterns, Immutability by default, Interactive development, The ""piping"" idiom, Type providers",Good use of scripting for teaching,"Have good examples on using DDD and CQRS with F#, and how F# helps make some of the modelling easier","More material with in-depth tutorials, More material with real-world examples and war stories",
14/04/2015 13:39:27,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,F# bloggers,"Structured training/workshops, Reading F# code written by experts",,It's used unofficially,Utilities and tools,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, C++, Javascript, Typescript",,"Correctness (no nulls, it works first time), Learning functional programming in general, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,"Missing information on what it is doing ""behind the scenes"" at the IL level",Fad: They have concerns over long term language viability,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,,"Domain modelling: making illegal states unrepresentable, Easy concurrency with async and agents","Agents (MailboxProcessor), Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference, Units of measure",,,"More short ""live coding"" videos",
14/04/2015 13:41:32,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,It's officially endorsed for non-critical/non-production code,"None - Just playing around, Utilities and tools","Internal enterprise projects, Not applicable. None of my F# code is used by other people",SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Computation expressions, Quotations, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,"Lack of good wrappers for non-F# libraries, Cross-platform issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Active Patterns, Agents (MailboxProcessor), Easy integration with other .NET libraries, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 13:44:53,10 or more years,"No, I don't know much theory",Just tinkering,,"HN, Reddit and other programming news sites, F# bloggers","MSDN, F# books, F# bloggers, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,I don't use F# at work,Utilities and tools,Internal enterprise projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,Learning functional programming in general,"Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Quotations, Units of measure","I can't use my knowledge from C# or other imperative languages, Don't understand the compiler errors",,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,Difficulty in troubleshooting problems,,"Easy integration with other .NET libraries, The ""piping"" idiom, Type providers",,,"More material with real-world examples and war stories, More short ""live coding"" videos",
14/04/2015 13:45:31,2-5 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"HN, Reddit and other programming news sites","MSDN, Links and instructions from fsharp.org, F# books, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Mainstream business & enterprise applications","Internal enterprise projects, Open source projects","SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,"LLVM, Native","C#, Scala",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Learning functional programming in general, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Object expressions",,"Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 13:46:30,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# bloggers","MSDN, F# books, F# bloggers",,It's officially endorsed for critical/production areas,"Utilities and tools, Financial services, Machine learning","Internal enterprise projects, Open source projects",SQL databases,Visual Studio 2012 or newer,Windows,Windows,"Javascript, LLVM","C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Type providers",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Financial services or similar,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Backtick naming, Immutability by default, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories","""rarely use type annotations"" does not make you experienced. "
14/04/2015 13:47:43,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"F# Weekly, StackOverflow chat","F# books, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Mainstream business & enterprise applications, Text analysis/language parsing",Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,Windows,,"C#, Haskell, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Computation expressions, Object expressions, Quotations, Type providers, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams, Team members hate functional programming.",I like theory -- I'm not afraid of monads and other abstractions,Lol. Its ML basis. I prefer Haskell to F#; but F# to C#.,4 or more years,Thanks!,Enterprise development,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,I wish I knew!,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",Pretty good survey.
14/04/2015 13:50:50,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,F# Weekly,"F# bloggers, Reading F# code written by experts",,It's used unofficially,"Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Mainstream business & enterprise applications",Commercial products,Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,Windows,"JVM, Javascript, Native","C#, Scala",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Having fun again, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Async workflows, Quotations, Type providers, Units of measure",Not enough real-world code to learn from,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Data or analytics related,,"Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,More material with real-world examples and war stories,
14/04/2015 13:51:28,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Structured training/workshops, Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Data analysis/statistics",Internal enterprise projects,"SQL databases, Event sourcing, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,"LLVM, Native","C#, Javascript, Ocaml/SML, Python",,"Better domain modelling with records and unions, Great community, Having fun again, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Object expressions, Units of measure",Not enough real-world code to learn from,"Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,Functors from OCaml would be great!,4 or more years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 13:53:52,2-5 years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly",fsharpforfunandprofit.com,,I don't use F# at work,Games,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, Mac, Linux, iOS, Android, WinPhone, Azure, Amazon Web services",None -- I'm happy with the CLR/Mono,"C#, Python",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Computation expressions, Object expressions, Quotations, Units of measure","Not enough real-world code to learn from, would love to see ""path of go"" code from microsoft research",No perceived benefits: They don't understand what benefits F# has over C# or other languages,I want to learn functional programming but I don't like academic jargon,,Less than a year,,Enterprise development,,"Less sophisticated tools for refactoring, etc.",,"Active Patterns, Backtick naming, Immutability by default, Simple ""one liner"" type definitions for records and DUs",,,,
14/04/2015 13:55:02,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"Twitter, F# bloggers","Links and instructions from fsharp.org, F# books, Structured training/workshops, Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux",,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Quotations, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from",Clients don't use it - we're a consultancy,I like theory -- I'm not afraid of monads and other abstractions,,3-4 years,,Enterprise development,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Immutability by default, Interactive development, No dependency cycles, The ""piping"" idiom, Type inference, Type providers",It would be good to see a comprehensive course for F# (or set of courses) along the lines of the Coursera material for Scala,"Evangelism with large companies who are conservative and often tied to OO, e.g. Java or C# + MS stack","More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 13:57:14,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"F# Weekly, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,It's officially endorsed for critical/production areas,Financial services,Internal enterprise projects,"SQL databases, Event sourcing",Visual Studio 2012 or newer,Windows,Windows,"JVM, LLVM, Native","C#, C++, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Quotations, Units of measure",Learning has not been an issue,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Too Windows-centric: They have concerns over cross-platform issues, New kid on the block",I'm willing to learn advanced concepts but only if they are relevant and practical,"1. Type providers cannot be easily used from C#
2. Tooling within Visual Studio, specifically first time users have difficulty remembering that file order is also compilation order",3-4 years,,Financial services or similar,,"Not being part of the core .NET distribution, Working with C#-centric tooling","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers","Active Patterns, Agents (MailboxProcessor), Easy integration with other .NET libraries, Immutability by default, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,"I use and love it, but the rest of the team has only dipped their toes in to the space. There is a feeling that the language is too new to be relevant yet. More high profile and successful projects using F# might start swaying people.","More material with real-world examples and war stories, More short ""live coding"" videos",
14/04/2015 13:57:31,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,none of the people i code with use the .Net CLR in production :-/,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","MSDN, reddit daily_programmer",,I don't use F# at work,"Utilities and tools, Algorithm-heavy business applications (non-financial), Data analysis/statistics",Not applicable. None of my F# code is used by other people,Read-only data sources such as feeds,TextMate,Mac,Mac,"None -- I'm happy with the CLR/Mono, JVM","C, Python, Scala",,"Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Object expressions, Object-oriented compatibility, Units of measure",Lack of good tutorials/documentation,,I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,"the F# community is very friendly, warm and welcoming. it's a tremendous asset.",Science or related,,Lack of F# friendly libraries,,"Active Patterns, Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference",,,More material with real-world examples and war stories,
14/04/2015 13:59:36,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,,"F# books, Answers to Stack Overflow questions",,I don't use F# at work,"Games, Mobile apps",Not applicable. None of my F# code is used by other people,"SQL databases, Event sourcing",Visual Studio 2012 or newer,"Windows, Mac","Windows, Mac, iOS, Android, WinPhone","LLVM, Native",C++,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,"Lack of good tutorials/documentation, Not enough real-world code to learn from",,I like theory -- I'm not afraid of monads and other abstractions,,Less than two months,,UI middleware ,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Cross-platform issues",,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 14:02:15,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, HN, Reddit and other programming news sites","F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, fsharpforfunandprofit.com",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Data analysis/statistics, Other","Internal enterprise projects, Commercial products","SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,"LLVM, Native",C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Interactive development, Object expressions, Quotations",Interop with C#,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Enterprise development,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Units of measure",,,"More material with short ""cookbook"" style information",
14/04/2015 14:02:42,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,,"Links and instructions from fsharp.org, F# books, Personal mentoring, Structured training/workshops, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,Javascript,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Computation expressions, Integration with non-F# libraries, Interactive development, Object expressions, Object-oriented compatibility, Quotations, Static type constraints, Type providers, Units of measure",Don't understand the compiler errors,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I like theory -- I'm not afraid of monads and other abstractions,,Haven't really used it yet,,Financial services or similar,,,,"Immutability by default, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Structural equality",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 14:19:14,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"HN, Reddit and other programming news sites","Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,Native,"C#, Javascript, Ruby",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Agents (MailboxProcessor)",Not enough real-world code to learn from,Training: They are worried about getting non-F# developers up to speed,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference, Units of measure",,,More material with real-world examples and war stories,
14/04/2015 14:19:38,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"Twitter, F# Weekly, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,"Javascript, Native","C#, Javascript, Visual Basic",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Great community, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Quotations",I can't use my knowledge from C# or other imperative languages,,I like theory -- I'm not afraid of monads and other abstractions,"The limit of the community's perceived scope; by making it a ""niche"" language, it's not given the overall respect it deserves.",3-4 years,No,"Academic, research, or related",,Working with C#-centric tooling,,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Interactive development, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Units of measure","I'm not sure how to answer this question.  I've been able to ground myself in the fundamentals, but as I switch between multiple languages, it becomes a challenge to remembering the differences.  It's kind of like switching between English and Japanese.","None, as I work for a training company and I was able to get an F# on our schedule for training people; unfortunately, we never got any takers plus the courseware was never updated by the author.","More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",Nothing that I can think of
14/04/2015 14:25:50,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,F# bloggers,"MSDN, Links and instructions from fsharp.org, F# books",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,,"C#, Python, Visual Basic, PowerShell",,"Conciseness of code (I can see more at a glance), Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,,Haven't really used it yet,,Enterprise development,,,,Units of measure,,,"More material with short ""cookbook"" style information",
14/04/2015 14:26:08,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,Twitter,"MSDN, Links posted on social media such as Twitter, Answers to Stack Overflow questions, FSharpForFunAndProfit",,It's used unofficially,"Utilities and tools, Mainstream business & enterprise applications, Data analysis/statistics",Internal enterprise projects,Not doing data centric apps,Visual Studio 2013 & Vim,"Windows, Mac, Linux","Windows, Mac, Linux","JVM, LLVM","C#, Clojure",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Object expressions, Object-oriented compatibility, Quotations, Units of measure",Don't understand the compiler errors,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,It needs more investment from MSFT and others.,Less than a year,,Data or analytics related,,"Not being part of the core .NET distribution, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., MSFT Core libraries need to be on NuGet.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, No dependency cycles, Simple ""one liner"" type definitions for records and DUs, Type inference, Type providers",Careful explanations of some of the more difficult topics such as monads/computational expressions.,"A larger community would help. F# and/or FP ""crossing the chasm"" is key here.","More material with in-depth tutorials, More material with real-world examples and war stories, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans), F# flavored Katas",
14/04/2015 14:27:55,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,Twitter,"F# bloggers, Links posted on social media such as Twitter",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Xamarin,Mac,,,"C#, Clojure, Java, Javascript, Python",,Great community,Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,"There is still a perception (at least in Montreal, Canada) that nobody is using it. I think the only local player is Genetec.

Can F# reach the escape velocity of having enough companies using it to prompt other companies to use it?",Haven't really used it yet,"A few years ago I was pondering functional programming and was hesitant between F# and Scala since I knew both C# and Java. In the end, I chose Scala simply I was doing Java professionally at the time.

Today, I guess I would be hesitant between OCaml which seems to be going thought a renaissance, and F#. Although if I were working in a .net shop, I would surely go with F#.","Academic, research, or related",,,,"Immutability by default, The ""piping"" idiom, Type inference",,,More interactive tutorials (e.g. like the F# Koans),
14/04/2015 14:30:20,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,,F# books,,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications","Internal enterprise projects, Commercial products, Open source projects",SQL databases,Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux","LLVM, Native","C, C++",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Type providers",Not enough real-world code to learn from,No buy-in: There is lack of acceptance from other teams,I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Enterprise development,,"Working with C#-centric tooling, Cross-platform issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Easy concurrency with async and agents, Better for solving complex problems","Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Immutability by default, Quotations, Type inference, Units of measure",,,More material with in-depth tutorials,
14/04/2015 14:36:57,2-5 years,"No, I don't know much theory",I use it for hobby or side projects,,"F# Weekly, HN, Reddit and other programming news sites, F# bloggers, StackOverflow chat","MSDN, Links and instructions from fsharp.org, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Personal mentoring",,It's used unofficially,"Utilities and tools, Mobile apps","Internal enterprise projects, Open source projects","SQL databases, NoSQL database, Event sourcing",Vim,"Windows, Linux","Windows, Linux","None -- I'm happy with the CLR/Mono, Native","C#, Java, PHP, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Units of measure",Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft",I want to learn functional programming but I don't like academic jargon,,Less than a year,,Enterprise development,,"Not being part of the core .NET distribution, Lack of good wrappers for non-F# libraries","More productive with fewer developers, Faster time to market, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference, Type providers",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 14:37:35,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"Twitter, F# Weekly, F# bloggers","F# bloggers, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,"None -- I'm happy with the CLR/Mono, Javascript, LLVM, Native","C#, Javascript, Typescript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,Not enough real-world code to learn from,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I like theory -- I'm not afraid of monads and other abstractions,,Haven't really used it yet,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.",,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 14:38:12,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Structured training/workshops",,It's used unofficially,Utilities and tools,Internal enterprise projects,"Event sourcing, Analytics",Visual Studio 2012 or newer,Windows,"Windows, Azure",JVM,"C#, Java, Objective-C, R",,"Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,Don't understand the compiler errors,"Too Microsoft-centric: They think it is too closely linked to Microsoft, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,"Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Correctness: fewer bugs and less rework, More productive with fewer developers","Active Patterns, Agents (MailboxProcessor), Async workflows, Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Units of measure",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos",
14/04/2015 14:46:17,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"Twitter, F# Weekly, IRC","F# books, Personal mentoring, Reading F# code written by experts",,It's officially endorsed for critical/production areas,Other,"Commercial products, Open source projects, Research code",Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, Mac, Linux",None -- I'm happy with the CLR/Mono,"Erlang, Haskell, Python",,"Conciseness of code (I can see more at a glance), Speed of development, Functional but can be tweaked to get high performance, More readable functional code!",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Object expressions, Units of measure",,,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,"Academic, research, or related",,No Visual Studio for Linux,Correctness: fewer bugs and less rework,"Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Quotations, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
14/04/2015 14:49:20,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"HN, Reddit and other programming news sites","MSDN, F# books, Links posted on social media such as Twitter, Answers to Stack Overflow questions",,It's used unofficially,"Utilities and tools, Data analysis/statistics",Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,Windows,"JVM, Javascript, LLVM","C#, Haskell",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Integration with non-F# libraries, Quotations","Lack of good tutorials/documentation, Not enough real-world code to learn from","Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,"Second-class support on non-Windows systems (I assume this will improve with all of the parts of .NET that have been open-sourced). Support for the more powerful features of the OCaml module system - functors, first-class modules - would be great.

",2-3 years,Thanks for doing this!,Enterprise development,,Cross-platform issues,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Type providers, Units of measure",,,,
14/04/2015 14:50:27,2-5 years,"No, I don't know much theory",I use it for hobby or side projects,,,,,I don't use F# at work,"Utilities and tools, Data analysis/statistics",Not applicable. None of my F# code is used by other people,"SQL databases, Analytics, Data integration and EAI",Visual Studio 2012 or newer,Windows,"Windows, Linux",Native,"C#, SQL",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows, Integration with non-F# libraries, Units of measure",Lack of good tutorials/documentation,,I'm willing to learn advanced concepts but only if they are relevant and practical,easy deployment to linux,Less than a year,,Data or analytics related,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries",,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, printf that is type checked, Type providers",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 14:53:55,2-5 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"HN, Reddit and other programming news sites",Links and instructions from fsharp.org,,I don't use F# at work,Utilities and tools,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Xamarin,Mac,,"LLVM, Native","C++, Haskell, Javascript, Python, Rust",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor), Integration with non-F# libraries, Interactive development, Object expressions, Object-oriented compatibility","Lack of good tutorials/documentation, Installation process",,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Student,,Cross-platform issues,,"Algebraic types (inc discriminated unions and tuples), Immutability by default, The ""piping"" idiom",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 14:59:20,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Financial services, Machine learning, Mainstream business & enterprise applications, Data analysis/statistics",Internal enterprise projects,"SQL databases, NoSQL database, Read-only data sources such as feeds, Analytics, Data integration and EAI",Visual Studio 2012 or newer,Windows,"Windows, Azure",None -- I'm happy with the CLR/Mono,"C#, Javascript, R, Visual Basic",,Functional but can be tweaked to get high performance,Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Agents (MailboxProcessor),Bugs in the compiler/intellisense,"People program in what they know. I'm the only one who knows F#. I wasn't hired because of this but, I use it because I know it helps.",I like theory -- I'm not afraid of monads and other abstractions,Lack of support for Office Interop. There are bugs in how this works,1-2 years,,Data or analytics related,,Not being part of the core .NET distribution,"Efficiency/Performance, Better for solving complex problems",Type providers,"Too many ""experts"" try to constrain F#. ","I've asked questions and have been told on occasion that F# is not the best choice. However, if it is an F# program, I don't want to write wrappers around the F# so I can deploy it as a C# app with F# features. Don't criticize my choice, help me to understand how to make it work with what I'm doing.","More material with real-world examples and war stories, More short ""live coding"" videos",
14/04/2015 14:59:57,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,"I wouldn't say I've stopped intentionally, but I've been unable to convince my employer to make use of F# so I haven't been doing as much F# development as I'd like.","Twitter, HN, Reddit and other programming news sites","Links and instructions from fsharp.org, Answers to Stack Overflow questions, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Algorithm-heavy business applications (non-financial), Financial services, Data analysis/statistics","Internal enterprise projects, Not applicable. None of my F# code is used by other people","SQL databases, Data integration and EAI",Vim,"Windows, Linux",,"Javascript, LLVM","C#, Go, Haskell, Javascript, Python, Ruby, Scheme/CL",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance)",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Interactive development, Object expressions, Quotations, Type providers, Units of measure","Lack of good tutorials/documentation, Installation process, Don't understand the compiler errors, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,"It's better than C# for sure, but it's not ENOUGH better to easily convince many of folks who are bogged down by forces of inertia.",1-2 years,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling","More productive with fewer developers, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Immutability by default, The ""piping"" idiom, Type inference","I'm hardly a VisualStudio user myself, but it seems like having template projects there would be helpful.","Get the F# build tools into the core MSBuild package.  If that weren't a question we'd be using F# more, but the extra step of installing the F# build tools is (somehow) a deal breaker.","More material with in-depth tutorials, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 15:02:55,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers, Slack Functional Programming team","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's used unofficially,"None - Just playing around, Utilities and tools, Machine learning",Internal enterprise projects,"Read-only data sources such as feeds, Not doing data centric apps",Visual Studio 2012 or newer,"Windows, Mac",Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript, Typescript",,"Conciseness of code (I can see more at a glance), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Units of measure",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Easy integration with other .NET libraries, Immutability by default, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 15:03:33,2-5 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"HN, Reddit and other programming news sites","MSDN, F# bloggers, Answers to Stack Overflow questions",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,"Windows, Mac","Windows, Mac, Linux",LLVM,"C#, Python",,Conciseness of code (I can see more at a glance),Beginner (For example: you know OO well and functional programming seems strange),Object-oriented compatibility,"Lack of good tutorials/documentation, Not enough real-world code to learn from",No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Enterprise development,,Cross-platform issues,,"The ""piping"" idiom",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 15:04:52,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"HN, Reddit and other programming news sites, F# bloggers","MSDN, Links and instructions from fsharp.org, F# bloggers, Answers to Stack Overflow questions",,It's officially endorsed for non-critical/non-production code,Utilities and tools,Internal enterprise projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, C++, Javascript, Typescript",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Computation expressions, Interactive development, Object expressions, Quotations",,"Nothing, but too busy to, even if benefits are acknowledged",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Algebraic types (inc discriminated unions and tuples), Backtick naming, Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More podcasts and other audio-only material",
14/04/2015 15:07:22,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, C++, Java, Javascript, Typescript",,"Conciseness of code (I can see more at a glance), Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",Units of measure,Not enough real-world code to learn from,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I like theory -- I'm not afraid of monads and other abstractions,"Some .NET developers I've talked to who have approached F# for the first time are also having to overcome the hurdle of switching from a more imperative to a functional type of thinking. That ""double-hurdle"" of the functional thinking plus the syntax of a new language make it seem more daunting than it may actually be.",Less than a year,It had a good mix of questions. I am anxious to be able to use F# more at work; I'll be looking forward to seeing the survey results.,Software for Medical Device,,Difficulty in troubleshooting problems,,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, Type inference","I would like to see more applications in which F# is not commonly seen as a ""natural"" fit. Creating a web service that returns records from a database, for example. I would also like to see some desktop WPF development using F# to see how that interaction goes.","I have seen a lot of growth in the awareness of F# among the typically C#-focused developers I currently work with. Keep up the work of getting the word out and having webinars, publishing samples, and offering tutorials.","More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 15:10:50,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"F# Weekly, F# bloggers","F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions",,I don't use F# at work,"None - Just playing around, Utilities and tools",Not applicable. None of my F# code is used by other people,"SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Python",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Quotations","Lack of good tutorials/documentation, Not enough real-world code to learn from","Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Enterprise development,,Difficulty in troubleshooting problems,,"Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Units of measure",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 15:17:13,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly","F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly",,It's used unofficially,"None - Just playing around, Custom development/specialist markets","Internal enterprise projects, Not applicable. None of my F# code is used by other people",Data integration and EAI,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Agents (MailboxProcessor),Not enough real-world code to learn from,No buy-in: There is lack of acceptance from other teams,I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Enterprise development,,Working with C#-centric tooling,"Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Immutability by default, No dependency cycles, The ""piping"" idiom, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 15:19:21,5-10 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"HN, Reddit and other programming news sites","Links and instructions from fsharp.org, Answers to Stack Overflow questions, Reading F# code written by experts",,It's used unofficially,"Mainstream business & enterprise applications, Mobile apps","Internal enterprise projects, Commercial products",SQL databases,Sublime Text,Windows,Windows,"JVM, LLVM, Native","C++, Haskell, Javascript, Groovy",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Units of measure,Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, Extra Runtime Cost",I'm willing to learn advanced concepts but only if they are relevant and practical,"It's a great language, not as Functional as Haskell, but also not as complicated as Scala. I like it a lot, and I think it needs more adoption before enterprises really jump on board.",Less than a year,,Enterprise development,,"Not being part of the core .NET distribution, Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
14/04/2015 15:31:43,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,F# bloggers,"Links and instructions from fsharp.org, F# bloggers, Videos (e.g. Community for F#), Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,"Lack of good tutorials/documentation, Not enough real-world code to learn from",,I'm willing to learn advanced concepts but only if they are relevant and practical,"Again, the community keeps harping on the benefits of F#. Most people get the benefits after reading a couple of blogs/articles. What is needed is real-world examples of full-stack applications built in an F# idiomatic way, not toy throw-away tutorial code showing isolated concepts. Also, a consistent web stack would help. Finally, lots of marketing needs to be done to show multiple success stories from a few big players. This marketing campaign needs to persist for a few years to increase the level of awareness of F# outside the small F# community.",Less than two months,,Enterprise development,,Lack of F# friendly libraries,,"Algebraic types (inc discriminated unions and tuples), Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference","Most existing material focus on certain features of the language in isolation. It's extremely hard to understand how one can put together a full application, especially a web application e.g. a SPA with a web API backend, a domain model, and data persistence. Also need more material on architectures that use  functional reactive DDD, CQRS and Event Sourcing.","I guess the community a great deal of effort trying to communicate the benefits of F#. I don't think you need to do more of that. What the community needs to do is to showcase multiple successful real-world production systems that was developed with F#, illustrating the benefits from a practical point of view. This is a marketing task that needs to be done, otherwise the language will remain only known to a small percentage of the developer community.

Also the learning material need to be more accessible, more complete. And the chaotic situation with respect to F# web frameworks (freya, frannk, web api, etc) is turning away new comers.","More material with in-depth tutorials, More material with real-world examples and war stories",
14/04/2015 15:34:23,5-10 years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly, Google+","Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Videos (e.g. Community for F#), Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Games, Data analysis/statistics",Not applicable. None of my F# code is used by other people,"SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,"Windows, Mac, Linux, Azure",None -- I'm happy with the CLR/Mono,"C#, Python",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Great community, Having fun again",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,"Not being part of the core .NET distribution, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos",
14/04/2015 15:36:44,2-5 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, StackOverflow chat","MSDN, F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,Financial services,Internal enterprise projects,Event sourcing,Visual Studio 2012 or newer,Windows,"Windows, WinPhone",,"C#, Haskell, Java",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Active Patterns, Object expressions, Quotations, Units of measure",,,I like theory -- I'm not afraid of monads and other abstractions,,3-4 years,,Financial services or similar,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents","Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, No dependency cycles, Simple ""one liner"" type definitions for records and DUs, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 15:44:12,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,F# bloggers,"MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Custom development/specialist markets, Data analysis/statistics",Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux",None -- I'm happy with the CLR/Mono,"C#, C++, Javascript",,"Correctness (no nulls, it works first time), Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Agents (MailboxProcessor), Computation expressions, Integration with non-F# libraries, Quotations, Units of measure",Not enough real-world code to learn from,"Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Easy integration with other .NET libraries, Immutability by default, Object expressions, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 15:47:37,2-5 years,"Yes, I enjoy computer science and mathematics",Just tinkering,Lack of enough tutorials and real world examples,"HN, Reddit and other programming news sites, F# bloggers","MSDN, F# books, F# bloggers, Links mentioned in F# Weekly, Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,"SQL databases, NoSQL database",Visual Studio 2012 or newer,"Windows, Linux",,"Javascript, LLVM, Native","C#, Javascript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,"Lack of good tutorials/documentation, Not enough real-world code to learn from","Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",,"Immutability by default, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 15:47:51,5-10 years,"No, I don't know much theory",Just tinkering,,"Twitter, F# Weekly, Google groups, IRC","F# books, F# bloggers, Links mentioned in F# Weekly",,I don't use F# at work,Games,Not applicable. None of my F# code is used by other people,"SQL databases, NoSQL database, Event sourcing",Visual Studio 2012 or newer,Windows,Windows,"None -- I'm happy with the CLR/Mono, JVM, Javascript","C#, C++, Java, Javascript, Typescript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Quotations",,"Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Financial services or similar,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 15:52:00,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"F# Weekly, Google groups, F# bloggers, IRC","F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#), fsharpforfunandprofit.com IRC ##fsharp",,,"Utilities and tools, Custom development/specialist markets, Text analysis/language parsing, Other",Open source projects,,Visual Studio 2012 or newer,Windows,Windows,"JVM, Javascript, Native","C, C#, C++, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Computation expressions, Interactive development, Object expressions, Static type constraints, Units of measure",FP concepts in general,,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,retired,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., WPF support",,"Algebraic types (inc discriminated unions and tuples), Backtick naming, Easy integration with other .NET libraries, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",If the VS F# Interactive window had intellisense. I don't like having to write a dummy .fsx file and continually send things to the FSI. Also better F# support in the VS Debugger (now you often have to use C# syntax for F# values).,,"More material with in-depth tutorials, More material with real-world examples and war stories",
14/04/2015 15:52:23,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"HN, Reddit and other programming news sites, StackOverflow chat","F# books, F# bloggers, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,It's used unofficially,Data analysis/statistics,Not applicable. None of my F# code is used by other people,Analytics,Visual Studio 2012 or newer,Windows,,"LLVM, Native","C#, C++, R",,Learning functional programming in general,Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Agents (MailboxProcessor),Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Fad: They have concerns over long term language viability, Too Windows-centric: They have concerns over cross-platform issues",I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Data or analytics related,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems, Performance issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Easy integration with other .NET libraries, Immutability by default, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference, Type providers, Units of measure",,,More material with real-world examples and war stories,
14/04/2015 15:53:44,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly","MSDN, Links and instructions from fsharp.org, F# bloggers, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Machine learning, Text analysis/language parsing",Commercial products,"SQL databases, NoSQL database, Read-only data sources such as feeds",MonoDevelop,Windows,Windows,"None -- I'm happy with the CLR/Mono, Javascript","C, C#, Clojure, Go, Haskell, Python, Ruby, Scala",,Conciseness of code (I can see more at a glance),Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Object expressions, Quotations, Type providers, Units of measure",,"Hiring: They worry about not being able to find F# developers, Too Windows-centric: They have concerns over cross-platform issues",I want to learn functional programming but I don't like academic jargon,,1-2 years,,Data or analytics related,,"Not being part of the core .NET distribution, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Performance issues",Correctness: fewer bugs and less rework,"Agents (MailboxProcessor), Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, Type inference",,,More material with real-world examples and war stories,
14/04/2015 15:54:00,1-2 years,"No, I don't know much theory",I use it for hobby or side projects,,"F# Weekly, StackOverflow chat","MSDN, Links and instructions from fsharp.org, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,It's used unofficially,"Utilities and tools, Custom development/specialist markets, Data analysis/statistics, Text analysis/language parsing",Not applicable. None of my F# code is used by other people,"SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,"Windows, Azure, Amazon Web services",None -- I'm happy with the CLR/Mono,"C#, Javascript, Visual Basic",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general, Speed of development",Beginner (For example: you know OO well and functional programming seems strange),,Not enough real-world code to learn from,,I'm willing to learn advanced concepts but only if they are relevant and practical,"functional programming is seen as a niche style - especially f#. Also, there are too many microsoft haters that will not use it solely because it is tied to microsoft (dev team at my company used delphi with some .net years ago and now solely Ruby on Rails for their new application).",Less than two months,"I am new to development and have taken courses in college for Java and other mainstream languages. After several years of mostly just scripting using vbscript and javascript with some SQL, I decided to make a few web applications in C#. After roughly six months of C#, I quickly became interested in F# due to its succinct nature, type inference, very clean look, and performance. Also, functional programming seemed very interested since it is different than the usual imperative programming style (not just a different syntax - e.g. Java vs C#). The main struggle with learning F# has been lack of community compared to the larger communities (e.g. RoR or even C#). Comparatively, the younger community is exciting, and I look forward to continuing with F# and being part of its growth.",Data or analytics related,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Working with C#-centric tooling","Correctness: fewer bugs and less rework, Efficiency/Performance","Easy integration with other .NET libraries, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference","Real-world examples, .net mvc/api examples, asp.net examples",,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material",
14/04/2015 15:59:49,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, Google+, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Financial services, Mainstream business & enterprise applications, Mobile apps, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Commercial products, Open source projects","SQL databases, NoSQL database, Event sourcing, Read-only data sources such as feeds, Analytics, Data integration and EAI",OmniSharp,"Windows, Mac, Linux","Azure, Amazon Web services",Javascript,"C#, Go, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Agents (MailboxProcessor),Lack of data access articles.,Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Enterprise development,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material",
14/04/2015 16:00:45,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,,Links and instructions from fsharp.org,,It's used unofficially,Data analysis/statistics,Commercial products,"SQL databases, Data integration and EAI",Visual Studio 2012 or newer,Windows,Windows,,"C, C#, Python, Visual Basic",,"Correctness (no nulls, it works first time), Having fun again",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,,Too Windows-centric: They have concerns over cross-platform issues,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,,Correctness: fewer bugs and less rework,"Active Patterns, Easy integration with other .NET libraries",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 16:07:32,1-2 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Personal mentoring, Reading F# code written by experts",,It's used unofficially,Utilities and tools,Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,"Windows, Mac",Windows,LLVM,C#,,"Correctness (no nulls, it works first time), Great community, Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Computation expressions, Quotations, Units of measure",Compiler errors are tough on a regular basis with respect to types and syntax,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,"No one talks about #light, but it's on by default and can lead to very subtle format issues which cause compiler warnings and errors which are hard for me to figure out even having used F# for a long time. 

Xamarin is in a pretty inconsistent state and often has what I would consider to be ship-stopping editor bugs. This is an unpleasant developer experience. 

There is a mountain of FUD against Microsoft with respect to OSS. The F# community needs to work clearly and consistently to address the FUD without fail. ",1-2 years,Don Syme is the best. Lincoln is amazing and I really enjoy the energy and involvement of the F# community. ,Enterprise development,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc., Performance issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents","Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, printf that is type checked, The ""piping"" idiom, Type inference","F# is about getting things done - therefore all tutorials should be focused on this. Additionally, libraries that come out and are highly popularized by the community should have easy and obvious setup steps to immediately get work done.",,"More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)","Make it from an official source on a regular basis and provide a way to get in touch with people if possible. For example, I work in Microsoft OSG and would love to work with whoever said there was nobody in the group using F#. "
14/04/2015 16:09:38,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","F# books, Reading F# code written by experts, fsharpforfunandprofit.com",,It's officially endorsed for critical/production areas,"Utilities and tools, Mainstream business & enterprise applications",Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,Windows,Native,,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Object-oriented compatibility, Quotations, Units of measure",Installation process,"Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,2-3 years,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Immutability by default, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
14/04/2015 16:10:42,2-5 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"Twitter, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Personal mentoring",,It's used unofficially,"None - Just playing around, Data analysis/statistics","Internal enterprise projects, Not applicable. None of my F# code is used by other people","SQL databases, NoSQL database",Visual Studio 2012 or newer,"Windows, Mac",Windows,"None -- I'm happy with the CLR/Mono, LLVM","C#, C++, Javascript, PHP, Typescript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Integration with non-F# libraries","Lack of good tutorials/documentation, Not enough real-world code to learn from",No perceived benefits: They don't understand what benefits F# has over C# or other languages,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,Difficulty in troubleshooting problems,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
14/04/2015 16:29:48,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","F# bloggers, Personal mentoring, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications",Commercial products,"SQL databases, NoSQL database, Event sourcing",Visual Studio 2012 or newer,Windows,"Windows, Azure",None -- I'm happy with the CLR/Mono,C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Units of measure,Not enough real-world code to learn from,Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling","Correctness: fewer bugs and less rework, More productive with fewer developers, Easy concurrency with async and agents, Better for solving complex problems","Async workflows, Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference",,,"More material with real-world examples and war stories, More short ""live coding"" videos",
14/04/2015 16:33:13,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,F# Weekly,"F# books, Links mentioned in F# Weekly",,I don't use F# at work,"Financial services, Data analysis/statistics",Open source projects,SQL databases,Xamarin,"Mac, Linux",Linux,None -- I'm happy with the CLR/Mono,"Ruby, Scala",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Type providers, Units of measure",Lack of good tutorials/documentation,"Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft",I'm willing to learn advanced concepts but only if they are relevant and practical,"1. No ad-hoc polymorphism. F# needs something like Clojure's protocols, or Haskell's typeclasses, or Scala's implicits.

2. An easy to use, quick to adopt, intuitive, **lightweight** web ""framework""/library.",1-2 years,,Enterprise development,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Cross-platform issues",,"Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,"For my workplace to even consider F#, it needs a broader community outside of Windows/Microsoft-land; specifically, Mac and Linux adoption.","More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 16:51:47,5-10 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"HN, Reddit and other programming news sites","F# bloggers, Reading F# code written by experts",,I don't use F# at work,Utilities and tools,Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,"Windows, Linux","Javascript, LLVM, Native","C#, Haskell",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Units of measure",Compiler tools aren't up to C# standards,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I like theory -- I'm not afraid of monads and other abstractions,Tooling needs improving.,3-4 years,,Enterprise development,,Working with C#-centric tooling,,"Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, Interactive development, No dependency cycles, Quotations, Type inference, Type providers",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 16:58:13,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,Xamarin project too difficult to work with for non-MS platforms,Twitter,F# books,,I don't use F# at work,"Utilities and tools, Data analysis/statistics",Open source projects,Read-only data sources such as feeds,Xamarin,Mac,"Mac, Linux","JVM, Native","Clojure, Java, Ocaml/SML, Scala",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,Lack of good tutorials/documentation,"Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,I was using F# but have stopped,,Science or related,,Not being part of the core .NET distribution,,"The ""piping"" idiom",,Lower the barrier to entry for teams to adopt Xamarin/Mono.,"More material with short ""cookbook"" style information",
14/04/2015 17:08:13,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"HN, Reddit and other programming news sites",jump in the deep end,,It's used unofficially,Utilities and tools,Internal enterprise projects,Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,,LLVM,"C, C#, Haskell, Ocaml/SML",,monadic code is an option,Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Async workflows, Object expressions, Object-oriented compatibility",dependency prevention based off of file order with no indication,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,Not being part of the core .NET distribution,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, Type inference, Units of measure",a list of gotchas and better error handling for syntax errors.  also for FP in general you need to find a way to motivate developers to want to work in immutable contexts.,,,
14/04/2015 17:09:31,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, HN, Reddit and other programming news sites, F# bloggers","MSDN, F# books, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,"Utilities and tools, Research/Teaching",Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, Android",Javascript,"Haskell, Java, Python",,"Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Object-oriented compatibility, Units of measure","Don't understand the compiler errors, Not enough real-world code to learn from",,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Student,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems, Cross-platform issues",,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Immutability by default, Interactive development, Object expressions, Quotations, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 17:13:13,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly, Google groups, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Videos (e.g. Community for F#)",,,Utilities and tools,Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Javascript, Typescript",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Object expressions, Quotations",Not enough real-world code to learn from,Fad: They have concerns over long term language viability,I'm willing to learn advanced concepts but only if they are relevant and practical,Microsoft doesn't treat it as a first class language. Missing or bad support for universal apps and asp.net vnext.,Haven't really used it yet,,Enterprise development,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers","Algebraic types (inc discriminated unions and tuples), Immutability by default, The ""piping"" idiom, Type inference, Type providers",,,More material with real-world examples and war stories,
14/04/2015 17:14:05,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,F# bloggers,"MSDN, Links and instructions from fsharp.org, F# bloggers, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, WinPhone, Azure",,C#,,Learning functional programming in general,"Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Agents (MailboxProcessor), Async workflows, Computation expressions, Integration with non-F# libraries, Interactive development, Object expressions, Object-oriented compatibility, Quotations, Static type constraints, Type providers, Units of measure",Not enough real-world code to learn from,"Money: They worry that good F# developers will cost too much, Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Haven't really used it yet,,Financial services or similar,,,,"The ""piping"" idiom",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 17:26:31,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers",F# bloggers,,It's used unofficially,Mobile apps,Not applicable. None of my F# code is used by other people,"SQL databases, NoSQL database",Vim,"Windows, Mac","Windows, Mac, iOS, Android","LLVM, Native","C, C#",,"Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Quotations, Type providers",Don't understand the compiler errors,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Data or analytics related,,"Working with C#-centric tooling, Performance issues",More productive with fewer developers,"Algebraic types (inc discriminated unions and tuples), Immutability by default, The ""piping"" idiom",,,"More material with short ""cookbook"" style information",
14/04/2015 17:28:01,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,I use it as a personal play and learn language. None of my colleagues use it or are inclined to use it. They feel that C# satisfies all their needs.,"F# Weekly, F# bloggers","F# books, F# bloggers, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,It's used unofficially,"Custom development/specialist markets, Other",Internal enterprise projects,"SQL databases, Event sourcing",Visual Studio 2012 or newer,Windows,Windows,,C#,,"Conciseness of code (I can see more at a glance), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Object-oriented compatibility, Units of measure",Not enough real-world code to learn from,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,Difficulty in troubleshooting problems,"More productive with fewer developers, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Interactive development, Type inference, Type providers",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 17:29:08,10 or more years,"No, I don't know much theory",Just tinkering,,F# bloggers,"Links and instructions from fsharp.org, F# bloggers, Links posted on social media such as Twitter, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Haskell, Typescript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Type providers, Units of measure",differences from Haskell,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,,Haven't really used it yet,,Software Developer,,"Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.",,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Type inference, Units of measure",,,,
14/04/2015 17:42:27,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"HN, Reddit and other programming news sites","F# bloggers, Reading F# code written by experts",,It's used unofficially,Utilities and tools,Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C, C#, C++",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Type providers, Units of measure",Not enough real-world code to learn from,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,,Less than two months,,Enterprise development,,Lack of F# friendly libraries,,"Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, printf that is type checked, The ""piping"" idiom, Type inference",,,More material with in-depth tutorials,
14/04/2015 17:44:22,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"F# bloggers, StackOverflow chat","Links and instructions from fsharp.org, F# bloggers, Answers to Stack Overflow questions, wikipedia book on F#",,It's used unofficially,"Utilities and tools, Data analysis/statistics, Text analysis/language parsing",Not applicable. None of my F# code is used by other people,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,,Javascript,"C#, Javascript",,"Correctness (no nulls, it works first time), Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Computation expressions, Quotations",Not enough real-world code to learn from,Hiring: They worry about not being able to find F# developers,I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Enterprise development,,"Lack of good wrappers for non-F# libraries, Working with C#-centric tooling","Correctness: fewer bugs and less rework, Easy concurrency with async and agents","Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information",
14/04/2015 17:52:07,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","F# books, F# bloggers, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,It's officially endorsed for critical/production areas,Mainstream business & enterprise applications,Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,Windows,"Javascript, Native, Perhaps transpile to Rust","C#, SQL",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,"Not enough real-world code to learn from, Poor tooling, no onsite mentor","Tooling, compatibility, e.g., no razor",I like theory -- I'm not afraid of monads and other abstractions,Tooling,Less than a year,"I wish F# was closer to being Haskell.NET rather than oCaml.NET - type classes, default clean laziness, and just an overall cleaner syntax with fewer alternative syntaxes for doing the same things.",Enterprise development,,"Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,Bring the F# compiler as a service to the same level as C#,"More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 17:53:18,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,Twitter,"Links and instructions from fsharp.org, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,Utilities and tools,Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,"Windows, Mac",Linux,None -- I'm happy with the CLR/Mono,"Javascript, Python",,Learning functional programming in general,Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Computation expressions, Interactive development, Object expressions, Quotations, Units of measure",Don't understand the compiler errors,No buy-in: There is lack of acceptance from other teams,I want to learn functional programming but I don't like academic jargon,,Less than a year,,Enterprise development,,Difficulty in troubleshooting problems,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 18:13:39,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"F# bloggers, StackOverflow chat","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, WinPhone",,C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,"I can't use my knowledge from C# or other imperative languages, Don't understand the compiler errors","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,,,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, The ""piping"" idiom, Units of measure",Stop every other activities in life and only focus on F#.  :-P,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 18:24:35,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","MSDN, Links and instructions from fsharp.org, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Machine learning, Research/Teaching",Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Integration with non-F# libraries, Units of measure",Don't understand the compiler errors,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,,3-4 years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Immutability by default, Type inference",,,,
14/04/2015 18:27:02,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,Twitter,"F# bloggers, Answers to Stack Overflow questions",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Event sourcing,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript",,"Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Integration with non-F# libraries, Quotations, Units of measure",Add a couple of more hours a day. Yes I have kids...,"Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,Haven't really used it yet,,Enterprise development,,Difficulty in troubleshooting problems,Easy concurrency with async and agents,,,,"More material with in-depth tutorials, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 20:05:07,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, Google+, F# bloggers","F# books, F# bloggers, Links mentioned in F# Weekly, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Financial services, Mobile apps, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Commercial products","SQL databases, Event sourcing, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,LLVM,"C, Haskell, Typescript, Delphi (Object Pascal)",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Object-oriented compatibility, Quotations, Static type constraints",None,Training: They are worried about getting non-F# developers up to speed,I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Faster time to market, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, The ""piping"" idiom, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 18:50:14,2-5 years,"No, I don't know much theory",I use it for hobby or side projects,,"F# Weekly, HN, Reddit and other programming news sites","F# books, Links mentioned in F# Weekly",,I don't use F# at work,"Mainstream business & enterprise applications, Mobile apps, Data analysis/statistics",Commercial products,SQL databases,MonoDevelop,Linux,"Linux, iOS, Android, Amazon Web services","LLVM, Native","R, Ruby, Scala",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Quotations","Lack of good tutorials/documentation, Not enough real-world code to learn from","Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,The community and tools are still far too windows-centric. ,Less than two months,,Data or analytics related,,"Less sophisticated tools for refactoring, etc., Cross-platform issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents","Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Type providers",,"More linux compatibility!!! Editors/IDEs, better performance on Mono, a more linux compatible build/deployment system. ","More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 18:59:57,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, Links posted on social media such as Twitter, Personal mentoring",,It's used unofficially,Games,Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, Mac, Linux, iOS, Android, WinPhone",Javascript,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Object expressions, Units of measure",Lack of good tutorials/documentation,"Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, Too Windows-centric: They have concerns over cross-platform issues",I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,"The F# Community is impressive.
Thank you for your support!",Enterprise development,,"Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Efficiency/Performance","Active Patterns, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers","Better tutorials about advanced F# (like monads, async workflows and agents)",More business uses samples about the language.,"More material with in-depth tutorials, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 19:02:45,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","MSDN, F# bloggers, Links mentioned in F# Weekly, Reading F# code written by experts",,It's used unofficially,Utilities and tools,Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,,"C#, C++, Visual Basic",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Changed the way I approach coding problems",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Units of measure,Not enough real-world code to learn from,"Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,"Has to get over being considered a niche language. 

Having to restate signatures twice is annoying.  It would be great if we could find way to have .fs files only and specifically label the portions which should appear as if they were declared in an .fsi file. ",4 or more years,"The lack of type dependency cycles is simultaneously one of my favorite and most hated features.  It keeps catching my mistakes.  

",Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, No dependency cycles, Type inference",,,More material with real-world examples and war stories,
14/04/2015 19:09:46,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,F# bloggers,"MSDN, F# bloggers, Answers to Stack Overflow questions",,I don't use F# at work,"Machine learning, Data analysis/statistics",Open source projects,Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,"Windows, WinPhone, Azure",Javascript,"C, C#, Python",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Speed of development, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Quotations, Type providers, Units of measure",Don't understand the compiler errors,,I like theory -- I'm not afraid of monads and other abstractions,It's hard to make the leap from CLR to crossplatform.,Less than a year,,Student,,"Not being part of the core .NET distribution, Difficulty in troubleshooting problems",,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom",,,More material with in-depth tutorials,
14/04/2015 19:11:41,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,F# Weekly,MSDN,,It's officially endorsed for critical/production areas,"Data analysis/statistics, Text analysis/language parsing",Internal enterprise projects,"SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,"Windows, Azure",,"C, C#, Javascript, R",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Computation expressions, Quotations, Units of measure",Don't understand the compiler errors,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",,,2-3 years,,"Academic, research, or related",,Working with C#-centric tooling,"Correctness: fewer bugs and less rework, Efficiency/Performance, Better for solving complex problems","Agents (MailboxProcessor), Async workflows, Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Type providers",,,,
14/04/2015 19:12:15,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,"I love using F#, but when I was using it three / four years ago I didn't really see much in the way of good documentation, and would have a hard time justifying it's use in production.","HN, Reddit and other programming news sites","Links and instructions from fsharp.org, Answers to Stack Overflow questions",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,"SQL databases, Not doing data centric apps",Visual Studio 2012 or newer,Windows,Windows,"None -- I'm happy with the CLR/Mono, Javascript","C#, C++, Java, PHP",,Having fun again,Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,"Lack of good tutorials/documentation, I can't use my knowledge from C# or other imperative languages, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,Documentation in general.,Less than two months,Please keep up the hard work! I want to see F# become a great and widely-used language someday :),Enterprise development,,Not being part of the core .NET distribution,,Easy integration with other .NET libraries,,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 19:17:25,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,,"Personal mentoring, Structured training/workshops",,It's officially endorsed for critical/production areas,Machine learning,Not applicable. None of my F# code is used by other people,,Visual Studio 2012 or newer,Windows,Windows,,C#,,"Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,Lack of good tutorials/documentation,Training: They are worried about getting non-F# developers up to speed,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Science or related,,,,,,,,
14/04/2015 19:17:50,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, HN, Reddit and other programming news sites","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications",Commercial products,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,"Windows, Azure",Javascript,"C, C#, C++",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Quotations, Type providers, Units of measure","Lack of good tutorials/documentation, Don't understand the compiler errors","No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Easy integration with other .NET libraries, Immutability by default, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 19:23:55,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, #fsharp on slack","MSDN, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts, fsharpforfunandprofit",,It's used unofficially,"Utilities and tools, Text analysis/language parsing","Internal enterprise projects, Open source projects",SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript, Visual Basic",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Static type constraints, Type providers, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from",Training: They are worried about getting non-F# developers up to speed,I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Immutability by default, printf that is type checked, Quotations, The ""piping"" idiom, Type inference, Type providers","Rather than trying to gloss over academic jargon like the dreaded M-word, a way for people with little academic history to learn relevant mathematics and theory would do wonders for the advanced F# topics.","I don't know any way that the F# community can improve this, but in small teams (my team is 3 devs) that cover a wide swath of tech, it's both important and difficult to ensure the bus factor is higher than 1.",More material with in-depth tutorials,"The answers to the question ""How comfortable are you with functional programming in general?"" don't seem to match my experience with F# so far. Pattern matching is one of my favorite parts of the language and I learned it fairly early on, but it's listed as Experienced; piping and higher-order functions took me much longer to start utilizing at all."
14/04/2015 19:22:34,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"F# Weekly, Google+, F# bloggers","F# books, F# bloggers, Reading F# code written by experts",,I don't use F# at work,,,,Visual Studio 2012 or newer,Windows,Windows,LLVM,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor), Units of measure",,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Enterprise development,,"Less sophisticated tools for refactoring, etc.",,"Algebraic types (inc discriminated unions and tuples), Interactive development, Quotations, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
14/04/2015 19:23:09,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"F# Weekly, F# bloggers","MSDN, F# bloggers, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,"Utilities and tools, Custom development/specialist markets, Research/Teaching, Data analysis/statistics, Other",Internal research projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, C++, Java, Javascript, Python, Scheme/CL",,"Conciseness of code (I can see more at a glance), Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Async workflows, Computation expressions, Type providers, Units of measure",,Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,"Two things:
1) The poor support within the VS IDE (compared to C#), especially when compared to commercial tools like ReSharper, is a constant annoyance.
2) The lack of integration of F# async workflows with .NET Tasks makes it difficult to do clean asynch development in a ""natural"" way in F#. I find I never use the native F# features because they don't integrate well with the rest of .NET and they don't perform as well as using the TPL or raw threads directly.
",1-2 years,,"Academic, research, or related",,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Much worse VS support",More productive with fewer developers,"Active Patterns, Easy integration with other .NET libraries, Immutability by default, Object-oriented features (inc. C# compatibility, conciseness), Quotations, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans), More on what's happening ""under the covers""",
14/04/2015 19:27:27,2-5 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Xamarin,"Windows, Mac",,JVM,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Integration with non-F# libraries","Don't understand the compiler errors, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams, Not object oriented enough, can't wrap their head around",I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, No dependency cycles, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 19:35:33,5-10 years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, Google groups, F# bloggers","MSDN, F# books, F# bloggers, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for critical/production areas,"None - Just playing around, Utilities and tools, Games, Mainstream business & enterprise applications, Mobile apps","Commercial products, Open source projects","SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,"Windows, iOS, Android","JVM, Javascript, LLVM, Native","C#, Javascript, PHP",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Computation expressions, Static type constraints",Lack of good tutorials/documentation,"Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,"Documentation, but this is common in open source ecosystems.",3-4 years,,Enterprise development,,"Working with C#-centric tooling, Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Type providers, Units of measure","I don't mind the theory stuff now, however I used to find it an obstruction; providing practical-use examples first helped me learn the language and let me progress into the realm of theory on an as-needed basis.",,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 19:46:27,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, Google groups","F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Personal mentoring, Reading F# code written by experts, Well-structured experimentation",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Financial services, Machine learning, Mainstream business & enterprise applications, Research/Teaching, Data analysis/statistics","Internal enterprise projects, Commercial products, Open source projects","SQL databases, NoSQL database, Event sourcing, Read-only data sources such as feeds, Analytics",Visual Studio 2012 or newer,"Windows, Mac","Windows, Mac","LLVM, Native","C, C#, Erlang, Rust, Scheme/CL, Visual Basic",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Great community, Learning functional programming in general, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),Static type constraints,People fetishizing Haskell's idioms.,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I want to learn functional programming but I don't like academic jargon,Ease-of-development of and overall quality of type providers.,4 or more years,,Financial services or similar,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries,  Awkwardness and/or performance issues when metaprogramming","Domain modelling: making illegal states unrepresentable, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, No dependency cycles, Type inference, Units of measure","Focus on solving problems, including explanations of the pros and cons of various techniques. In other words, ""when"" is as important as ""how"" in the explanation.","Please promote (as much as possible) more success stories that aren't from start-ups (i.e. from established organizations). Also, it'd be nice to have a range of both ""full-stack"" F# and ""polyglot"" success stories.","More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 19:55:21,5-10 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","MSDN, F# books, F# bloggers, Answers to Stack Overflow questions, Personal mentoring",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications, Text analysis/language parsing","Commercial products, Open source projects",Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,,"C#, Powershell, Mathematica",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Async workflows, Computation expressions, Object expressions, Quotations, Static type constraints, Type providers, Units of measure",Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,2-3 years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, Type inference",,,,
14/04/2015 20:03:34,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly","F# books, F# bloggers, Links posted on social media such as Twitter, Reading F# code written by experts",,It's used unofficially,"Machine learning, Research/Teaching, Data analysis/statistics, Text analysis/language parsing",Not applicable. None of my F# code is used by other people,Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Agents (MailboxProcessor),Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams, Large existing codebase in C++/C#",I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,CS education focusing on imperative languages is a major obstacle to uptake. Overworked devs don't see the point in investing time/energy in learning a different paradigm.  ,Science or related,,"Not being part of the core .NET distribution, Working with C#-centric tooling","Correctness: fewer bugs and less rework, Better for solving complex problems","Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
14/04/2015 20:15:29,2-5 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"HN, Reddit and other programming news sites","Answers to Stack Overflow questions, http://fsharpforfunandprofit.com",,It's used unofficially,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript, Ruby",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Quotations, Units of measure",Not enough real-world code to learn from,"Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.",,"Active Patterns, Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 20:28:00,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,Twitter,"F# books, F# bloggers, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,Algorithm-heavy business applications (non-financial),Commercial products,SQL databases,Visual Studio 2012 or newer,"Windows, Mac",Azure,None -- I'm happy with the CLR/Mono,"C++, Go, Python",,"Learning functional programming in general, practical immutability",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,speed of compiler,Nothing. Everyone loves it.,I'm willing to learn advanced concepts but only if they are relevant and practical,"Needs more endoresment by microsoft. Improve the tooling, esp shipping more official project templates. ",4 or more years,,independent developer/analyst,,Not being part of the core .NET distribution,"Domain modelling: making illegal states unrepresentable, Better for solving complex problems","Immutability by default, Units of measure",,"more diversity, less academics.",More material with real-world examples and war stories,
14/04/2015 20:29:07,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, HN, Reddit and other programming news sites","F# books, F# bloggers, Answers to Stack Overflow questions, Personal mentoring, Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,Utilities and tools,Open source projects,SQL databases,Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Javascript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Integration with non-F# libraries,"Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Financial services or similar,,"Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., folders!!","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Async workflows, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",Provide perspectives from different programming backgrounds,Nothing. It's a culture problem at my current work.,"More material with in-depth tutorials, More material with real-world examples and war stories",
14/04/2015 20:29:13,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"F# Weekly, F# bloggers","MSDN, F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions",,It's used unofficially,"None - Just playing around, Games",Not applicable. None of my F# code is used by other people,Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Having fun again, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows, Quotations, Units of measure","Don't understand the compiler errors, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,Enterprise development,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Faster PoC, then convert to C#","Backtick naming, Easy integration with other .NET libraries, Interactive development, No dependency cycles, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 20:31:31,5-10 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","MSDN, F# bloggers",,It's used unofficially,"Utilities and tools, Research/Teaching",Not applicable. None of my F# code is used by other people,Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Object expressions",,No buy-in: There is lack of acceptance from other teams,I like theory -- I'm not afraid of monads and other abstractions,Tooling.,Less than a year,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers","I would like direction for creating a new idiomatic F# project that can be easily used by others a la F# scaffold project.
Direction for F# application. Direction for F# library design.",I do not know of anything off hand.,"More material with in-depth tutorials, More material with real-world examples and war stories","The question: ""What are your primary programming languages (in addition to F#)"" could be changed so that it does not assume F# is a primary programming language."
14/04/2015 20:54:22,2-5 years,"Yes, I enjoy computer science and mathematics",Just tinkering,My current job and personal projects don't lend themselves to F# development (mostly client-side web projects).,"Twitter, F# Weekly, HN, Reddit and other programming news sites","MSDN, F# books, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,"Javascript, LLVM","C#, Java, Javascript, Typescript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Active Patterns, Agents (MailboxProcessor), Quotations, Static type constraints",I can't use my knowledge from C# or other imperative languages,Nothing. Everyone loves it.,I'm willing to learn advanced concepts but only if they are relevant and practical,"The weird relationship/association with Microsoft. Even though it's a fully open source project, many people still assume it's an in-house Microsoft product to the degree of VB and C#. It's sort of the worst of all possible worlds: doesn't have a huge team at MS, but doesn't have the community swagger of Rust/etc.",2-3 years,,Enterprise development,,,,"Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 21:05:38,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, Google groups, F# bloggers, StackOverflow chat, Slack Chat","MSDN, F# books, F# bloggers, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Mainstream business & enterprise applications, Data analysis/statistics","Internal enterprise projects, Commercial products, Open source projects",Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,"JVM, LLVM, Native","C, C#, C++, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),Active Patterns,Lack of good tutorials/documentation,Nothing. Everyone loves it.,I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Science or related,,"Not being part of the core .NET distribution, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Easy concurrency with async and agents, Better for solving complex problems","Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, No dependency cycles, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 21:10:53,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"F# bloggers, fsharp@microsoft.com","F# books, F# bloggers, Answers to Stack Overflow questions",,It's used unofficially,"Utilities and tools, Text analysis/language parsing","Internal enterprise projects, Open source projects",Not doing data centric apps,Visual Studio 2012 or newer,"Windows, Mac","Windows, Mac",None -- I'm happy with the CLR/Mono,"C#, Ruby, Smalltalk",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Async workflows, Object expressions, Quotations, Type providers, Units of measure",Don't understand the compiler errors,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,"Right now, I'd like to see all the wrinkles and warts in the Visual Studio experience dealt with. Like not being able to add folders to F# projects, or having to edit the registry to get various bits to work.",Less than a year,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.",Faster time to market,"Algebraic types (inc discriminated unions and tuples), Backtick naming, Immutability by default, Interactive development, No dependency cycles, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,"My workplace is Microsoft, and yet...","More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 21:14:12,5-10 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","F# books, F# bloggers, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,It's officially endorsed for critical/production areas,,Commercial products,"SQL databases, Event sourcing",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,,,I like theory -- I'm not afraid of monads and other abstractions,,Less than two months,,Enterprise development,,Difficulty in troubleshooting problems,,"Async workflows, Easy integration with other .NET libraries, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,,
14/04/2015 21:53:04,5-10 years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, HN, Reddit and other programming news sites, F# bloggers","Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts, fsharpforfunandprofit.com is awesome",,I don't use F# at work,"None - Just playing around, Utilities and tools","Internal enterprise projects, Commercial products","Read-only data sources such as feeds, Not doing data centric apps",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Java, Javascript",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Agents (MailboxProcessor),Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,"Development tools, and more focus on how to build and maintain large systems written in f# ",1-2 years,,Enterprise development,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Lack of tools like resharper. ",,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, Object expressions, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More podcasts and other audio-only material",
14/04/2015 21:58:05,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Google groups, F# bloggers","MSDN, Links and instructions from fsharp.org, F# bloggers, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,Mainstream business & enterprise applications,Commercial products,"NoSQL database, Event sourcing",Visual Studio 2012 or newer,Windows,"Windows, Azure",None -- I'm happy with the CLR/Mono,"C#, Javascript, Visual Basic",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Quotations, Static type constraints, Type providers, Units of measure",Don't understand the compiler errors,"Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,"Compile time and project organization mainly. Compile times could use a bit of improvement in F# to begin with. But when you have a lot of projects, it slows down drastically. I think the strict ordering in F# is actually a benefit that causes you to be more organized, but there is not enough tooling to reflect that organization sufficiently. At first I tried to increase organization by making more projects, but the compile times got silly. Most people are asking for folder-based organization, but I would love a simple divider line in the project file list with a label where I can put informational text like ""domain"" or ""helpers"". That way I can section off the code files in stacks with the label at the top. I guess that's more of a VS tooling thing. It was also a real shock coming from C#, that the compiler doesn't notice the changes I make in dependent assemblies until I manually recompile that assembly. I still get regularly annoyed by this. Otherwise, after some initial hurdles, I have fallen in love with the language. It has really brought to bear a lot of professional development for me through learning functional paradigms.",Less than a year,"I would like to see some of the language conveniences to have more serious representation in the CLR. I'm thinking of type abbreviations and units of measure. I was trying to use type abbreviations as basically function signatures to define dependencies (instead of using the OO version: interfaces). However, once put into a dictionary of string, obj, they are impossible to get back out unboxed to the same type. I ended up working around this by putting it in a record type. E.g. instead of type asdf = string -> int -> string, I had to do type asdf = { asdf: string -> int -> string } which can actually be unboxed. But I don't really need the record type, only the function signature as the interface which a dependency must conform to.",Enterprise development,,"Lack of F# friendly libraries, Working with C#-centric tooling","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents, Better for solving complex problems","Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Immutability by default, No dependency cycles, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom","Making a lot of it practical rather than relying on the elegant theories behind it. Scary words (algebraic types, monads, monoids, etc) are going to discourage your average developer. http://fsharpforfunandprofit.com/ has been an amazing site for exactly the right approach to reach outside of just academia.","I don't think there is anything that can be done about people being scared of using ""new"" things. Acceptance will come with time and history proving it viable.","More material with short ""cookbook"" style information, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 22:02:26,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"F# Weekly, Google+, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications, Mobile apps, Text analysis/language parsing",Internal enterprise projects,,Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux",Javascript,C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Interactive development, Units of measure","Unpleasant interactions with the community, Functional Fundamentalist like to flaunt their fewer-numbers elitist status and make us OO (majority) feel like we are dumb",,I like theory -- I'm not afraid of monads and other abstractions,,3-4 years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, More productive with fewer developers, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,,
14/04/2015 22:04:36,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,F# bloggers,"MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,It's used unofficially,Custom development/specialist markets,Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,Windows,"None -- I'm happy with the CLR/Mono, JVM","C#, Javascript",,"Better domain modelling with records and unions, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,,Efficiency/Performance,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, No dependency cycles, Type providers",,,"More material with in-depth tutorials, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 22:11:11,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly","F# books, F# bloggers, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,It's used unofficially,Utilities and tools,Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,"Windows, Linux","Windows, Mac, Linux",Native,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Async workflows, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More podcasts and other audio-only material",
14/04/2015 22:17:53,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"F# Weekly, F# bloggers","F# books, F# bloggers, Links mentioned in F# Weekly",,It's used unofficially,Research/Teaching,Internal enterprise projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,"LLVM, Native","C#, C++, Java, Python, Scala",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Interactive development,,No buy-in: There is lack of acceptance from other teams,I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Science or related,,"Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents","Easy integration with other .NET libraries, The ""piping"" idiom, Type inference, Units of measure",,,"More material with in-depth tutorials, More podcasts and other audio-only material",
14/04/2015 22:20:35,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,It feels natural and makes me happy.,"Twitter, F# bloggers","F# books, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Custom development/specialist markets, Data analysis/statistics","Commercial products, Open source projects",NoSQL database,Xamarin,"Windows, Mac, Linux","Windows, Linux",None -- I'm happy with the CLR/Mono,"Clojure, Rust, Scala",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Having fun again, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Units of measure,"Lack of good tutorials/documentation, Don't understand the compiler errors, Not enough real-world code to learn from",Nothing. Everyone loves it.,I'm willing to learn advanced concepts but only if they are relevant and practical,"The lack of a really good BDD framework, like ScalaTest and Spock.",1-2 years,,Data or analytics related,,"Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Cross-platform issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems, It makes the devs happy","Agents (MailboxProcessor), Easy integration with other .NET libraries, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",A great IDE from JetBrains or plugin for MonoDevelop would be brilliant. ,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos",
14/04/2015 22:30:54,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"HN, Reddit and other programming news sites, StackOverflow chat","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Answers to Stack Overflow questions, Personal mentoring, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Games, Data analysis/statistics","Internal enterprise projects, Open source projects","SQL databases, NoSQL database, Analytics",MonoDevelop,Linux,Linux,None -- I'm happy with the CLR/Mono,Erlang,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Object-oriented compatibility, Units of measure",Not enough real-world code to learn from,Nothing. Everyone loves it.,I want to learn functional programming but I don't like academic jargon,,Less than two months,,Data or analytics related,,"Cross-platform issues, Monodevelop sucks","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Easy integration with other .NET libraries",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 22:33:24,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"Twitter, F# Weekly, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books",,It's officially endorsed for non-critical/non-production code,Research/Teaching,Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, Azure",None -- I'm happy with the CLR/Mono,"C#, C++",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Computation expressions, Quotations","Don't understand the compiler errors, Not enough real-world code to learn from",Training: They are worried about getting non-F# developers up to speed,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,"Academic, research, or related",,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",Correctness: fewer bugs and less rework,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
14/04/2015 22:39:39,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"Twitter, F# Weekly, Google+, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,It's used unofficially,"Machine learning, Research/Teaching, Data analysis/statistics",Not applicable. None of my F# code is used by other people,Analytics,Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux, Android, Amazon Web services","LLVM, Native","C++, Python, R, Ruby",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Object expressions, Quotations","Lack of good tutorials/documentation, Not enough real-world code to learn from","Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft",I'm willing to learn advanced concepts but only if they are relevant and practical,,2-3 years,,Data or analytics related,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Difficulty in troubleshooting problems, less documentation and examples for libraries","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems, A lot of funs","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Type providers, Units of measure",A lot of simple and easy to understand examples,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",little bit long
14/04/2015 22:45:57,5-10 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"HN, Reddit and other programming news sites",F# books,,It's officially endorsed for critical/production areas,"Utilities and tools, Financial services, Data analysis/statistics","Internal enterprise projects, Commercial products, Open source projects",SQL databases,Visual Studio 2012 or newer,"Windows, Linux",Windows,Native,"C#, Clojure, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Async workflows, Interactive development, Object-oriented compatibility, Quotations, Static type constraints, Type providers, Units of measure",Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, fear it's not MS endorsed and will go the way of VB.NET",I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,"Lack of good wrappers for non-F# libraries, Terrible REPL experience compared to Clojure.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, No dependency cycles",,,More material with in-depth tutorials,
14/04/2015 22:47:05,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly","MSDN, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions",,,,,,Visual Studio 2012 or newer,Windows,,,C#,,"Better domain modelling with records and unions, Great community, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Computation expressions, Object expressions, Object-oriented compatibility, Static type constraints",,,,,Less than a year,,Enterprise development,,,,"Easy integration with other .NET libraries, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,,
14/04/2015 22:58:47,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"Twitter, F# Weekly, F# bloggers","F# books, F# bloggers",,It's officially endorsed for critical/production areas,"Games, Machine learning, Data analysis/statistics, Text analysis/language parsing",Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,Windows,"JVM, Native",C#,,"Correctness (no nulls, it works first time), Having fun again, Beauty",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Units of measure",,"No buy-in: There is lack of acceptance from other teams, Some team members are hesitant to learn it and do not see the benefit.",I'm willing to learn advanced concepts but only if they are relevant and practical,"I find writing F# to be bliss. At the same time, I find reading other people's code (and even my own, months later) to be harder than reading C#.

As programmer's we often spend more time reading code than writing code. 

- We need to make navigating code very easier in F#, especially when dealing with other C# libraries or projects.

- Ideas such as literate programming should be embedded in the language/ tooling in order to make it easier/more pleasant for other people, especially newbies, to understand.",4 or more years,,"Academic, research, or related",,"Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, More productive with fewer developers","Algebraic types (inc discriminated unions and tuples), Computation expressions, The ""piping"" idiom, Type inference, Type providers",,,How to structure a large project,
14/04/2015 23:04:28,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly","F# books, F# bloggers, Links mentioned in F# Weekly",,It's used unofficially,"Utilities and tools, Machine learning",Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Scheme/CL",,"Great community, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Object expressions, Object-oriented compatibility, Quotations, Static type constraints",Don't understand the compiler errors,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,C# is good enough that most .net developers will never feel the need to try it,1-2 years,,Enterprise development,,"Not being part of the core .NET distribution, Lack of F# friendly libraries",more fun,"Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 23:05:45,2-5 years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,F# bloggers,"MSDN, F# books, F# bloggers, Answers to Stack Overflow questions",,I don't use F# at work,"Utilities and tools, Algorithm-heavy business applications (non-financial), Machine learning, Data analysis/statistics",Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,Windows,,,"C#, Elixir, Python",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Computation expressions, Integration with non-F# libraries, Object-oriented compatibility, Static type constraints, Units of measure",no proper F# editor for linux,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Too Windows-centric: They have concerns over cross-platform issues",I'm willing to learn advanced concepts but only if they are relevant and practical,"- Poor support in linux (incredible difficult to install in linux)
- No Visual Studio in linux (MonoDevelop is not mature, and I don't like emacs)",2-3 years,,Student,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Cross-platform issues",,"Algebraic types (inc discriminated unions and tuples), Async workflows, Immutability by default, Object expressions, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
14/04/2015 23:52:45,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, Google groups","F# books, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Financial services, Mainstream business & enterprise applications",Internal enterprise projects,"Read-only data sources such as feeds, Analytics",Vim,"Windows, Mac",Windows,"JVM, LLVM","C#, Clojure, Erlang",,"Correctness (no nulls, it works first time), Learning functional programming in general, Expression orientated programming (leads to clearer code)",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Object expressions,,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Enterprise development,,"Not being part of the core .NET distribution, Installation issues, specifically that build agents (that currently compile C#) need extra installs to enable F# builds. To be fair, this is not just a problem for F# - Windows build agents for .Net are generally a pain to setup (""just stick VS on it"" is not great).","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Active Patterns, Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, No dependency cycles, The ""piping"" idiom, Type inference","For myself and others that I have introduced to F#, focusing on how F# nudges you in the right direction to produce code that is usually simpler and clearer resulting in easier maintainance is the big draw. Producing code bases that can remain adaptable and reasonable is very important, and C#/Java do nothing to help in this respect - we need a language that will discourage bad practices as F# does. This is perhaps not a specific thing that can make learning it easier but it helps to know that there are tangible benefits to learning F# and that some of the seemingly awkward aspects of F# (for programmers used to C#) are in fact warning signs that when heeded will produce better software. ","Not much, I suspect it will require a critical mass of champions within the company, but any increased visibility of F# will help - especially if it is in areas that non language-curious programmers will notice.",More material with in-depth tutorials,
14/04/2015 23:55:33,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, Google+, Google groups, HN, Reddit and other programming news sites, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,It's used unofficially,Utilities and tools,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,"Windows, Mac, Linux",,"JVM, Javascript, LLVM, Native","C#, Objective-C",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Quotations, Static type constraints, Type providers, Units of measure",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I like theory -- I'm not afraid of monads and other abstractions,UI tooling,2-3 years,,Enterprise development,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, Interactive development, No dependency cycles, Object expressions, printf that is type checked, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",More fully implemented functional architecture examples.,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos",
15/04/2015 00:54:39,2-5 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,F# bloggers,"Links and instructions from fsharp.org, F# books, F# bloggers",,It's officially endorsed for critical/production areas,"Games, Mobile apps",Internal enterprise projects,"NoSQL database, Event sourcing",Xamarin,Mac,iOS,JVM,"C#, Java, Javascript, PHP",,"Conciseness of code (I can see more at a glance), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Quotations, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from",Training: They are worried about getting non-F# developers up to speed,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,"Not being part of the core .NET distribution, Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Easy concurrency with async and agents, Better for solving complex problems","Computation expressions, Immutability by default, The ""piping"" idiom",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
15/04/2015 00:59:06,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"F# Weekly, F# bloggers","F# books, F# bloggers, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,Mobile apps,Commercial products,Not doing data centric apps,Xamarin,Mac,"iOS, Android",We only use dotnet on Android/iOS,"Java, Scala",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Interactive development, Quotations, Type providers, Units of measure",,Poor integration with Android and iOS toolkits; it's easier to just use C# for some bits,I like theory -- I'm not afraid of monads and other abstractions,It's not enough like Scala :-).,4 or more years,,Enterprise development,,"Basic tool stuff can be hard; for example, lack of PCL support for Android/iOS (not refactoring kinds of tools, couldn't care less about those)","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, The ""piping"" idiom",Hard for me to say; I've been using it too long.,,More material with real-world examples and war stories,
15/04/2015 01:05:25,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,,"MSDN, Links and instructions from fsharp.org, F# books, F# bloggers",,It's used unofficially,"None - Just playing around, Utilities and tools",Not applicable. None of my F# code is used by other people,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C, C#, C++, Javascript",,"Having fun again, Learning functional programming in general, Speed of development","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",Object-oriented compatibility,"Lack of good tutorials/documentation, I can't use my knowledge from C# or other imperative languages","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I'm willing to learn advanced concepts but only if they are relevant and practical,More complete examples ,Less than a year,,Enterprise development,,"Working with C#-centric tooling, Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Faster time to market, Efficiency/Performance","Active Patterns, Immutability by default, The ""piping"" idiom",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More interactive tutorials (e.g. like the F# Koans)",
15/04/2015 02:08:16,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"F# Weekly, HN, Reddit and other programming news sites",Books,,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Financial services, Data analysis/statistics",Internal enterprise projects,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),Agents (MailboxProcessor),,Nothing. Everyone loves it.,I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Financial services or similar,,Performance issues,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Active Patterns, Easy integration with other .NET libraries, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,More material with in-depth tutorials,
15/04/2015 02:35:33,2-5 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"F# Weekly, HN, Reddit and other programming news sites","MSDN, F# bloggers, Answers to Stack Overflow questions",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Machine learning, Text analysis/language parsing","Internal enterprise projects, Open source projects",,Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux",LLVM,"C#, C++, Haskell, Scala, Typescript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,"Installation process, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,Less than two months,,Enterprise development,,"Less sophisticated tools for refactoring, etc., Performance issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More short ""live coding"" videos, More podcasts and other audio-only material",
15/04/2015 03:51:12,10 or more years,"No, I don't know much theory",Just tinkering,,"Twitter, F# Weekly, Google groups, F# bloggers","F# books, F# bloggers",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Great community, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Enterprise development,,Working with C#-centric tooling,,"Algebraic types (inc discriminated unions and tuples), Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
15/04/2015 05:42:33,10 or more years,"Yes, I enjoy computer science and mathematics",art project,,"Twitter, F# Weekly, F# bloggers","F# books, F# bloggers, Personal mentoring, Reading F# code written by experts, Jon Harrop's FSharp Journal",,,Other,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,"LLVM, OpenCL",Just F#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Functional but can be tweaked to get high performance, Life long learning",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Object-oriented compatibility,prior language baggage ,,I like theory -- I'm not afraid of monads and other abstractions,"It's the leading edge.

",4 or more years,"Don Syme knows technology transfer.

From R&D to open source ... Don and the F# community have hit the mark.

F# is a mature, open source, cross-platform, functional-first programming language.

FSharp has a bright future.",Artist,,,,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure","Just look at Jon Harrop's body of work.
It's worth it.

Jon has the greatest breadth and depth ....
From high level theory to low level performance considerations.
Clear and succinct, like F#.

He knows his stuff, and tells it like it is.

Reading his articles and running the code has been F#UN!

",,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans), Conal Elliot presentations",It's OK.
15/04/2015 06:18:58,5-10 years,,I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","F# bloggers, Links mentioned in F# Weekly, fsharpforfunandprofit.com",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Machine learning, Data analysis/statistics",Internal enterprise projects,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,"Windows, Linux, Azure","JVM, Javascript, LLVM","C#, Typescript",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Great community, Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Quotations, Static type constraints, Units of measure",Don't understand the compiler errors,"Hiring: They worry about not being able to find F# developers, Fad: They have concerns over long term language viability, Too Windows-centric: They have concerns over cross-platform issues",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,"Not being part of the core .NET distribution, Less sophisticated tools for refactoring, etc., Performance issues, Cross-platform issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
15/04/2015 06:47:57,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# bloggers, StackOverflow chat","MSDN, Links and instructions from fsharp.org, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,"None - Just playing around, Utilities and tools, Games, Text analysis/language parsing, Other",Open source projects,SQL databases,Vim,"Windows, Mac, Linux","Windows, Mac, Linux","None -- I'm happy with the CLR/Mono, JVM","C#, C++, Perl, Python, Scheme/CL, Swift",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Object expressions, Quotations",Not enough real-world code to learn from,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,"Inline should be more powerful: The `when` cases in inline should be available outside of standard library.
Value restriction problem, which doesn't exist in Haskell.
Not enough features to save me from typing out a lambda: Java 8 has Type::method, Swift has {$1 + $2} and Scala has (.field)
Some Haskell functions like curry, uncurry, flip should be in F# standard library
",4 or more years,,Student,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, Interactive development, No dependency cycles, printf that is type checked, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos",
15/04/2015 06:52:57,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,I need a typesafe scripting language but F# lacks of strong and confortable file manuipuraltion module and integration with command execution. Also I'd be have to generate CSV as in PowerShell on the fly.,F# Weekly,"MSDN, Links and instructions from fsharp.org, F# books",,It's used unofficially,Utilities and tools,Internal enterprise projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, X++",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Agents (MailboxProcessor), Async workflows, Object expressions, Quotations, Type providers","I can't use my knowledge from C# or other imperative languages, Not enough real-world code to learn from",,I'm willing to learn advanced concepts but only if they are relevant and practical,,I was using F# but have stopped,,Enterprise development,,Lack of F# friendly libraries,Correctness: fewer bugs and less rework,"Algebraic types (inc discriminated unions and tuples), Backtick naming, printf that is type checked, The ""piping"" idiom, Type inference","Add more instructions how to switch from tryfsharp.org to VS. For example how to get type providers working there (where to get them, etc).",,"More material with in-depth tutorials, More material with real-world examples and war stories",
15/04/2015 07:33:47,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"Twitter, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, C++",,"Great community, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Agents (MailboxProcessor), Async workflows, Computation expressions, Quotations, Type providers",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I want to learn functional programming but I don't like academic jargon,"Needs more ""outreach"" type stuff to developers coming from C# / java background.

I think it's easy for the F# community to to think its obvious how beneficial the language is as they already have experience with it and can see the advantages.

But when I talk to other developers at work, who are all very good, they either
a) have never heard of it
b) think it's just for mathematical applications
c) think no one uses it and Microsoft will drop it as they never hear about it from Microsoft.
d) can't see any advantage in using it. This might be because to see the advantages for the unique features you have to get over the different syntax hurdle - which puts many people off even looking.",Haven't really used it yet,,Financial services or similar,,,,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, No dependency cycles, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
15/04/2015 07:47:51,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,the notion that c# will adopt more functional style concepts,F# bloggers,"MSDN, F# books, Links posted on social media such as Twitter, Videos (e.g. Community for F#)",,I don't use F# at work,"None - Just playing around, Other",Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript, Typescript",,"Correctness (no nulls, it works first time), Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Computation expressions, Object-oriented compatibility",I can't use my knowledge from C# or other imperative languages,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Fad: They have concerns over long term language viability, Too Windows-centric: They have concerns over cross-platform issues",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Enterprise development,,"Working with C#-centric tooling, Performance issues",Easy concurrency with async and agents,"Immutability by default, Type providers, Units of measure",see above,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos",
15/04/2015 08:07:35,5-10 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# bloggers","MSDN, Links and instructions from fsharp.org, F# bloggers, Links posted on social media such as Twitter, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for critical/production areas,Text analysis/language parsing,Internal enterprise projects,Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Java, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows, Object expressions, Object-oriented compatibility","I can't use my knowledge from C# or other imperative languages, Don't understand the compiler errors, Better IDE support","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,"Compared to languages like C# and Java, you don't get enough help from the IDE, especially for refactoring. Compile errors are sometimes quite hard to understand.
",Less than a year,,Enterprise development,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Active Patterns, Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
15/04/2015 08:36:46,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,F# bloggers,"MSDN, F# books, F# bloggers, www.fsharpforfunandprofit.com",,It's officially endorsed for critical/production areas,Data analysis/statistics,Commercial products,SQL databases,Visual Studio 2012 or newer,Windows,Windows,,"C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Object expressions, Type providers, Units of measure",Not enough real-world code to learn from,Nothing. Everyone loves it.,I'm willing to learn advanced concepts but only if they are relevant and practical,far too easy to abuse pattern matching and have poor modularity in your code,1-2 years,,Enterprise development,,Lack of F# friendly libraries,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Agents (MailboxProcessor), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, The ""piping"" idiom, Type inference",,,More material with real-world examples and war stories,
15/04/2015 09:06:28,1-2 years,"No, I don't know much theory",I use it for student work,,"Twitter, F# Weekly, HN, Reddit and other programming news sites","F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Practice",,I don't use F# at work,Mainstream business & enterprise applications,"Not applicable. None of my F# code is used by other people, Current project will be open source, but I'm only just learning","NoSQL database, Event sourcing",Visual Studio 2012 or newer,"Windows, Linux",Linux,None -- I'm happy with the CLR/Mono,"C#, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Learning functional programming in general, Full access to .NET libraries",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Async workflows, Computation expressions, Quotations, Type providers",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I'm willing to learn advanced concepts but only if they are relevant and practical,"Microsoft. They only talk about F# as being good in very specific domains like finance, and I bet many businesses worry that F# might go the way of Silverlight. I wish Microsoft would beat the drums on how F# is open source and actively supported, and useful for general purpose programming.

It is also unclear to me what situation is like on Mono. Is it really 100% compatible? What is the performance like on Mono? I wish Mono was officially a first-class citizen (official as in directly supported by Microsoft) . ",Less than two months,F# is awesome,Student,,"Less sophisticated tools for refactoring, etc.",,"Algebraic types (inc discriminated unions and tuples), Backtick naming, Easy integration with other .NET libraries, Immutability by default, No dependency cycles, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, Type inference, Actors from Akka.NET","Not enough in-depth tutorials focused at those who are new to functional programming. Most only touch on the very basics but don't go in depth explaining the concepts - by far the best blog I've found is Scott Wlaschin's, I'd like to see more of material of that kind. 

Also, I don't know for sure how to structure my F# application. How do I transition from classic three-layer UI / Model / DataAccess applications? What do I do about state in the domain model? More focus on practical topics like that (instead of more monad analogies) would be nice.","Companies who use F# should be willing to talk about it openly and truthfully, so companies looking to adopt it will have a better feel for the strengths and weaknesses of F# - they are afraid of unknown unknowns.

Articles like this: http://simontylercousins.net/does-the-language-you-use-make-a-difference-revisited/","More material with in-depth tutorials, More material with real-world examples and war stories, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans), Petabridge's Akka.NET bootcamp in F#, Scott Wlaschins book on F#",
15/04/2015 09:22:46,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly",,It's officially endorsed for critical/production areas,Financial services,Commercial products,"SQL databases, Analytics",Visual Studio 2012 or newer,Windows,Windows,"Javascript, Native","C#, R",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Units of measure",,Training: They are worried about getting non-F# developers up to speed,I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Financial services or similar,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Efficiency/Performance, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,More material with real-world examples and war stories,
15/04/2015 09:23:23,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","F# books, F# bloggers",,It's officially endorsed for critical/production areas,"Financial services, Data analysis/statistics",Internal enterprise projects,"SQL databases, NoSQL database, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Quotations, Type providers, Units of measure",,Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,"1) Lagging behind Ocaml, Haskell and even the atrocious Scala in terms of abstraction (higher kinds, type classes, ...), and absolutely not any stated plans to improve in this domain. This corroborates another problem which is a lack of serious commitment from MS, one of the manifestations of which precisely is the 'frozen' state of the core language (nothing significant since type providers).

2) Lack of a comprehensive, efficient and mostly functional scientific computing stack.",4 or more years,,Financial services or similar,,Lack of F# friendly libraries,"Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Async workflows, Interactive development, The ""piping"" idiom, Type inference",,,More material with real-world examples and war stories,
15/04/2015 09:42:22,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"F# Weekly, HN, Reddit and other programming news sites","F# bloggers, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,It's used unofficially,"Utilities and tools, Algorithm-heavy business applications (non-financial)",Internal enterprise projects,Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Typescript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Computation expressions, Quotations",Tooling in VS,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,"Visual Studio integration, it needs to be on par with C# integration.",Less than a year,,Enterprise development,,Working with C#-centric tooling,"Correctness: fewer bugs and less rework, Efficiency/Performance, Easy concurrency with async and agents","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos",
15/04/2015 11:05:40,5-10 years,"No, I don't know much theory",I use it at work or for other commercial uses,,F# bloggers,"MSDN, F# bloggers, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Mainstream business & enterprise applications, Text analysis/language parsing",Internal enterprise projects,Event sourcing,Visual Studio 2012 or newer,"Windows, Mac","Windows, Azure",Javascript,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows, Units of measure",Not enough real-world code to learn from,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,Lack of F# friendly libraries,Correctness: fewer bugs and less rework,"Immutability by default, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, Type inference, Type providers",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
15/04/2015 11:11:26,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's used unofficially,"Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications, Mobile apps, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Open source projects","SQL databases, NoSQL database, Analytics",Visual Studio 2012 or newer,"Windows, Mac, Linux","Windows, Mac, Linux, iOS, Android, WinPhone, Azure, Amazon Web services","Javascript, LLVM, Native","C#, Scala, Swift",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),Units of measure,Add fun ___ -> can be tiring a shorter syntax in some simple cases e.g. like Scala _ placeholder would be nice,"Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with real-world examples and war stories, More podcasts and other audio-only material",
15/04/2015 11:57:42,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,F# Weekly,"F# books, Answers to Stack Overflow questions, Personal mentoring",,It's officially endorsed for non-critical/non-production code,"Machine learning, Data analysis/statistics",Internal enterprise projects,,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Computation expressions, Object expressions, Quotations, Type providers",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams, Pushback from C# developers who are unwilling to learn",I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Data or analytics related,,"Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Visual Studio does not work seemlessly across C#/F# boundaries. For example, GoToDefinition is broken (it worked in VS2010)","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Units of measure",,"More war stories from inside enterprises where F# is used for critical production work. Preferrably in applications that are traditionally handled by C#, and don't smell too much of ""science"". I hear too often ""F# is just for scientists, not for REAL devs, REAL applications""","More material with real-world examples and war stories, More short ""live coding"" videos",
15/04/2015 11:58:42,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","MSDN, F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, F# For fun and profit",,It's officially endorsed for critical/production areas,"Financial services, Data analysis/statistics",Internal enterprise projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows, Static type constraints, Type providers, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Financial services or similar,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Performance issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Backtick naming, Computation expressions, Immutability by default, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
15/04/2015 12:04:30,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,,"F# books, F# bloggers",,It's officially endorsed for critical/production areas,"Research/Teaching, Other",Open source projects,,Visual Studio 2012 or newer,Windows,Windows,Native,"C, C++, Ocaml/SML",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Active Patterns, Agents (MailboxProcessor), Object expressions, Quotations",,"Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,"Academic, research, or related",,,"Correctness: fewer bugs and less rework, More productive with fewer developers","Algebraic types (inc discriminated unions and tuples), Immutability by default, Type inference, Units of measure",,,"More material with short ""cookbook"" style information",
15/04/2015 12:07:33,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Structured training/workshops",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Machine learning, Text analysis/language parsing","Internal enterprise projects, Open source projects","SQL databases, NoSQL database, Analytics",Visual Studio 2012 or newer,Windows,"Windows, Azure",,"C#, C++",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor), Units of measure","Installation process, Not enough real-world code to learn from, dev tools that work properly just as for C#",,I'm willing to learn advanced concepts but only if they are relevant and practical,"tooling support has to improve, specially for Visual Studio. 

Videos/Tutorials introducing how to start coding in F# ( How you approach problems, setting up your solutions, projects. It's different from how you start coding in C#). i.e. REPL etc.

It's cool to run everything on CLI on the local machine, but how do you actually deploy to cloud/ other servers etc..
",2-3 years,,Science or related,,"Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Async workflows, Computation expressions, Immutability by default, Interactive development, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, Type inference, Type providers","There are lot of outdated information, specially when trying to get a library working for my project. I personally think this slows down adoption. Incorrect outdated material must be removed - not trivial but it's worth coming up with a strategy to combat this.",,"More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos",
15/04/2015 12:09:59,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,F# Weekly,"MSDN, Links and instructions from fsharp.org, F# books, Answers to Stack Overflow questions, Structured training/workshops, Doing it regularly",,It's used unofficially,"Utilities and tools, Machine learning, Research/Teaching, Data analysis/statistics, Text analysis/language parsing",Internal enterprise projects,"Read-only data sources such as feeds, Analytics, Data integration and EAI",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C, C#, Ocaml/SML, Perl",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Units of measure,Don't understand the compiler errors,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Nothing. Everyone loves it., Alternatives with even more support/entrenchment in the major custom tooling environments",,"Occasional opaqueness in interactions between imperative data structures from .Net libraries and lazy evaluation.

There are some operations that can be performed with relational operations among large data streams that I haven't yet found good alternatives for with F#. Combining type providers with such operations would be neat.",4 or more years,"F# makes me more productive, and I have more fun programming. I can refactor blocks of code quickly and safely. There's a good community that's supportive and knowledgeable.","Research, science, and data analytics",,Working with C#-centric tooling,"Correctness: fewer bugs and less rework, More productive with fewer developers, Efficiency/Performance","Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Interactive development, printf that is type checked, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
15/04/2015 12:18:01,5-10 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly","Answers to Stack Overflow questions, FSarpForFunAndProfit  + Jon Harrop's writings",,,"Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Data analysis/statistics",Not applicable. None of my F# code is used by other people,,Visual Studio 2012 or newer,Windows,Windows,,Python,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Computation expressions, Object expressions, Quotations",,Training: They are worried about getting non-F# developers up to speed,I'm willing to learn advanced concepts but only if they are relevant and practical,,2-3 years,,Data or analytics related,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Efficiency/Performance, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, printf that is type checked, The ""piping"" idiom, Type inference","Websites schould use formated code, it is much easier to read.
(http://tpetricek.github.io/FSharp.Formatting/)",,"More material with in-depth tutorials, More material with real-world examples and war stories, More podcasts and other audio-only material",
15/04/2015 12:46:28,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,F# Weekly,"F# books, F# bloggers, Links mentioned in F# Weekly, Reading F# code written by experts, fsharpforfunandprofit.com",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,,Visual Studio 2012 or newer,"Windows, Mac","Windows, Mac",JVM,"C#, Java, Javascript",,"Conciseness of code (I can see more at a glance), Having fun again","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,"Lack of good tutorials/documentation, Not enough real-world code to learn from, subpar ide support on MAC OSX",f# is not come into focus yet,I like theory -- I'm not afraid of monads and other abstractions,The weakness of F# is C#. C# is just good enough.,Less than two months,"To extend the popularity of F# it would be nice to have a port for the JVM, but I don't think this will ever happen.",Enterprise development,,Working with C#-centric tooling,,"No dependency cycles, Type inference",,do more advertising ,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos",
15/04/2015 12:58:45,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,,"MSDN, Personal mentoring",,It's officially endorsed for critical/production areas,"Machine learning, Research/Teaching",Internal enterprise projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, Linux","LLVM, Native","C#, Java, Ocaml/SML",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Object expressions, Type providers, Units of measure",Don't understand the compiler errors,Too Windows-centric: They have concerns over cross-platform issues,I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,"Academic, research, or related",,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Performance issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Easy integration with other .NET libraries, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference",,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
15/04/2015 13:33:11,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,Email from colleagues,Answers to Stack Overflow questions,,It's officially endorsed for critical/production areas,"Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Games",Free scientific web tools,Not doing data centric apps,Visual Studio 2012 or newer,"Windows, Mac","Windows, Mac, Linux, Azure",LLVM,"Java, Ocaml/SML, Scala, Turbo Pascal",,Speed of development,Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Object expressions, Object-oriented compatibility, Quotations, Type providers",Debugger could visualize data structures better,It is used in all the places where it has benefits,I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,"Academic, research, or related",,Cross-platform issues,Better for solving complex problems,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Type inference, Polymorphism",,,More material with real-world examples and war stories,
15/04/2015 13:48:47,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"F# Weekly, Facebook",OCAML,,,,,,Visual Studio 2012 or newer,Windows,,,"C, C#, C++, Ocaml/SML",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Async workflows, Computation expressions, Object expressions, Quotations, Type providers, Units of measure",,,I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,"Academic, research, or related",,,,"Active Patterns, Algebraic types (inc discriminated unions and tuples), printf that is type checked, Type inference",,,"More material with real-world examples and war stories, More short ""live coding"" videos",
15/04/2015 14:07:58,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,,F# bloggers,,I don't use F# at work,,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,,"C#, Java, Javascript",,"Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,"Lack of good tutorials/documentation, I can't use my knowledge from C# or other imperative languages","Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,Haven't really used it yet,,Enterprise development,,,,,,,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
15/04/2015 14:26:07,5-10 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"Twitter, F# bloggers","Links and instructions from fsharp.org, Personal mentoring, Structured training/workshops",,I don't use F# at work,"Algorithm-heavy business applications (non-financial), Machine learning, Text analysis/language parsing",Not applicable. None of my F# code is used by other people,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,"Windows, Linux",None -- I'm happy with the CLR/Mono,"C#, Javascript, Visual Basic",,"Having fun again, Learning functional programming in general, Functional but can be tweaked to get high performance","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Quotations, Type providers","Lack of good tutorials/documentation, Installation process, Not enough real-world code to learn from","Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, Too Microsoft-centric: They think it is too closely linked to Microsoft",I'm willing to learn advanced concepts but only if they are relevant and practical,,Haven't really used it yet,,Enterprise development,,Difficulty in troubleshooting problems,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Async workflows, Easy integration with other .NET libraries, Interactive development, printf that is type checked, The ""piping"" idiom, Type inference, Units of measure",Real-World Examples,"Be more present on the Web, at IT events, show the world the ture benefits of F# by showing them real-world examples","More material with real-world examples and war stories, More short ""live coding"" videos",
15/04/2015 15:45:21,5-10 years,"No, I don't know much theory",I use it at work or for other commercial uses,,"HN, Reddit and other programming news sites","Personal mentoring, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Games, Data analysis/statistics","Internal enterprise projects, Commercial products, Open source projects","SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,"LLVM, Native","C#, RPGLE",,"Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Quotations,"Lack of good tutorials/documentation, Not enough real-world code to learn from",No buy-in: There is lack of acceptance from other teams,I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, printf that is type checked, The ""piping"" idiom, Type inference",,,"More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
15/04/2015 15:56:55,5-10 years,"No, I don't know much theory",I use it at work or for other commercial uses,,"HN, Reddit and other programming news sites","MSDN, F# bloggers, Answers to Stack Overflow questions, Personal mentoring, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Games, Mainstream business & enterprise applications, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Open source projects","SQL databases, Event sourcing",Visual Studio 2012 or newer,Windows,Windows,Javascript,"C, C#, C++, Haskell, Ocaml/SML, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Interactive development, Quotations","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,"It's very close to haskell but lack some very important features that would improve maintainability. Type classes, newtype, possibly GADT.",1-2 years,F# is great.,Enterprise development,,"Not being part of the core .NET distribution, Less sophisticated tools for refactoring, etc., Lack of important features such as type classes","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, No dependency cycles, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure","Real world examples, show C# users how they can rewrite stuff in F# in a better way. Show how maintainability is improved.","If a C# project could contain F# files as well, people might start using it more since it's hard to port a complete project.","More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material",Ask features you want to see in F#.
15/04/2015 16:16:56,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, Links mentioned in F# Weekly",,I don't use F# at work,Utilities and tools,Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Async workflows, Interactive development, Quotations",Not enough real-world code to learn from,Hiring: They worry about not being able to find F# developers,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,Working with C#-centric tooling,Domain modelling: making illegal states unrepresentable,"Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Immutability by default, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
15/04/2015 16:25:39,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly",Don Syme ,,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Machine learning, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Open source projects","SQL databases, Read-only data sources such as feeds",Vim,"Windows, Linux","Windows, Linux, Amazon Web services","Javascript, LLVM","Javascript, Python",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,Don't understand the compiler errors,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,Dotnet dependency ,4 or more years,,Science or related,,"Not being part of the core .NET distribution, Database interop","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, The ""piping"" idiom, Type inference, Type providers, Units of measure, Semantic whitespace",,Better Linux editor support. ,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
15/04/2015 16:45:09,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, HN, Reddit and other programming news sites","MSDN, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly",,It's used unofficially,"Utilities and tools, Algorithm-heavy business applications (non-financial), Research/Teaching","Internal enterprise projects, Commercial products",Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,"None -- I'm happy with the CLR/Mono, JVM, Javascript, LLVM, Native","C#, Haskell",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Async workflows, Object expressions, Object-oriented compatibility, Units of measure",,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,Enterprise development,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, No dependency cycles, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
15/04/2015 17:18:33,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","F# books, F# bloggers",,I don't use F# at work,Research/Teaching,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,LLVM,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,,Training: They are worried about getting non-F# developers up to speed,I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,,,"Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
15/04/2015 17:18:41,5-10 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# bloggers","MSDN, F# books, F# bloggers",,It's officially endorsed for critical/production areas,"Utilities and tools, Financial services, Games, Mainstream business & enterprise applications, Data analysis/statistics",Commercial products,"SQL databases, Data integration and EAI",Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux",None -- I'm happy with the CLR/Mono,"C#, C++, Haskell, Visual Basic",,,Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Agents (MailboxProcessor),"Installation process, I can't use my knowledge from C# or other imperative languages","Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,"Visual development support for ASP.NET, WPF and Windows Store app",3-4 years,none,Enterprise development,,"Less sophisticated tools for refactoring, etc., Cross-platform issues","Correctness: fewer bugs and less rework, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference, Type providers",Learning F# can be made easier if we provide more comparison with other .NET supported languages such as C# and VB,More F# developers should be easier to find,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material",This survey should add question on how F# will support visual programming for UI
15/04/2015 17:19:19,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,,"Links and instructions from fsharp.org, F# books, Coding",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Algorithm-heavy business applications (non-financial), Machine learning, Research/Teaching, Data analysis/statistics","Internal enterprise projects, Commercial products, Open source projects",Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, WinPhone",None -- I'm happy with the CLR/Mono,"C, C#, C++, Perl, Python",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Interactive development, Type providers, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,Science or related,,,"Correctness: fewer bugs and less rework, More productive with fewer developers, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, Quotations, The ""piping"" idiom",,,More material with in-depth tutorials,
15/04/2015 17:25:32,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# bloggers","F# bloggers, Structured training/workshops, http://fsharpforfunandprofit.com",,It's officially endorsed for critical/production areas,"Utilities and tools, Mainstream business & enterprise applications",Small libraries to be used by C# core,"SQL databases, NoSQL database, Event sourcing",Visual Studio 2012 or newer,"Windows, Mac",Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript, Ruby",,"Conciseness of code (I can see more at a glance), Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",Quotations,,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,Too wsimple Agent/Actor model out of the box (compared to Akka/Erlang/etc.),Less than a year,,Financial services or similar,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Easy concurrency with async and agents","Active Patterns, Agents (MailboxProcessor), Easy integration with other .NET libraries",,"Not much, we have internal advocates for functional in general and F# in particular. I guess it is a matter of time.","More material with in-depth tutorials, More material with real-world examples and war stories",
15/04/2015 17:40:56,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, Google+, Google groups, F#nctional Times (Flipboard)","F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Data analysis/statistics","Commercial products, Open source projects","SQL databases, Data integration and EAI",Visual Studio 2012 or newer,"Windows, Mac","Windows, iOS, Azure",Javascript,"C#, Javascript, Python, Ruby, Typescript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Quotations, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from",Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,We should be focused on moving .NET into new areas such as startups and schools. I think that would give us more visibility and a better foothold within Microsoft and future developers.,4 or more years,,Web and client development,,"Lack of good wrappers for non-F# libraries, Working with C#-centric tooling","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems, Great for mapping domain logic to a web API","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",I think transition or add-on stories/tutorials might help bridge the gap for those interested but not sure they want to jump straight into F#.,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
15/04/2015 17:46:43,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,"Utilities and tools, Custom development/specialist markets",Commercial products,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, C++",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),,"Don't understand the compiler errors, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,3-4 years,,Enterprise development,,"Working with C#-centric tooling, Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
15/04/2015 18:08:38,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,,"MSDN, Links and instructions from fsharp.org, F# books, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,"Utilities and tools, Machine learning, Data analysis/statistics","Internal enterprise projects, Commercial products","SQL databases, Analytics",Visual Studio 2012 or newer,Windows,Windows,,C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Async workflows",,"Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,"1. Debugging. I want to be able to step through interpreted code like I used to in Lisp. If I need to compile a dll to use the VS debugger it interrupts the interactive flow. If I need to reload the data, it takes a long time (e.g., 32GB at 10s/GB takes 5 minutes; the problem is not the compile time, it is the data load time). So I am back to using  printf. Painful.

2. Documentation. Equally broken in C#. You cannot write documentation that is both legible with intellisense and in the code!  You need <para></para> to break a line in intellisense doc. If you want an equation...

3. View IL from interpreted code. This is related to 1. Basically, I love the interpreter, and I want all functionality of compiled code to be interactively available (with a right click). 

4. Profiling too. Toggle it with a right click->Profile this function. Another right click->View profile of last call. Don't know if that is possible (?)


Despite the above asks, I want to state that I love F#. Thank you, thank you!

(Patrice@microsoft.com)
",4 or more years,,Science or related,,"Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Better for solving complex problems","Easy integration with other .NET libraries, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom",,"F# takes a while to learn. When I learned it, I could not do anything without a book or consulting the web for the first 2 weeks.

It took 2 months to realize that I was spending much less time debugging. That's when I realized I was in love with F#.",More material with in-depth tutorials,
15/04/2015 18:26:51,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,F# Weekly,F# books,,It's used unofficially,Other,Open source projects,NoSQL database,Visual Studio 2012 or newer,Windows,Windows,,C++,,"Correctness (no nulls, it works first time), Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Interactive development, Quotations","work with XAML, TPL, Cross platform development",No perceived benefits: They don't understand what benefits F# has over C# or other languages,,,2-3 years,,Enterprise development,,"Working with C#-centric tooling, Cross-platform issues",Correctness: fewer bugs and less rework,"printf that is type checked, Type inference",,,,
15/04/2015 18:45:16,2-5 years,"No, I don't know much theory",I use it for student work,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","F# books, F# bloggers, Videos (e.g. Community for F#)",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Machine learning, Mainstream business & enterprise applications, Data analysis/statistics, Text analysis/language parsing",Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,Windows,Windows,"LLVM, Native","C#, Java",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Integration with non-F# libraries, Object-oriented compatibility",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Enterprise development,,"Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, More productive with fewer developers, Faster time to market, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type providers",,,"More material with real-world examples and war stories, More podcasts and other audio-only material",
15/04/2015 18:52:59,2-5 years,"No, I don't know much theory",I use it for research or academic work,,"F# Weekly, HN, Reddit and other programming news sites, F# bloggers","MSDN, F# books, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,I don't use F# at work,"Utilities and tools, Machine learning, Research/Teaching",Open source projects,"Analytics, Data integration and EAI",Visual Studio 2012 or newer,Windows,Windows,,"C#, Python, R, SAS",,"Conciseness of code (I can see more at a glance), Great community, Learning functional programming in general, Type Providers","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Async workflows, Object-oriented compatibility, Quotations","Lack of good tutorials/documentation, Not enough real-world code to learn from","Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,"Academic, research, or related",,"Not being part of the core .NET distribution, Difficulty in troubleshooting problems","Correctness: fewer bugs and less rework, Better for solving complex problems","Active Patterns, Easy integration with other .NET libraries, Immutability by default, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",It's ok just like this.
15/04/2015 19:28:51,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers",Personal mentoring,,It's used unofficially,"Utilities and tools, Mainstream business & enterprise applications","Internal enterprise projects, Commercial products",Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Interactive development, Quotations, Type providers, Units of measure",,Lack of visual studio and resharper and wpf support,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Science or related,,"Not being part of the core .NET distribution, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents","Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Immutability by default, The ""piping"" idiom, Type inference",,"WPF
custom tools in fsproject for visual studio
better refactoring support
",More material with in-depth tutorials,
15/04/2015 19:49:13,10 or more years,"No, I don't know much theory",Just tinkering,,"Twitter, F# bloggers",F# bloggers,,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,"Javascript, LLVM, Native","C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,,No buy-in: There is lack of acceptance from other teams,I like theory -- I'm not afraid of monads and other abstractions,,Less than two months,,LOB development,,Working with C#-centric tooling,,"Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
15/04/2015 19:57:39,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,,"MSDN, F# books, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,"Machine learning, Research/Teaching, Data analysis/statistics",Internal enterprise projects,,Visual Studio 2012 or newer,Windows,Windows,Native,"C#, C++, Perl",,"Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Object-oriented compatibility",Not enough real-world code to learn from,Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,,1-2 years,,Science or related,,"Difficulty in troubleshooting problems, Performance issues",Correctness: fewer bugs and less rework,"Active Patterns, Immutability by default, Interactive development, The ""piping"" idiom",,,More material with real-world examples and war stories,
15/04/2015 20:54:28,5-10 years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, HN, Reddit and other programming news sites","Links and instructions from fsharp.org, F# books, F# bloggers, Reading F# code written by experts",,It's used unofficially,"None - Just playing around, Utilities and tools",Not applicable. None of my F# code is used by other people,Not doing data centric apps,Vim,Linux,,"None -- I'm happy with the CLR/Mono, JVM, Javascript, LLVM, Native","C#, Go, Javascript, Scheme/CL",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Having fun again",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Computation expressions, Object expressions, Object-oriented compatibility, Quotations, Static type constraints, Type providers, Units of measure","Lack of good tutorials/documentation, Installation process, Poor *nix support","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Haven't really used it yet,,Enterprise development,,"Lack of F# friendly libraries, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",fsi is convenient to create tests,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, No dependency cycles",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
15/04/2015 21:17:00,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly",,,It's officially endorsed for critical/production areas,"Algorithm-heavy business applications (non-financial), Financial services, Machine learning, Mainstream business & enterprise applications, Mobile apps, Text analysis/language parsing","Commercial products, Open source projects",Event sourcing,Xamarin,"Mac, Linux",Linux,"JVM, LLVM, Native",Ruby,,"Correctness (no nulls, it works first time), Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Integration with non-F# libraries, Object-oriented compatibility",Installation process,Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,Stronger type constraints ,4 or more years,,Financial services or similar,,"Less sophisticated tools for refactoring, etc., Cross-platform issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), No dependency cycles, Type inference",,,,
15/04/2015 21:47:21,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly","F# books, Videos (e.g. Community for F#)",,It's officially endorsed for critical/production areas,"Custom development/specialist markets, Mainstream business & enterprise applications","Internal enterprise projects, Commercial products","SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,"Windows, Azure",Javascript,"C#, Haskell, Javascript, Typescript, SQL",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Integration with non-F# libraries, Object expressions, Object-oriented compatibility, Static type constraints, Units of measure",,Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,F# being dismissed by Haskellers at conferences for not having higher-kinded polymorphism. Not really. Probably the worst feature of F# is that C# doesn't have a concise syntactic sugar for dealing with some of F# types such as option and discriminated unions.,4 or more years,,Science or related,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, More productive with fewer developers","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Immutability by default, Interactive development, Type inference, Type providers",,,"More material with in-depth tutorials, More interactive tutorials (e.g. like the F# Koans)",
15/04/2015 22:29:33,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,word of mouth,"MSDN, http://fsharpforfunandprofit.com/",,It's used unofficially,"Machine learning, Research/Teaching, Text analysis/language parsing",research projects,,Visual Studio 2012 or newer,Windows,,,"C#, Python",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Async workflows, Object expressions, Quotations, Static type constraints, Type providers, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,Lack of good training material.  How about a fully automated Coursera course?,1-2 years,,"Academic, research, or related",,,"Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Interactive development, No dependency cycles, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",Ask me this in another survey.
15/04/2015 22:31:44,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, HN, Reddit and other programming news sites, F# bloggers","F# books, F# bloggers, Links posted on social media such as Twitter, Videos (e.g. Community for F#)",,I don't use F# at work,"None - Just playing around, Mobile apps",Not applicable. None of my F# code is used by other people,"NoSQL database, Event sourcing",Xamarin,Mac,"Mac, iOS",None -- I'm happy with the CLR/Mono,"C#, Javascript, Typescript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Integration with non-F# libraries, Object expressions, Object-oriented compatibility","Lack of good tutorials/documentation, Don't understand the compiler errors","Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,tooling on mac. I would like to see F# as the go-to x-plat language.,Less than a year,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems, Cross-platform issues",,"Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, The ""piping"" idiom, Type inference",,F# needs to disassociate from Microsoft and .NET,"More material with short ""cookbook"" style information, More podcasts and other audio-only material",
15/04/2015 23:29:02,5-10 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"Google groups, HN, Reddit and other programming news sites","Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Linux,"Javascript, LLVM","Clojure, Java, Javascript, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance)",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows, Static type constraints, Type providers, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from","Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed",I want to learn functional programming but I don't like academic jargon,Documentation around tooling and workflow.,Less than two months,,Science or related,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries",,"Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, The ""piping"" idiom, Type inference","More tutorials about the tooling/general workflow when using F#. As an experienced programmer who has never touched Visual Studio before, it is a little intimidating.",,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
15/04/2015 23:30:42,1-2 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,F# bloggers,"Links and instructions from fsharp.org, F# books, F# bloggers",,I don't use F# at work,"None - Just playing around, Algorithm-heavy business applications (non-financial), Financial services, Machine learning",Not applicable. None of my F# code is used by other people,Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, C++",,Learning functional programming in general,"Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",Quotations,do not now,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I like theory -- I'm not afraid of monads and other abstractions,,Less than two months,,Data or analytics related,,Not being part of the core .NET distribution,,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, The ""piping"" idiom",,,More material with real-world examples and war stories,
15/04/2015 23:37:00,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"F# bloggers, fsharpforfunorprofit, wikibooks","Links and instructions from fsharp.org, F# bloggers, Videos (e.g. Community for F#), pluralsight",,It's used unofficially,"None - Just playing around, Machine learning, Data analysis/statistics",Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,"Windows, Mac, Linux","Windows, Mac, Linux",None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Interactive development",it just has a steep initial learning curve before which it is difficult to understand the benefits,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability",I like theory -- I'm not afraid of monads and other abstractions,"Lack of interaction with partial classes (winforms/WPF, even though I'm personally thankful not to be working with either)",1-2 years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, fun","Active Patterns, Algebraic types (inc discriminated unions and tuples), Immutability by default, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, Type inference, Units of measure",,,More material with real-world examples and war stories,
16/04/2015 00:11:42,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers","Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Reading F# code written by experts, CTO corner",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications","Internal enterprise projects, Commercial products, Open source projects",Not doing data centric apps,Visual Studio 2012 or newer,Windows,"Windows, Other",None -- I'm happy with the CLR/Mono,"C, C#, C++, Ocaml/SML, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Quotations, Static type constraints, Type providers","Lack of good tutorials/documentation, Don't understand the compiler errors, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Performance issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Efficiency/Performance","Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, No dependency cycles, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
16/04/2015 00:51:06,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly","F# bloggers, Links mentioned in F# Weekly, Fsharpforfunandprofit.com",,It's used unofficially,,Internal enterprise projects,"SQL databases, Event sourcing, Data integration and EAI",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,Not enough real-world code to learn from,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I want to learn functional programming but I don't like academic jargon,,Less than a year,,Enterprise development,,"Not being part of the core .NET distribution, Microsoft doesn't make F# part of the default stack ","More productive with fewer developers, EAI is for functional","Immutability by default, The ""piping"" idiom, Type providers",,The community is doing everything it can and should.,"More material with in-depth tutorials, More material with real-world examples and war stories",
16/04/2015 02:25:12,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"F# Weekly, F# bloggers","F# books, F# bloggers, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,It's used unofficially,Data analysis/statistics,Internal enterprise projects,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,"Windows, Azure","JVM, Native","C#, C++, powershell",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Speed of development, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Static type constraints, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,"lack of support in visual studio for the designers like XAML, MVC, etc.  F# should be a first class citizen just like C# with all the same templates available. ",Less than a year,,Data or analytics related,,Working with C#-centric tooling,"Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Interactive development, The ""piping"" idiom, Type providers",more code examples in F# on MSDN .Net documentation,"Get the designers in visual studio to work with F#.  Most people look at the work needed to get a web app or store app working with F# and say ""not worth it"".","More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
16/04/2015 04:24:09,2-5 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, HN, Reddit and other programming news sites","F# books, Links mentioned in F# Weekly, Reading F# code written by experts",,I don't use F# at work,"Utilities and tools, Financial services, Mainstream business & enterprise applications, Data analysis/statistics",Not applicable. None of my F# code is used by other people,"Read-only data sources such as feeds, Analytics",Visual Studio 2012 or newer,Windows,"Windows, Azure","None -- I'm happy with the CLR/Mono, LLVM, Native","C#, Java, Javascript, Ruby, Scala, Typescript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Functional but can be tweaked to get high performance","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",Object-oriented compatibility,"Lack of good tutorials/documentation, Not enough real-world code to learn from",Too Windows-centric: They have concerns over cross-platform issues,I'm willing to learn advanced concepts but only if they are relevant and practical,,Haven't really used it yet,,Enterprise development,,Lack of good wrappers for non-F# libraries,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
16/04/2015 06:55:03,1-2 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,Twitter,"F# books, Answers to Stack Overflow questions",,It's officially endorsed for non-critical/non-production code,Data analysis/statistics,Internal enterprise projects,"NoSQL database, Analytics",Visual Studio 2012 or newer,Windows,Windows,Native,C#,,"Conciseness of code (I can see more at a glance), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows",Lack of good tutorials/documentation,Training: They are worried about getting non-F# developers up to speed,I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,"Difficulty in troubleshooting problems, Performance issues",Correctness: fewer bugs and less rework,"Immutability by default, Interactive development, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More short ""live coding"" videos",
16/04/2015 07:13:28,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Reading F# code written by experts",,I don't use F# at work,"Utilities and tools, Machine learning, Research/Teaching, Data analysis/statistics",Not applicable. None of my F# code is used by other people,"NoSQL database, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,Javascript,"C#, Typescript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Object-oriented compatibility","Don't understand the compiler errors, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,C# is 'good enaugh',Less than a year,Excellent work :),Financial services or similar,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",,"Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Type inference, Type providers","Better tooling support - e.g., working with library references is still kind of PITA, I also had some troubles with dependency hell regarding different F# versions.

Troubleshooting of those problems is not mentioned very often - the blogs/articles/tutorials are all unicorns and rainbows.
",Success-stories from management level and higher - cutting costs is their main concern.,"More material with real-world examples and war stories, More short ""live coding"" videos",Be shorter
16/04/2015 08:56:22,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# bloggers","F# books, F# bloggers, Links posted on social media such as Twitter",,It's officially endorsed for critical/production areas,"Financial services, Mainstream business & enterprise applications, Mobile apps, Other","Internal enterprise projects, Commercial products","SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,"Windows, iOS, Azure",None -- I'm happy with the CLR/Mono,C#,,Conciseness of code (I can see more at a glance),Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Quotations, Units of measure",Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,"no typeclass.
less integration with VS.",4 or more years,,Enterprise development,,"Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",a lot of short and practical samples.,show a lot of articles that indicates F# is worth.,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
16/04/2015 09:04:46,10 or more years,"No, I don't know much theory",Learning,,"F# bloggers, StackOverflow chat","Links and instructions from fsharp.org, F# books, F# bloggers, Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,Windows,,None -- I'm happy with the CLR/Mono,"C, C#, C++, PHP",,"Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Async workflows, Interactive development","Lack of good tutorials/documentation, Not enough real-world code to learn from",Training: They are worried about getting non-F# developers up to speed,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Data or analytics related,,"Less sophisticated tools for refactoring, etc.",,"Active Patterns, Object-oriented features (inc. C# compatibility, conciseness), Type providers, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
16/04/2015 09:30:51,10 or more years,"No, I don't know much theory",Just tinkering,Gave up trying to convince coworkers to use F# or anything functional.,"HN, Reddit and other programming news sites","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links posted on social media such as Twitter, Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,,Not applicable. None of my F# code is used by other people,,Visual Studio 2012 or newer,Windows,,"Javascript, LLVM","C#, Javascript, Typescript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Interactive development",Don't understand the compiler errors,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,It seems to be treated as a toy language within Microsoft. ,I was using F# but have stopped,,Financial services or similar,,Difficulty in troubleshooting problems,,"Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,"Be rated higher by Gartner.

Needs compelling reason to switch from R or Matlab.

Distinguish how functional concepts are better in F# than their bastard cousins in C# (for example: C# has caused my coworkers to view tuples poorly, so it's an uphill battle to talk about how F# uses tuples to minimize the need for DTOs).","More material with in-depth tutorials, More material with real-world examples and war stories, More podcasts and other audio-only material",
16/04/2015 10:54:44,5-10 years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, slack","F# books, F# bloggers, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,"Utilities and tools, Mainstream business & enterprise applications",Internal enterprise projects,"SQL databases, NoSQL database",Visual Studio 2012 or newer,"Windows, Mac, Linux","Windows, Mac, Linux, Azure","JVM, Javascript, LLVM, Native, beam","C#, Erlang, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Having fun again, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Units of measure,"Lack of good tutorials/documentation, Not enough real-world code to learn from",No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Faster time to market","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Immutability by default, Interactive development, No dependency cycles, Quotations, The ""piping"" idiom, Type inference, Type providers",,,More material with real-world examples and war stories,
16/04/2015 11:29:26,5-10 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,IRC,"Links and instructions from fsharp.org, F# bloggers",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,,Vim,Linux,,LLVM,"C++, Rust",,"Speed of development, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Interactive development",Installation process,,I like theory -- I'm not afraid of monads and other abstractions,,Haven't really used it yet,,"Academic, research, or related",,Working with C#-centric tooling,,"Async workflows, Easy integration with other .NET libraries",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
16/04/2015 11:41:22,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"HN, Reddit and other programming news sites","MSDN, Links and instructions from fsharp.org, F# books",,I don't use F# at work,"Machine learning, Research/Teaching",Not applicable. None of my F# code is used by other people,Read-only data sources such as feeds,Xamarin,Mac,"Mac, Linux",LLVM,"C++, Python",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Integration with non-F# libraries, Object-oriented compatibility, Units of measure",Lack of good tutorials/documentation,,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Student,,"Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc.",,"Active Patterns, Immutability by default, The ""piping"" idiom, Type inference",,,More material with in-depth tutorials,
16/04/2015 12:09:21,Less than a year,"Yes, I enjoy computer science and mathematics",Just tinkering,,,"MSDN, Links and instructions from fsharp.org, F# bloggers, Answers to Stack Overflow questions",,It's used unofficially,"Custom development/specialist markets, Data analysis/statistics",Not applicable. None of my F# code is used by other people,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,"Windows, Azure, Other",,,,"Great community, Having fun again, Learning functional programming in general",Beginner (For example: you know OO well and functional programming seems strange),,Lack of material that doenst assume prior coding knowledge,Lack of awareness,I want to learn functional programming but I don't like academic jargon,,Haven't really used it yet,,Data or analytics related,,,,"Async workflows, Easy integration with other .NET libraries",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)","Lose the green/emerald text color, it's nasty."
16/04/2015 12:23:13,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,Twitter,"MSDN, Links and instructions from fsharp.org, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Research/Teaching, Data analysis/statistics, Other",Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,,"Windows, Mac, Linux, Azure","Javascript, Native",R,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Agents (MailboxProcessor), Async workflows, Object expressions, Object-oriented compatibility, Quotations, Units of measure",,Nothing. Everyone loves it.,I'm willing to learn advanced concepts but only if they are relevant and practical,,2-3 years,,Student,,"Less sophisticated tools for refactoring, etc., Cross-platform issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material",
16/04/2015 12:29:59,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,F# bloggers,"F# books, F# bloggers, Answers to Stack Overflow questions",,I don't use F# at work,"Utilities and tools, Mainstream business & enterprise applications, Research/Teaching",Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Quotations, Static type constraints, Type providers, Units of measure",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,Lack of F# friendly libraries,,"Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, No dependency cycles, The ""piping"" idiom, Type inference",It can't be made easier...,,"More material with in-depth tutorials, More material with real-world examples and war stories",
16/04/2015 12:42:31,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,Colleagues,"F# books, Answers to Stack Overflow questions, Personal mentoring, Reading F# code written by experts",,It's officially endorsed for critical/production areas,Custom development/specialist markets,Internal enterprise projects,"SQL databases, Event sourcing",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C, C#, Javascript, Python",,Having fun again,"Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Units of measure",I can't use my knowledge from C# or other imperative languages,No buy-in: There is lack of acceptance from other teams,I want to learn functional programming but I don't like academic jargon,,1-2 years,,Enterprise development,,hidden keywords not explained,Correctness: fewer bugs and less rework,"No dependency cycles, Type inference, Type providers",,,More material with in-depth tutorials,
16/04/2015 14:03:31,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,Twitter,"Links and instructions from fsharp.org, F# bloggers, Links posted on social media such as Twitter, Answers to Stack Overflow questions",,It's used unofficially,Utilities and tools,Open source projects,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,"Windows, Azure",None -- I'm happy with the CLR/Mono,"C, C#, C++, Java, Typescript, Delphi",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Computation expressions, Interactive development, Quotations, Type providers, Units of measure","I can't use my knowledge from C# or other imperative languages, Don't understand the compiler errors","No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,"I once saw three different way to declare and empty class.  

http://theburningmonk.com/2011/12/f-define-empty-class-struct-or-interface-types/

Why is there more that one way?  It's hard to accumulate knowledge when you continually see such variety in syntax.  Maybe there are reasons.  I wouldn't know.
",1-2 years,"F# FF&P and the people at fsharp.org are incredible and have expanded my thinking programming a lot.  F# has just not come easily to me like other languages have, and that's a personal frustration.  Because I love many of the language constructs, but I'm still just so slow to write them.  Which is frustrating.",Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, The ""piping"" idiom","I've picked up several languages in my career, most of them OO.  The paradigm shift itself is the first hurdle.  How do I the things I usually do with different tools and constructs.  It's hard to translate my old patterns sometimes.

I feel like the intellisense in VS is at the same level as C#.  I am often caught staring at a red squiggly line wondering what part of what I just typed is wrong.  The error messages aren't always that clear to me.  I feel like I depend on this a lot for guidance which may not be the best thing...  but I do it anyway.

F# FF&P has a 4 part calculator tutorial which is amazing.  I wish there were more enterprise level (architectural / design/ etc.) tutorials available.  Something with a 3-layered architecture, databases and the like.  I do a lot of WPF, F# is challenging for me here.  

Scope and object lifetimes are a challenge sometimes when I'm trying to write purely functional F# but I have to keep an .net framework object alive.  Dependency injection is great for OOP, I need to see how this is translated to F# in a more detailed way.

All of these things probably exists somewhere already.  I read what I can, but F# isn't acceptable in my workplace yet so mostly deal with C#.  It's hard to convince people to check F# out when you can't answer their questions well enough.  

Thanks for listening!

","VS tooling needs to be as good as C#.  People learn and depend so much on intellisense.  Without it, they feel like they're back coding in a text editor.","More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",No.  It's great.  Thanks for listening.
16/04/2015 14:44:19,10 or more years,"No, I don't know much theory",,,Twitter,fsharpforfunandprofit,,It's used unofficially,"None - Just playing around, Utilities and tools, Financial services, Data analysis/statistics","Open source projects, Not applicable. None of my F# code is used by other people",Read-only data sources such as feeds,Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux",None -- I'm happy with the CLR/Mono,"C#, Java, Javascript",,"Having fun again, Learning functional programming in general",Beginner (For example: you know OO well and functional programming seems strange),"Active Patterns, Agents (MailboxProcessor), Async workflows, Quotations, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams, very big corporatey enterprisey government",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,Thanks for doing this survey!,Enterprise development,,"Less sophisticated tools for refactoring, etc.",FAKE,"Algebraic types (inc discriminated unions and tuples), The ""piping"" idiom, Type providers","Koans, lots of them.",More tools like FAKE :) Small things that can be sneaked into the corp,More interactive tutorials (e.g. like the F# Koans),
16/04/2015 16:35:19,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"F# Weekly, Google groups, HN, Reddit and other programming news sites","F# books, F# bloggers, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Custom development/specialist markets, Mainstream business & enterprise applications, Text analysis/language parsing",Commercial products,"SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,Windows,Windows,"Javascript, LLVM","C, C#, C++, Erlang, Haskell, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Async workflows, Interactive development, Object expressions, Object-oriented compatibility",Dependency ordering,Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,"I think the fact that the language is held back by the CLR team is pretty bad.  F# would be a perfect language with higher kinded types; it's almost hackable with 'inline' at the moment, but the fact that the CLR team can slam any idea is going to be harmful for the project long-term.  ",1-2 years,,Software development house,,Debugging computation expressions in Visual Studio.  Forget it basically.,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Easy concurrency with async and agents, Better for solving complex problems","Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, No dependency cycles, Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",Higher kinded types,,I think the learning material for F# is adequate,"""How would you classify your day job?"" --- Should include 'Software development house"", it seems a glaring omission."
16/04/2015 15:15:32,5-10 years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, StackOverflow chat","Answers to Stack Overflow questions, Reading F# code written by experts, translating my own C# to F#",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Other",Not applicable. None of my F# code is used by other people,SQL databases,VS2015 CTP,Windows,Windows,"None -- I'm happy with the CLR/Mono, Javascript, Native",C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Async workflows, Static type constraints",Don't understand the compiler errors,legacy codebase,I want to learn functional programming but I don't like academic jargon,"tooling by far.

I think roslyn compatibility will be a problem eventually.

interop issues with C# (they sometimes have to add F# core references to reference F# libraries)

starter project templates",1-2 years,"I hope someone finds ways to make it simpler to try to create your own type provider.

the debugging experience for trying to make an F# type provider is atrocious.",Enterprise development,,Working with C#-centric tooling,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Immutability by default, No dependency cycles, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers","include namespaces in ALL code examples. it's very frustrating to see code that is claimed to work, but have no idea what the code actually is because of a lack of the open/using clauses showing what namespaces are needed for it to work.

have specific courses aimed at writing F# with a C# dialect to help the transition. (stay as close to C# as possible for awhile)

reduce or make more explicit the differences in learning samples between how something is done in the 3 different environments ( .fsx, .fs, and the F# interactive REPL)","improve C# nullable value type (and nullable reference type) interop with F# option types. 
improve interop of FSharp delegate and C# delegates.

allow creation of folders in an F# project.

allow drag-drop of files (both ordering and folder location)

support T4 templates","More material with in-depth tutorials, More material with short ""cookbook"" style information, More interactive tutorials (e.g. like the F# Koans)",
16/04/2015 16:10:32,2-5 years,"No, I don't know much theory",Just tinkering,,,Personal mentoring,,I don't use F# at work,,,,Visual Studio 2012 or newer,Windows,,None -- I'm happy with the CLR/Mono,C#,,,Beginner (For example: you know OO well and functional programming seems strange),,,,I'm willing to learn advanced concepts but only if they are relevant and practical,,Haven't really used it yet,,Enterprise development,,,,,,,More material with in-depth tutorials,
16/04/2015 16:38:02,10 or more years,"No, I don't know much theory","Hobby, Side and some Commercial uses",I don't really get a chance to use it. But I do look for opportunities where I can use it.  ,"F# Weekly, F# bloggers, Reddit","F# books, Links mentioned in F# Weekly",,I don't use F# at work,,,,Visual Studio 2012 or newer,Windows,,"JVM, Javascript, LLVM","C#, Typescript",,Learning functional programming in general,"Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",Type providers,"Lack of good tutorials/documentation, I can't use my knowledge from C# or other imperative languages",,I like theory -- I'm not afraid of monads and other abstractions,"I think some of the syntax is a little obscure, esp around class, properties and interfaces; I don't see how the ""less code"" mantra is applicable here, I think its far wordier. Also, having three different, context dependent, assignment operators is also dodgy, I don't think this helps with learning, at all.",I was using F# but have stopped,,Enterprise development,,"Lack of F# friendly libraries, Difficulty in troubleshooting problems",,"Agents (MailboxProcessor), Easy integration with other .NET libraries, Immutability by default, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, The ""piping"" idiom, Type inference",More books! ,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
16/04/2015 17:21:09,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"F# Weekly, HN, Reddit and other programming news sites","Links and instructions from fsharp.org, F# books, Links mentioned in F# Weekly, Answers to Stack Overflow questions",,I don't use F# at work,"Utilities and tools, Games",Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,Windows,Windows,,C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Integration with non-F# libraries, Interactive development","Lack of good tutorials/documentation, Not enough real-world code to learn from",,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,retired,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",,"Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,More material with real-world examples and war stories,
16/04/2015 17:57:26,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,F# bloggers,"MSDN, F# bloggers, Personal mentoring, Reading F# code written by experts",,I don't use F# at work,"None - Just playing around, Utilities and tools",,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,Native,"C#, Visual Basic",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Async workflows, Object-oriented compatibility, Quotations, Units of measure",Lack of good tutorials/documentation,"Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I want to learn functional programming but I don't like academic jargon,type-system ; lack of higher kind / typeclasses a la Haskell,1-2 years,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.",,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, Object expressions, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More interactive tutorials (e.g. like the F# Koans)",
16/04/2015 20:20:55,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"F# bloggers, StackOverflow chat","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,It's officially endorsed for critical/production areas,"Algorithm-heavy business applications (non-financial), Financial services, Machine learning, Data analysis/statistics",Internal enterprise projects,"SQL databases, NoSQL database, Event sourcing, Read-only data sources such as feeds",Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux, Azure, Amazon Web services","JVM, Native","C#, C++, R",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Type providers,Installation process,"Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft",I like theory -- I'm not afraid of monads and other abstractions,CLR/Mono's lack of hard real-time determinism.,3-4 years,,Financial services or similar,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Cross-platform issues","Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Interactive development, The ""piping"" idiom, Type inference, Units of measure",,,"More material with in-depth tutorials, More short ""live coding"" videos",
16/04/2015 20:34:23,10 or more years,"No, I don't know much theory",Just tinkering,,Google groups,F# books,,I don't use F# at work,None - Just playing around,,,Visual Studio 2012 or newer,Windows,,,"C#, Javascript",,Learning functional programming in general,Beginner (For example: you know OO well and functional programming seems strange),,so much syntax,,I'm willing to learn advanced concepts but only if they are relevant and practical,"It is a difficult language and it doesn't have a killer app or use case. (Or, if you like, it is not perceived as having these.)

I am still torn between continuing with F# or spending more time with Go. I am almost sure learning Go would open more doors for earning money, and it would be easier to get proficient with it. But I think I'll learn more from studying F#.
",Less than two months,Thanks for your interest/evangelism.,Enterprise development,,,,,,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
16/04/2015 21:03:21,10 or more years,"No, I don't know much theory",trying to learn functional programming,,,,,I don't use F# at work,,,,F# emulator in tryfsharp.org,Windows,,"JVM, Native","C#, Java",,,Beginner (For example: you know OO well and functional programming seems strange),,"Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I want to learn functional programming but I don't like academic jargon,,Haven't really used it yet,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",,,,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories",
16/04/2015 21:27:53,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"F# Weekly, HN, Reddit and other programming news sites","F# books, F# bloggers, Links mentioned in F# Weekly",,It's used unofficially,"Utilities and tools, Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications",Internal enterprise projects,"SQL databases, NoSQL database, Read-only data sources such as feeds, Data integration and EAI",Visual Studio 2012 or newer,Windows,Windows,LLVM,"C#, Javascript, Typescript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Interactive development, Object expressions, Units of measure",better interactive development workflow and scripting,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Performance issues","Domain modelling: making illegal states unrepresentable, More productive with fewer developers, Easy concurrency with async and agents","Active Patterns, Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, The ""piping"" idiom, Type inference, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos",
16/04/2015 21:38:43,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"HN, Reddit and other programming news sites, F# bloggers, StackOverflow chat","MSDN, Personal mentoring, Reading F# code written by experts",,It's officially endorsed for critical/production areas,,Internal enterprise projects,SQL databases,Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux","JVM, Native","C#, C++, Java",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general, Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Object-oriented compatibility, Quotations, Units of measure",Not enough real-world code to learn from,"Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom",,,More material with in-depth tutorials,
16/04/2015 22:39:58,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,,"F# books, F# bloggers, Personal mentoring, Structured training/workshops",,It's officially endorsed for critical/production areas,Financial services,Internal enterprise projects,"SQL databases, Event sourcing",Visual Studio 2012 or newer,Windows,Windows,,"C#, Haskell",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Computation expressions,Not enough real-world code to learn from,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Financial services or similar,,"Lack of good wrappers for non-F# libraries, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Type inference, Type providers, Units of measure",,,More material with real-world examples and war stories,
17/04/2015 01:31:05,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly, HN, Reddit and other programming news sites, F# bloggers, StackOverflow chat","MSDN, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Structured training/workshops, Videos (e.g. Community for F#), Reading F# code written by experts",,I don't use F# at work,"Financial services, Data analysis/statistics",Not applicable. None of my F# code is used by other people,"Event sourcing, Read-only data sources such as feeds, Analytics",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Conciseness of code (I can see more at a glance), Great community, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Quotations, Static type constraints, Units of measure",,,I like theory -- I'm not afraid of monads and other abstractions,,3-4 years,,Financial services or similar,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems",,"Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories",
17/04/2015 06:43:34,1-2 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"F# Weekly, Google+","MSDN, F# books, F# bloggers",,I don't use F# at work,None - Just playing around,Open source projects,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,Windows,"JVM, Javascript",C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Object expressions, Object-oriented compatibility, Quotations, Units of measure",Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers",I want to learn functional programming but I don't like academic jargon,"The lack of adoption is the biggest issue I would say. The community, while good, is incredibly small it seems a lot smaller than for other functional languages like Haskell or Clojure. In my country only three companies use F# officially and I assume this is because there is a lack of developers.",Less than a year,,Student,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.",,"Algebraic types (inc discriminated unions and tuples), Immutability by default, Interactive development, Type inference, Type providers",There needs to be more up-to-date resources,,"More material with in-depth tutorials, More material with short ""cookbook"" style information",
17/04/2015 09:39:59,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly","F# books, F# bloggers, Links mentioned in F# Weekly, Reading F# code written by experts",,It's used unofficially,"Utilities and tools, Custom development/specialist markets, Mainstream business & enterprise applications, Research/Teaching, Data analysis/statistics, Text analysis/language parsing",Bespoke tools and software (web and desktop) for Geographic Information Systems,SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Object expressions, Quotations, Type providers, Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Mixed professional services,,,"Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Agents (MailboxProcessor), Async workflows, Computation expressions, Immutability by default, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference",,,,
17/04/2015 11:20:28,10 or more years,"Yes, I enjoy computer science and mathematics",All of the above,,"Twitter, F# Weekly","Links and instructions from fsharp.org, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly",,It's officially endorsed for critical/production areas,"Utilities and tools, Financial services, Research/Teaching, Data analysis/statistics",Open source projects,Read-only data sources such as feeds,Visual Studio 2012 or newer,"Windows, Mac","Windows, Mac, Azure","JVM, Javascript, Erlang VM",C#,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Speed of development",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Static type constraints, Units of measure","Don't understand the compiler errors, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Financial services or similar,,"Not being part of the core .NET distribution, Working with C#-centric tooling","Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Interactive development, The ""piping"" idiom, Type inference, Type providers",,,"More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
17/04/2015 11:39:57,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"F# Weekly, F# bloggers, StackOverflow chat","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Reading F# code written by experts",,I don't use F# at work,"Financial services, Research/Teaching, Data analysis/statistics, Other",Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux","JVM, LLVM, Native","Python, R, MatLab",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Functional but can be tweaked to get high performance, .NET platform","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Agents (MailboxProcessor)","Lack of good tutorials/documentation, Don't understand the compiler errors","Nobody knows it at my school, and I have to follow the school programs with other languages.",I'm willing to learn advanced concepts but only if they are relevant and practical,,2-3 years,,Financial services or similar,,"Lack of F# friendly libraries, Lack of good wrappers for non-F# libraries, Difficulty in troubleshooting problems",,"Algebraic types (inc discriminated unions and tuples), Computation expressions, Easy integration with other .NET libraries, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, Quotations, The ""piping"" idiom, Type inference, Type providers, Units of measure",,Show the benefits in scientific and financial topics.,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos",
17/04/2015 12:04:02,Less than a year,"Yes, I enjoy computer science and mathematics",Just tinkering,,"HN, Reddit and other programming news sites, F# bloggers","Links and instructions from fsharp.org, F# bloggers, Answers to Stack Overflow questions",,I don't use F# at work,"None - Just playing around, Mainstream business & enterprise applications",Not applicable. None of my F# code is used by other people,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,Windows,"Javascript, LLVM, Native",Visual Basic,,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Speed of development","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Interactive development, Object-oriented compatibility, Quotations, Units of measure","Don't understand the compiler errors, Not enough real-world code to learn from",Training: They are worried about getting non-F# developers up to speed,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, No dependency cycles, Simple ""one liner"" type definitions for records and DUs","Make it easier for people to write graphical applications in F#.

Writing a business logic module while putting into practice all the new FP concepts is fun. Wrestling with WPF is painful, not particularly interesting, and discouraging to future F# coders.

Yes, you can and probably will write the GUI code in C# / VB.NET, but still.",,"More material with short ""cookbook"" style information, More material with real-world examples and war stories",
17/04/2015 13:57:09,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,,"F# bloggers, Videos (e.g. Community for F#), Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Object-oriented compatibility, Quotations",Not enough real-world code to learn from,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,"F# is very good and production ready as a language.
Low adoption have very fundamental reasons which have little to do with language as it is and difficult to fix:
- students still learn OOP as main paradigm which is bad
- F# / FP makes people think more and type less. Most people are too stupid for this, alas. Typical dev produces tonnes of rubbish code and then spend months fixing it. F# simply doesn't let them do it and reveals their unprofessionalism
",Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, The ""piping"" idiom, Type inference, Type providers, Units of measure",it can't,"F# and FP in general is for enthusiast who willing to make development fun and productive. It's also for smart people.
Typical enterprise dev is not like this at all. He's dumb, passive, doesn't like to learn and covers his ass with good old OOP.

Indifference and dumbness of peers is the main issue of adopting F#","More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos",not sure
17/04/2015 14:31:15,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,,"F# books, F# bloggers, Links mentioned in F# Weekly",,It's officially endorsed for non-critical/non-production code,Utilities and tools,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,,"C, C#, Haskell, Java",,Functional but can be tweaked to get high performance,Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Active Patterns, Agents (MailboxProcessor), Interactive development, Type providers",,,I like theory -- I'm not afraid of monads and other abstractions,,Less than a year,,Enterprise development,,,,"Algebraic types (inc discriminated unions and tuples), Async workflows, Computation expressions, Easy integration with other .NET libraries, Immutability by default, printf that is type checked, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information",
17/04/2015 16:43:29,5-10 years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","MSDN, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly",,It's officially endorsed for non-critical/non-production code,Utilities and tools,Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,"Javascript, LLVM, Native","C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Quotations, Type providers",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,"At the moment, I think it is the [official] tooling that is better for C#/VB. WPF XAML editor in Visual Studio for example.",1-2 years,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.",Scriptability,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Units of measure, Easy partial application and composition",,,More material with in-depth tutorials,
17/04/2015 16:44:28,5-10 years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","MSDN, F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly",,It's officially endorsed for non-critical/non-production code,Utilities and tools,Open source projects,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,"Javascript, LLVM, Native","C#, Javascript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Quotations, Type providers",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,"At the moment, I think it is the [official] tooling that is better for C#/VB. WPF XAML editor in Visual Studio for example.",1-2 years,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.",Scriptability,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, printf that is type checked, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Units of measure, Easy partial application and composition",,,More material with in-depth tutorials,
17/04/2015 18:12:01,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"HN, Reddit and other programming news sites","MSDN, Answers to Stack Overflow questions, Tomas Petricek ;)",,It's officially endorsed for critical/production areas,"Utilities and tools, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Commercial products","SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux",None -- I'm happy with the CLR/Mono,"C#, Haskell, Javascript, Typescript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Static type constraints, Units of measure","Hard to debug, especially computation expressions like async",Hiring: They worry about not being able to find F# developers,I like theory -- I'm not afraid of monads and other abstractions,"Different codebase for the open source version (the source code for 3.1.2 was not available on github for quite some time after release).

The compiler is in serious need of refactoring. Too many lines per file and hard to understand. Lots of functions have short names that mean nothing for the uninitiated and the functions are too long. If someone asks me for a project with well-structured, idiomatic F# code, the compiler is the last thing that comes to mind.",3-4 years,,Enterprise development,,"Not being part of the core .NET distribution, Lack of good wrappers for non-F# libraries","Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Agents (MailboxProcessor), Async workflows, Computation expressions, Quotations, The ""piping"" idiom, Type providers",,Grow :),More material with real-world examples and war stories,
17/04/2015 18:18:25,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"HN, Reddit and other programming news sites","MSDN, Answers to Stack Overflow questions, Tomas Petricek ;)",,It's officially endorsed for critical/production areas,"Utilities and tools, Data analysis/statistics, Text analysis/language parsing","Internal enterprise projects, Commercial products","SQL databases, Read-only data sources such as feeds",Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux",None -- I'm happy with the CLR/Mono,"C#, Haskell, Javascript, Typescript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Functional but can be tweaked to get high performance",Expert (For example: You use composition as a design style; You always try to create total functions; You are very comfortable with monadic code and computation expressions),"Static type constraints, Units of measure","Hard to debug, especially computation expressions like async",Hiring: They worry about not being able to find F# developers,I like theory -- I'm not afraid of monads and other abstractions,"Different codebase for the open source version (the source code for 3.1.2 was not available on github for quite some time after release).

The compiler is in serious need of refactoring. Too many lines per file and hard to understand. Lots of functions have short names that mean nothing for the uninitiated and the functions are too long. If someone asks me for a project with well-structured, idiomatic F# code, the compiler is the last thing that comes to mind.",3-4 years,,Enterprise development,,"Not being part of the core .NET distribution, Lack of good wrappers for non-F# libraries","Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Agents (MailboxProcessor), Async workflows, Computation expressions, Quotations, The ""piping"" idiom, Type providers",,Grow :),More material with real-world examples and war stories,
17/04/2015 18:49:43,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Still learning. I saw a few things about 4.0, but I couldnt understand them.. still learning","MSDN, F# books, F# bloggers, Answers to Stack Overflow questions, Personal mentoring, mainly http://fsharpforfunandprofit.com/",,It's officially endorsed for critical/production areas,"Utilities and tools, Mainstream business & enterprise applications","Internal enterprise projects, Commercial products, Not applicable. None of my F# code is used by other people, I code my own products... commercial products, and I'm the only one to use this code.",SQL databases,Visual Studio 2012 or newer,Windows,"Windows, Azure, Amazon Web services",JVM,"C#, Javascript, Typescript, Visual Basic",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Async workflows, Quotations, Type providers, Units of measure","I can't use my knowledge from C# or other imperative languages, Don't understand the compiler errors","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Fad: They have concerns over long term language viability",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Efficiency/Performance","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Object-oriented features (inc. C# compatibility, conciseness), printf that is type checked, The ""piping"" idiom, Type inference","the tooling is.. how can I say.... not the best. I use Power tools for visual studio, a nice addition, but sometimes even with that help, it is hard. Maybe in a year from now I'll find my comment to be wrong, but when you are starting, you have to have a lot of commitment to make it work...

I believe the language is awesome, and I really like it more every day, but it's counterproductive when you have a few projects with dependencies between them, that you have to compile them to ""see"" the changes in the other projects. It's like c# visual studio in 2003.",,"More material with short ""cookbook"" style information",
17/04/2015 19:37:07,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"F# Weekly, HN, Reddit and other programming news sites","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Personal mentoring, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications, Data analysis/statistics",Internal enterprise projects,"SQL databases, Analytics",Visual Studio 2012 or newer,Windows,Windows,"LLVM, Native","C, C#, Javascript, Rust, Typescript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,Not enough real-world code to learn from,Training: They are worried about getting non-F# developers up to speed,I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,"Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Active Patterns, Backtick naming, Easy integration with other .NET libraries, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
17/04/2015 19:38:29,10 or more years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"F# Weekly, HN, Reddit and other programming news sites","MSDN, Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Answers to Stack Overflow questions, Personal mentoring, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Utilities and tools, Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications, Data analysis/statistics",Internal enterprise projects,"SQL databases, Analytics",Visual Studio 2012 or newer,Windows,Windows,"LLVM, Native","C, C#, Javascript, Rust, Typescript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,Not enough real-world code to learn from,Training: They are worried about getting non-F# developers up to speed,I'm willing to learn advanced concepts but only if they are relevant and practical,,1-2 years,,Enterprise development,,"Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Active Patterns, Backtick naming, Easy integration with other .NET libraries, Immutability by default, Interactive development, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
17/04/2015 20:10:14,10 or more years,"No, I don't know much theory",Just tinkering,,F# bloggers,"Links and instructions from fsharp.org, F# books, F# bloggers",,I don't use F# at work,"Utilities and tools, Games",Open source projects,SQL databases,Visual Studio 2010 or older,Windows,,JVM,"C#, C++",,"Better domain modelling with records and unions, Having fun again","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much",I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Data or analytics related,,Difficulty in troubleshooting problems,"Domain modelling: making illegal states unrepresentable, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
17/04/2015 20:10:21,10 or more years,"No, I don't know much theory",Just tinkering,,F# bloggers,"Links and instructions from fsharp.org, F# books, F# bloggers",,I don't use F# at work,"Utilities and tools, Games",Open source projects,SQL databases,Visual Studio 2010 or older,Windows,,JVM,"C#, C++",,"Better domain modelling with records and unions, Having fun again","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much",I'm willing to learn advanced concepts but only if they are relevant and practical,,4 or more years,,Data or analytics related,,Difficulty in troubleshooting problems,"Domain modelling: making illegal states unrepresentable, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Algebraic types (inc discriminated unions and tuples), Computation expressions, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom, Type inference, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
18/04/2015 00:27:36,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,F# bloggers,"Links and instructions from fsharp.org, F# books, F# bloggers, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Games, Mobile apps",Internal enterprise projects,Not doing data centric apps,Xamarin,Mac,"Mac, iOS",LLVM,"C#, C++",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Active Patterns, Type providers",,Training: They are worried about getting non-F# developers up to speed,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Computation expressions, Immutability by default, Quotations",,,,
18/04/2015 01:15:31,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, Google groups, HN, Reddit and other programming news sites, F# bloggers","F# books, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,"Windows, Mac",Windows,"None -- I'm happy with the CLR/Mono, JVM, Javascript",C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Having fun again, Learning functional programming in general, Speed of development","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)",,Lack of good tutorials/documentation,No perceived benefits: They don't understand what benefits F# has over C# or other languages,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Enterprise development,,,,"Easy integration with other .NET libraries, Immutability by default",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)",
18/04/2015 01:25:22,5-10 years,"No, I don't know much theory",I use it at work or for other commercial uses,,Twitter,"Links and instructions from fsharp.org, fsharpforfunandprofit",,It's officially endorsed for critical/production areas,Games,Game Logic,NoSQL database,Xamarin,Mac,iOS,None -- I'm happy with the CLR/Mono,"C#, Javascript, Objective-C",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Interactive development, Quotations",Installation process,Nothing. Everyone loves it.,I want to learn functional programming but I don't like academic jargon,,Less than a year,,Game development,,Lack of good wrappers for non-F# libraries,"Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers","Async workflows, Computation expressions",,,More material with in-depth tutorials,
18/04/2015 11:59:05,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,"F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Reading F# code written by experts",,It's used unofficially,"Machine learning, Data analysis/statistics, Other","Internal enterprise projects, Open source projects","SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,Windows,Javascript,"C, C#, Haskell, Java, Javascript, PHP, Python, Visual Basic",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Units of measure,Tooling in VS,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,Tooling compared to C#. ,2-3 years,,Serious amateur,,"Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Async workflows, Backtick naming, Computation expressions, Easy integration with other .NET libraries, Immutability by default, Interactive development, No dependency cycles, Object expressions, Object-oriented features (inc. C# compatibility, conciseness), Quotations, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",Comparing F# with existing code.,Better tooling and support in VS.,"More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
18/04/2015 13:09:27,10 or more years,"No, I don't know much theory",Just tinkering,,,"F# books, F# bloggers, Videos (e.g. Community for F#)",,It's officially endorsed for non-critical/non-production code,,,,Xamarin,"Windows, Mac",,"None -- I'm happy with the CLR/Mono, LLVM","C#, Haskell, Python, Visual Basic",,"Conciseness of code (I can see more at a glance), Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Computation expressions, Units of measure",,,I like theory -- I'm not afraid of monads and other abstractions,"I think the most important weakness is tooling:

1) Tools for application development in Visual Studio (refactoring, formatting etc.) are not so mature as those for C# or VB.NET
2) The interactive command line is not enough user-friendly (compared to Python or ghci)",1-2 years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc., Performance issues",,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, The ""piping"" idiom, Type providers",,,"More material with in-depth tutorials, More material with real-world examples and war stories","One comment to ""How do you use F# at work?"" section:

There's a mission option. Something like: ""F# is endorsed in the company but not in your team."""
18/04/2015 13:29:20,10 or more years,"No, I don't know much theory",I use it for hobby or side projects,,"Twitter, F# bloggers","MSDN, F# books, F# bloggers, Links posted on social media such as Twitter, Videos (e.g. Community for F#), fsharpforfunandprofit.com",,It's used unofficially,Utilities and tools,Some small internal tooling and scripts,Not doing data centric apps,Visual Studio 2012 or newer,Windows,,None -- I'm happy with the CLR/Mono,C#,,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Agents (MailboxProcessor), Async workflows, Computation expressions, Quotations, Static type constraints","Don't understand the compiler errors, Not enough real-world code to learn from, The perpetually conflicting statements about what monads are and whether or not I need to understand them.","No perceived benefits: They don't understand what benefits F# has over C# or other languages, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,"Tooling, and generally attention from tool developers. ReSharper (as the most important tool) will not support F# for years to come, and that not only affects features that work with the code itself, but also things like inspection, search and navigation. F# code will always be a blind spot for such functionality. That is a huge turnoff for people who are not enthusiastic about F# itself in the first place.

Also (yes, that's a second one), backing from Microsoft as a ""first-class"" .NET language. It's still mostly ""that library/science language we also have and some people seem to be crazy about for some odd reason"". And the tooling/integration inside Visual Studio is also far behind that for C# or VB.",1-2 years,,Enterprise development,,"Working with C#-centric tooling, Difficulty in troubleshooting problems, Considering their ubiquity, not being able to debug pipe chains step by step is probably one of the biggest frustrations","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Being able to use functional concepts and language constructs in an overall object-oriented setting","Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference","It's more learning of to *make use of* F# than the language itself, but what I personally find underrepresented in general F# coverage is going from functions and scripts to actual applications.","Currently, more visibility and actual promotion from Microsoft as a viable application development language would potentially be the most helpful thing. The next hurdle would likely be tooling/Visual Studio integration.","More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos",Hand out snacks halfway through. This is exhausting. :-)
18/04/2015 13:31:22,5-10 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Twitter, F# Weekly, F# bloggers","F# books, F# bloggers, Answers to Stack Overflow questions",,It's officially endorsed for critical/production areas,"Utilities and tools, Games, Text analysis/language parsing",Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, C++",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Having fun again, Learning functional programming in general, Functional but can be tweaked to get high performance",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Agents (MailboxProcessor), Computation expressions, Quotations, Type providers",My only constraint was personal time.,"Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,Not really treated equally with C# and VB in Visual Studio and esp. Resharper. Gives devs the impression that it's 'unofficial'. Also C# is pretty darn good already so it has tough competition. The language itself is amazing.,2-3 years,,Enterprise development,,"Not being part of the core .NET distribution, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.",I don't use it at work but other teams do. So I can't comment.,"Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, No dependency cycles, Simple ""one liner"" type definitions for records and DUs, Type inference, Units of measure","F# power tools need to be in Visual Studio out of the box with great syntax coloring. Wall of white text is scary.

Also Scott Wlaschin needs to release his functional programming book ;)",Grow in size and prove through real world projects that F# is useful.,"More material with in-depth tutorials, More material with real-world examples and war stories",
18/04/2015 14:04:24,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","F# books, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,It's officially endorsed for critical/production areas,"Financial services, Mainstream business & enterprise applications","Internal enterprise projects, Commercial products","SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Javascript, Typescript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general, Speed of development, Functional but can be tweaked to get high performance",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Object expressions, Quotations","Lack of good tutorials/documentation, Not enough real-world code to learn from","Hiring: They worry about not being able to find F# developers, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,2-3 years,,Enterprise development,,"Lack of good wrappers for non-F# libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Better for solving complex problems","Agents (MailboxProcessor), Algebraic types (inc discriminated unions and tuples), Backtick naming, Easy integration with other .NET libraries, Immutability by default, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers",,,"More material with real-world examples and war stories, More short ""live coding"" videos",
18/04/2015 14:20:54,5-10 years,"Yes, I enjoy computer science and mathematics",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Links mentioned in F# Weekly, Videos (e.g. Community for F#), Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Algorithm-heavy business applications (non-financial), Other","Internal enterprise projects, Commercial products, Open source projects","SQL databases, Event sourcing",Visual Studio 2012 or newer,"Windows, Mac, Linux","Windows, Mac, Linux","None -- I'm happy with the CLR/Mono, Javascript","C, C#, Javascript, Perl, Python",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Active Patterns, Computation expressions, Object expressions",Don't understand the compiler errors,"Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed",I'm willing to learn advanced concepts but only if they are relevant and practical,"1. Getting people over the hump of being too scared to use it or change what their currently using.

2. Tooling.  Just lack of folder support is a huge stopping force for folder crucial project like MVC.",Less than a year,,Enterprise development,,"Less sophisticated tools for refactoring, etc., Tooling, R# stealing keyboard shortcuts","Correctness: fewer bugs and less rework, More productive with fewer developers, Easy concurrency with async and agents","Agents (MailboxProcessor), Async workflows, Easy integration with other .NET libraries, Immutability by default, Interactive development, The ""piping"" idiom","The type inference is a scary thing for most beginners. If you don't have some type of intellisense, the beginner has to try to keep in their head what the function does, and if it's complicated, will lose track of whats happening.  

I also see frequent short value names like:
let myThing f v = ...
This is a sin in any language and doesn't help F# beginners for sure.

Seeing a |> and <| in the same line is impossible for beginners to wrap their head around.  The order of operations isn't usually explained well enough.


",,"More material with real-world examples and war stories, More podcasts and other audio-only material",
18/04/2015 14:28:26,10 or more years,,I use it for hobby or side projects,,"Twitter, F# bloggers","F# books, F# bloggers",,I don't use F# at work,"Mobile apps, Data analysis/statistics",Open source projects,Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,"Windows, WinPhone",Native,"C#, Typescript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Having fun again",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Agents (MailboxProcessor),Not enough real-world code to learn from,Big code base touched by many developers that don't know F#,,,3-4 years,,,,,,"Active Patterns, Algebraic types (inc discriminated unions and tuples), Interactive development, The ""piping"" idiom, Type providers",,,More material with in-depth tutorials,
18/04/2015 16:23:42,5-10 years,"No, I don't know much theory",Just tinkering,,"Google+, HN, Reddit and other programming news sites, F# bloggers","F# books, F# bloggers, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,LINQPad,Windows,Windows,"LLVM, Native","C, C#, C++",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community, Having fun again, Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Async workflows, Integration with non-F# libraries",Not enough real-world code to learn from,People are not aware about F# and it's benefits,I'm willing to learn advanced concepts but only if they are relevant and practical,I work in embedded so I guess performance can be an issue.,Less than two months,,Enterprise development,,,Correctness: fewer bugs and less rework,"Active Patterns, No dependency cycles, The ""piping"" idiom, Type inference",,Keep promoting,More material with real-world examples and war stories,
18/04/2015 17:48:45,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"Google groups, F# bloggers","Links and instructions from fsharp.org, F# books, F# bloggers, Answers to Stack Overflow questions, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,LLVM,"C#, C++, Javascript, Objective-C, Typescript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Quotations, Units of measure","Lack of good tutorials/documentation, Not enough real-world code to learn from","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Fad: They have concerns over long term language viability",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,"Not being part of the core .NET distribution, Lack of F# friendly libraries, Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.",,"Algebraic types (inc discriminated unions and tuples), Async workflows, Easy integration with other .NET libraries, Immutability by default, Interactive development, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
18/04/2015 18:53:19,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"F# Weekly, Reddit","MSDN, F# books, Links mentioned in F# Weekly",,I don't use F# at work,Utilities and tools,Not applicable. None of my F# code is used by other people,SQL databases,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, Python, Ruby, SQL",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Computation expressions, Quotations",Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Data or analytics related,,"Not being part of the core .NET distribution, Less sophisticated tools for refactoring, etc.",,"Easy integration with other .NET libraries, Immutability by default, Interactive development, Object-oriented features (inc. C# compatibility, conciseness), The ""piping"" idiom",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More interactive tutorials (e.g. like the F# Koans)",
18/04/2015 19:55:47,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,Twitter,content optimized for learning,,It's officially endorsed for critical/production areas,"Utilities and tools, Mainstream business & enterprise applications, Data analysis/statistics, Text analysis/language parsing","Commercial products, Open source projects","SQL databases, Read-only data sources such as feeds, Analytics",MonoDevelop,Linux,Linux,"None -- I'm happy with the CLR/Mono, JVM, LLVM, Native, replacable runtime just like in Haxe",Java,,expressive and strict language,Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Integration with non-F# libraries,Not enough real-world code to learn from,"Too Windows-centric: They have concerns over cross-platform issues, Too Microsoft-centric: They think it is too closely linked to Microsoft",I like theory -- I'm not afraid of monads and other abstractions,"1) strict memory model definition in CLR (!)
2) implement interoperability to be at least parity with C# eg.: unsafe (indirect load/safe IL instructions, managedptr), fixed struct, etc.
3) custom jit and/or code generation (with metaprogramming)
4) cost modeling is hard, it would be good to have some kind of resource awareness or cost model for each ""feature"" something like this:
http://raml.tcs.ifi.lmu.de/
http://lambda-the-ultimate.org/node/5021




",3-4 years,,Data or analytics related,,"Difficulty in troubleshooting problems, Cross-platform issues","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, More productive with fewer developers, Faster time to market, Efficiency/Performance, Easy concurrency with async and agents, Better for solving complex problems",compiler control (inline),"use the scientific method: model the learning process (mental model): what and how it happens then somebody get the ""functional programming"" ?","implement interoperability to be at least parity with C# eg.: unsafe (indirect load/safe IL instructions, managedptr), fixed struct, etc.","More material with in-depth tutorials, More material with real-world examples and war stories, More podcasts and other audio-only material, More interactive tutorials (e.g. like the F# Koans)",
18/04/2015 20:11:07,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,Twitter,"MSDN, F# books, F# bloggers, Links posted on social media such as Twitter, Answers to Stack Overflow questions, Videos (e.g. Community for F#), Reading F# code written by experts",,It's used unofficially,"Mainstream business & enterprise applications, Mobile apps, Other","Internal enterprise projects, Mostly in the works",SQL databases,Visual Studio 2012 or newer,Windows,"Windows, iOS, Android",,"C#, Javascript",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),"Agents (MailboxProcessor), Units of measure",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Too Microsoft-centric: They think it is too closely linked to Microsoft, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,I think memory allocation in the CLI.,Less than a year,Keep up the good work! While using other languages we often use functional programming principles already. It's probably good to point then out.,Enterprise development,,"Less sophisticated tools for refactoring, etc.",Correctness: fewer bugs and less rework,"The ""piping"" idiom, Type inference","I think we'll produced videos are underused, not only for F#. Understandably so, since they are time-consuming to make.",Keep convincing others  that functional programming and F# in particular is good for business,"More material with in-depth tutorials, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
18/04/2015 20:44:52,10 or more years,"Yes, I enjoy computer science and mathematics",Just tinkering,,F# bloggers,"F# books, Videos (e.g. Community for F#)",,It's used unofficially,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,Javascript,"C, C#, C++, Python",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Learning functional programming in general",Beginner (For example: you know OO well and functional programming seems strange),"Integration with non-F# libraries, Object-oriented compatibility","Lack of good tutorials/documentation, Not enough real-world code to learn from",,I'm willing to learn advanced concepts but only if they are relevant and practical,,Haven't really used it yet,,Science or related,,Working with C#-centric tooling,,"Active Patterns, Algebraic types (inc discriminated unions and tuples), The ""piping"" idiom",,,More material with real-world examples and war stories,
19/04/2015 01:00:33,2-5 years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,Twitter,"MSDN, Links and instructions from fsharp.org, F# bloggers, Links posted on social media such as Twitter, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,It's officially endorsed for non-critical/non-production code,"Utilities and tools, Algorithm-heavy business applications (non-financial), Mainstream business & enterprise applications","Internal enterprise projects, Not applicable. None of my F# code is used by other people","SQL databases, NoSQL database, Event sourcing",Visual Studio 2012 or newer,"Windows, Linux","Windows, Linux","None -- I'm happy with the CLR/Mono, Native","C#, Javascript, Python, Typescript",,"Better domain modelling with records and unions, Correctness (no nulls, it works first time), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),Type providers,"Lack of good tutorials/documentation, Unpleasant interactions with the community","No perceived benefits: They don't understand what benefits F# has over C# or other languages, Hiring: They worry about not being able to find F# developers, Money: They worry that good F# developers will cost too much, Training: They are worried about getting non-F# developers up to speed, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,"Less sophisticated tools for refactoring, etc., Difficulty in troubleshooting problems, Performance issues","Domain modelling: making illegal states unrepresentable, Easy concurrency with async and agents, Better for solving complex problems","Active Patterns, Agents (MailboxProcessor), Async workflows, Backtick naming, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More interactive tutorials (e.g. like the F# Koans)","Same issues with all conversations around functional programmers, a slight but real air of superiority... that puts a lot of people off. I don't like ruby, but I like the culture. MINASWAN."
19/04/2015 01:43:36,2-5 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,,,,,,,,Visual Studio 2012 or newer,Windows,,,"C#, Java, Javascript",,,Beginner (For example: you know OO well and functional programming seems strange),,,,,,Haven't really used it yet,,Enterprise development,,,,,,,,
19/04/2015 03:10:09,5-10 years,"Yes, I enjoy computer science and mathematics",Just tinkering,,"F# Weekly, HN, Reddit and other programming news sites","Links and instructions from fsharp.org, F# books, F# bloggers, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,LLVM,"C#, C++",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Learning functional programming in general","Learner (For example: You're comfortable using piping and higher-order functions, but you often need to use mutability and OO idioms)","Agents (MailboxProcessor), Async workflows, Static type constraints",Lack of good tutorials/documentation,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Fad: They have concerns over long term language viability, No buy-in: There is lack of acceptance from other teams",I'm willing to learn advanced concepts but only if they are relevant and practical,,Haven't really used it yet,,Enterprise development,,,,"Active Patterns, Algebraic types (inc discriminated unions and tuples), No dependency cycles, The ""piping"" idiom",,,More material with real-world examples and war stories,
19/04/2015 07:31:43,5-10 years,"No, I don't know much theory",I use it at work or for other commercial uses,,"HN, Reddit and other programming news sites, F# bloggers","F# bloggers, Reading F# code written by experts",,It's officially endorsed for critical/production areas,"Financial services, Mainstream business & enterprise applications",Commercial products,"SQL databases, NoSQL database",Visual Studio 2012 or newer,Windows,Windows,JVM,"C#, Java, Javascript, Python",,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Speed of development",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Async workflows, Interactive development, Units of measure",Not enough real-world code to learn from,"It's difficult to migrate existing .net code bases to F# -- visual studio supports one language per project only. Cannot mix-and-match, cannot incrementally adopt F#",I'm willing to learn advanced concepts but only if they are relevant and practical,"There should be more beginner friendly resources to learn from. 

F# is a great language to learn if you're just starting out with programming – but most resources out there assume you're an experienced programmer. I don't think I saw any books for complete beginners. (I could be wrong about this, haven't looked at learning resources in a while)

A ""Learn F# the Hard Way"" book would be super awesome.
",1-2 years,,Startup,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Correctness: fewer bugs and less rework, More productive with fewer developers, Better for solving complex problems","Algebraic types (inc discriminated unions and tuples), Immutability by default, The ""piping"" idiom, Type providers","It would be great if there are more examples of end to end F# applications. For example, websites or client applications written completely in F# – the entire stack.","We should have a F# conference in India.

ClearTax can help host :)","More material with in-depth tutorials, More interactive tutorials (e.g. like the F# Koans)",
19/04/2015 08:56:47,10 or more years,"No, I don't know much theory",I use it at work or for other commercial uses,,"Twitter, F# Weekly, F# bloggers","Links and instructions from fsharp.org, F# books, Links posted on social media such as Twitter, Links mentioned in F# Weekly",,It's officially endorsed for critical/production areas,"Utilities and tools, Custom development/specialist markets, Machine learning, Mobile apps, Text analysis/language parsing, Other","Internal enterprise projects, Commercial products","SQL databases, NoSQL database, Event sourcing",Vim,Windows,"Windows, Azure",None -- I'm happy with the CLR/Mono,"C#, Javascript, Typescript",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time), Great community",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor)",Not enough real-world code to learn from,Nothing. Everyone loves it.,I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,Enterprise development,,"Working with C#-centric tooling, Less sophisticated tools for refactoring, etc.","Domain modelling: making illegal states unrepresentable, Correctness: fewer bugs and less rework, Easy concurrency with async and agents, Better for solving complex problems","Backtick naming, Computation expressions, Immutability by default, Simple ""one liner"" type definitions for records and DUs, The ""piping"" idiom, Type inference, Type providers, Units of measure",,,"More material with in-depth tutorials, More material with real-world examples and war stories, More short ""live coding"" videos",
19/04/2015 09:08:47,2-5 years,"No, I don't know much theory",Just tinkering,,,MSDN,,I don't use F# at work,None - Just playing around,Not applicable. None of my F# code is used by other people,Read-only data sources such as feeds,Visual Studio 2012 or newer,Windows,,"Native, Erlang VM","Haskell, Fortran",,Functional but can be tweaked to get high performance,Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),Object-oriented compatibility,Not as beautiful as haskell,,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than two months,,Student,,Working with C#-centric tooling,,"Async workflows, Easy integration with other .NET libraries, Interactive development",,,"More material with short ""cookbook"" style information",
19/04/2015 15:20:36,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for research or academic work,,StackOverflow chat,F# books,,I don't use F# at work,Research/Teaching,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2010 or older,Windows,Windows,,"C, C++",,"Having fun again, Learning functional programming in general, Speed of development",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,Not enough real-world code to learn from,No buy-in: There is lack of acceptance from other teams,I like theory -- I'm not afraid of monads and other abstractions,,2-3 years,,"Academic, research, or related",,Difficulty in troubleshooting problems,,"Algebraic types (inc discriminated unions and tuples), Interactive development",,,"More material with short ""cookbook"" style information",
19/04/2015 18:17:21,10 or more years,"Yes, I enjoy computer science and mathematics",I use it for hobby or side projects,,"Google+, F# bloggers","Links and instructions from fsharp.org, F# books",,I don't use F# at work,Other,Not applicable. None of my F# code is used by other people,Not doing data centric apps,Visual Studio 2012 or newer,Windows,Windows,None -- I'm happy with the CLR/Mono,"C#, C++, Perl",,"Conciseness of code (I can see more at a glance), Learning functional programming in general",Experienced (For example: You are very comfortable using a wide range of algebraic types. You rely on type inference and rarely use type annotations; You design your code to benefit from exhaustive pattern matching; You use automatic generalization to make your functions as generic as possible.),"Active Patterns, Agents (MailboxProcessor), Async workflows, Computation expressions, Object-oriented compatibility, Quotations, Type providers",,"No perceived benefits: They don't understand what benefits F# has over C# or other languages, Training: They are worried about getting non-F# developers up to speed",I like theory -- I'm not afraid of monads and other abstractions,,4 or more years,,Enterprise development,,Difficulty in troubleshooting problems,,"Algebraic types (inc discriminated unions and tuples), Easy integration with other .NET libraries, Immutability by default, Interactive development, The ""piping"" idiom, Type inference",,,,
20/04/2015 00:01:09,Less than a year,"No, I don't know much theory",Just tinkering,,F# Weekly,"F# books, F# bloggers, Links mentioned in F# Weekly, Videos (e.g. Community for F#)",,I don't use F# at work,None - Just playing around,Open source projects,SQL databases,Visual Studio 2012 or newer,Windows,"Windows, Mac, Linux, iOS, Android, WinPhone, Azure",None -- I'm happy with the CLR/Mono,Python,,"Conciseness of code (I can see more at a glance), Correctness (no nulls, it works first time)",Beginner (For example: you know OO well and functional programming seems strange),Quotations,"Lack of good tutorials/documentation, Not enough real-world code to learn from",,I want to learn functional programming but I don't like academic jargon,,Haven't really used it yet,,Student,,Cross-platform issues,,"The ""piping"" idiom",,,"More material with in-depth tutorials, More material with short ""cookbook"" style information, More material with real-world examples and war stories, More short ""live coding"" videos, More interactive tutorials (e.g. like the F# Koans)",
20/04/2015 07:54:01,2-5 years,"No, I don't know much theory",I use it for hobby or side projects,,,,,I don't use F# at work,,,,Visual Studio 2012 or newer,Windows,,,"C#, C++",,"Better domain modelling with records and unions, Conciseness of code (I can see more at a glance), Learning functional programming in general",Intermediate (For example: You create your own higher-order functions regularly and you're comfortable using partial application; You embrace immutability by default.),,,,I'm willing to learn advanced concepts but only if they are relevant and practical,,Less than a year,,Enterprise development,,,,,,,"More material with in-depth tutorials, More material with real-world examples and war stories",